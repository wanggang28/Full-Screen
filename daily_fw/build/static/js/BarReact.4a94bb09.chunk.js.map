{"version":3,"sources":["../static/js/BarReact.4a94bb09.chunk.js","EchartsDemo/BarReact.js","../node_modules/echarts/lib/component/axisPointer/modelHelper.js","../node_modules/echarts/lib/component/axis/AxisBuilder.js","../node_modules/echarts/lib/component/axis/AxisView.js","../node_modules/echarts/lib/component/axisPointer.js","../node_modules/echarts/lib/component/axisPointer/viewHelper.js","../node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js","../node_modules/echarts/lib/component/axisPointer/globalListener.js","../node_modules/echarts/lib/component/gridSimple.js","../node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js","../node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js","../node_modules/echarts/lib/visual/symbol.js","../node_modules/echarts/lib/chart/helper/createListSimply.js","../node_modules/echarts/lib/coord/cartesian/AxisModel.js","../node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js","../node_modules/echarts/lib/component/tooltip.js","../node_modules/echarts/lib/coord/cartesian/Grid.js","../node_modules/echarts/lib/coord/axisModelCreator.js","../node_modules/echarts/lib/coord/axisDefault.js","../node_modules/echarts/lib/chart/helper/Symbol.js","../node_modules/echarts/lib/layout/points.js","../node_modules/echarts/lib/component/axisPointer/axisTrigger.js","../node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js","../node_modules/echarts/lib/component/axisPointer/AxisPointerView.js","../node_modules/echarts/lib/component/tooltip/TooltipModel.js","../node_modules/echarts/lib/component/tooltip/TooltipView.js","../node_modules/echarts/lib/component/tooltip/TooltipContent.js","../node_modules/echarts/lib/processor/dataFilter.js","../node_modules/echarts/lib/chart/helper/SymbolDraw.js","../node_modules/echarts/lib/component/legend.js","../node_modules/echarts/lib/component/legend/LegendModel.js","../node_modules/echarts/lib/component/legend/LegendView.js","../node_modules/echarts/lib/component/helper/listComponent.js","../node_modules/echarts/lib/visual/dataColor.js","../node_modules/echarts/lib/chart/helper/labelHelper.js","../node_modules/echarts/lib/component/legend/legendAction.js","../node_modules/echarts/lib/component/legend/legendFilter.js","../node_modules/echarts/lib/component/grid.js","../node_modules/echarts/lib/coord/cartesian/Cartesian2D.js","../node_modules/echarts/lib/coord/cartesian/Cartesian.js","../node_modules/echarts/lib/coord/cartesian/Axis2D.js","../node_modules/echarts/lib/coord/cartesian/GridModel.js","../node_modules/echarts/lib/component/axis.js","../node_modules/echarts/lib/component/axis/CartesianAxisView.js","../node_modules/echarts/lib/chart/line/helper.js","../node_modules/echarts/lib/component/helper/selectableMixin.js","../node_modules/echarts/lib/action/createDataSelectAction.js","../node_modules/echarts/lib/chart/line/poly.js","../node_modules/echarts/lib/chart/pie.js","../node_modules/echarts/lib/chart/pie/PieSeries.js","../node_modules/echarts/lib/chart/pie/PieView.js","../node_modules/echarts/lib/chart/pie/pieLayout.js","../node_modules/echarts/lib/chart/pie/labelLayout.js","../node_modules/echarts/lib/chart/line.js","../node_modules/echarts/lib/chart/line/LineSeries.js","../node_modules/echarts/lib/chart/line/LineView.js","../node_modules/echarts/lib/chart/line/lineAnimationDiff.js","../node_modules/echarts/lib/processor/dataSample.js","../node_modules/echarts/lib/chart/bar/BaseBarSeries.js","../node_modules/echarts/lib/chart/bar/helper.js","../node_modules/echarts/lib/chart/bar.js","../node_modules/echarts/lib/chart/bar/BarSeries.js","../node_modules/echarts/lib/chart/bar/BarView.js","../node_modules/echarts/lib/chart/bar/barItemStyle.js"],"names":["webpackJsonp","Array","concat","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default","__WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip__","__WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_grid__","__WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_bar__","__WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_legend__","__WEBPACK_IMPORTED_MODULE_6_echarts_lib_chart_pie__","__WEBPACK_IMPORTED_MODULE_7_echarts_lib_chart_line__","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","BarReact","_React$Component","this","_this","getPrototypeOf","initPie","bind","_props$option","option","undefined","myChart","a","init","ID","setOption","window","onresize","resize","_this2","_props","_props$width","width","_props$height","height","createElement","ref","style","Component","exports","collect","ecModel","api","result","axesInfo","seriesInvolved","coordSysAxesInfo","coordSysMap","collectAxesInfo","collectSeriesInfo","globalTooltipModel","getComponent","globalAxisPointerModel","linksOption","get","linkGroups","each","getCoordinateSystems","coordSys","saveTooltipAxisInfo","fromTooltip","triggerTooltip","axis","axisPointerModel","model","getModel","axisPointerShow","isHandleTrigger","makeAxisPointerModel","baseTooltipModel","snap","makeKey","involveSeries","type","axisInfo","useHandle","seriesModels","axesInfoInCoordSys","groupIndex","getLinkGroupIndex","linkGroup","mapper","axisPointerEnabled","coordSysKey","coordSysModel","getAxes","curry","getTooltipAxes","triggerAxis","cross","tooltipAxes","baseAxes","otherAxes","tooltipAxisPointerModel","volatileOption","field","zrUtil","clone","labelOption","label","show","tooltipAxisPointerLabelShow","crossStyle","lineStyle","defaults","textStyle","Model","eachSeries","seriesModel","coordinateSystem","seriesTooltipTrigger","seriesTooltipShow","getAxis","dim","push","seriesDataCount","getData","count","axisModel","linkOption","checkPropInLink","id","componentIndex","name","linkPropValue","axisPropValue","isArray","indexOf","fixValue","getAxisInfo","scale","status","parse","extent","getExtent","slice","reverse","isBlank","getAxisPointerModel","makeAxisEventDataBase","eventData","componentType","mainType","endTextLayout","opt","textPosition","textRotate","textAlign","textVerticalAlign","rotationDiff","remRadian","rotation","inverse","onLeft","isRadianAroundZero","PI","isSilent","tooltipOpt","fixMinMaxLabelShow","labelEls","tickEls","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","el","ignore","current","next","labelLayout","firstRect","getBoundingRect","nextRect","mRotationBack","matrixUtil","identity","rotate","applyTransform","mul","getLocalTransform","intersect","isNameLocationCenter","nameLocation","buildAxisTick","axisBuilder","tickModel","lineStyleModel","tickLen","ticksCoords","getTicksCoords","pt1","pt2","matrix","_transform","tickCoord","coord","tickDirection","v2ApplyTransform","tickEl","graphic","Line","subPixelOptimizeLine","anid","tickValue","shape","x1","y1","x2","y2","getLineStyle","stroke","z2","silent","group","add","buildAxisLabel","retrieve","axisLabelShow","labelModel","labelMargin","labels","getViewLabels","labelRotation","labelRotate","innerTextLayout","labelDirection","rawCategoryData","getCategories","triggerEvent","labelItem","index","formattedLabel","rawLabel","itemLabelModel","textColor","getTextColor","dataToCoord","pos","labelOffset","textEl","Text","position","setTextStyle","text","getShallow","textFill","targetType","_dumbGroup","updateTransform","decomposeTransform","_util","extend","formatUtil","_number","_symbol","createSymbol","_vector","Math","AxisBuilder","nameDirection","Group","dumbGroup","transform","hasBuilder","builders","getGroup","axisLine","lineCap","strokeContainThreshold","arrows","arrowSize","arrowOffset","symbolWidth","symbolHeight","offset","r","sqrt","point","symbol","cos","sin","attr","axisTickLabel","axisName","textStyleModel","gap","gapSignal","nameRotation","axisNameAvailableWidth","abs","isFinite","textFont","getFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","truncatedText","truncateText","minChar","placeholder","formatterParams","$vars","__fullText","__truncatedText","tooltip","content","formatter","axisRotation","textRotation","direction","_default","updateAxisPointer","axisView","payload","forceRender","Clazz","AxisView","getAxisPointerClass","axisPointerClass","axisPointerModelHelper","_axisPointer","render","disposeAxisPointer","axisPointer","dispose","_config","echarts","__DEV__","extendComponentView","superApply","arguments","force","remove","axisPointerClazz","registerAxisPointerClass","clazz","axisTrigger","registerPreprocessor","link","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","registerAction","event","update","buildElStyle","axisPointerType","styleModel","fill","getAreaStyle","buildLabelElOption","elOption","labelPos","getValueLabel","precision","paddings","normalizeCssArray","font","textRect","textContain","align","verticalAlign","confineInContainer","bgColor","x","y","lineWidth","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","viewWidth","getWidth","viewHeight","getHeight","min","max","seriesDataIndices","getLabel","params","axisHelper","getAxisRawValue","seriesData","idxItem","series","getSeriesByIndex","seriesIndex","dataIndex","dataIndexInside","dataParams","getDataParams","isString","replace","isFunction","getTransformedPosition","layoutInfo","translate","buildCartesianSingleLabelElOption","textLayout","makeLineShape","p1","p2","xDimIndex","makeRectShape","xy","wh","makeSectorShape","cx","cy","r0","startAngle","endAngle","clockwise","finder","data","modelUtil","queryDataIndex","getItemGraphicEl","getTooltipPosition","dataToPoint","getValues","map","dimensions","mapDimension","rect","register","handler","env","node","zr","getZr","inner","records","initGlobalListeners","useHandler","eventType","cb","on","e","dis","makeDispatchAction","record","dispatchAction","dispatchTooltipFinally","pendings","initialized","doEnter","onLeave","actuallyPayload","showLen","showTip","hideLen","hideTip","currTrigger","pendingList","unregister","_model","makeInner","gridModel","removeAll","Rect","getRect","getItemStyle","xAxis","yAxis","grid","getCartesian","getAxisDimIndex","BaseAxisPointer","viewHelper","cartesianAxisHelper","CartesianAxisPointer","makeElOption","otherExtent","getOtherAxis","getGlobalExtent","pixelValue","toGlobalCoord","elStyle","pointerOption","pointerShapeBuilder","graphicKey","pointer","layout","getHandleTransform","labelInside","updateHandleTransform","delta","axisExtent","dimIndex","currPosition","cursorOtherValue","cursorPoint","tooltipOptions","tooltipOption","line","targetShape","shadow","bandWidth","getBandWidth","span","otherAxisOnZeroOf","getAxesOnZeroOf","rawAxisPosition","axisPosition","axisDim","rectBound","idx","left","right","top","bottom","onZero","axisOffset","posBound","onZeroCoord","dirMap","seriesType","defaultSymbolType","legendSymbol","performRawSeries","reset","dataEach","symbolSize","rawValue","getRawValue","setItemVisual","hasItemOption","itemModel","getItemModel","itemSymbolType","itemSymbolSize","itemSymbolKeepAspect","symbolType","keepAspect","setVisual","symbolKeepAspect","isSeriesFiltered","hasCallback","nameList","coordDimensions","source","getSource","dimensionsInfo","createDimensions","list","List","initData","getAxisType","ComponentModel","axisModelCreator","axisModelCommonMixin","AxisModel","resetRange","mergeOption","restoreData","getCoordSysModel","queryComponents","gridIndex","gridId","merge","extraOption","updateProps","animationModel","moveAnimation","propsEqual","lastProp","stopAnimation","lastProps","newProps","isObject","equals","item","updateLabelShowHide","labelEl","getHandleTransProps","trans","updateMandatoryProps","z","zlevel","traverse","clazzUtil","eventTool","throttleUtil","_group","_lastGraphicKey","_handle","_dragging","_lastValue","_lastStatus","_payloadInfo","animationThreshold","_axisModel","_axisPointerModel","_api","handle","hide","clear","_moveAnimation","determineAnimation","doUpdateProps","updatePointerEl","updateLabelEl","createPointerEl","createLabelEl","_renderHandle","animation","isCategoryAxis","useSnap","pointerEl","setStyle","handleModel","isInit","createIcon","cursor","draggable","onmousemove","stop","onmousedown","_onHandleDragMove","drift","ondragend","_onHandleDragEnd","includeStyles","handleSize","createOrUpdate","_moveHandleToValue","dx","dy","_doDispatchAxisPointer","payloadInfo","axisIndex","doClear","buildLabel","enableClassExtend","isAxisUsedInTheGrid","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","fixAxisOnZero","axesMap","otherAxisDim","otherAxis","onZeroAxisIndex","canOnZeroToAxis","hasOwnProperty","ifAxisCrossZero","updateAxisTransform","coordBase","axisExtentSum","toLocalCoord","findAxesModels","axesTypes","axisType","getReferringComponents","isCartesian2D","_layout","getLayoutRect","_axisHelper","createScaleByModel","niceScaleExtent","estimateLabelUnionRect","Cartesian2D","Axis2D","CoordinateSystem","_dataStackHelper","getStackedDimension","gridProto","_rect","_updateScale","ignoreContainLabel","adjustAxes","axesList","isHorizontal","gridRect","setExtent","getBoxLayoutParams","labelUnionRect","margin","axesMapOnDim","xAxisIndex","yAxisIndex","coordList","getCartesians","convertToPixel","_findConvertTarget","cartesian","convertFromPixel","pointToData","coordToData","xAxisModel","yAxisModel","coordsList","containPoint","createAxisCreator","axisPositionUsed","isCategory","onBand","axesCount","eachComponent","addAxis","unionExtent","unionExtentFromData","Infinity","axesModels","baseAxis","getBaseAxis","grids","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","AXIS_TYPES","mergeDefaultAndTheme","layoutMode","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","optionUpdated","__ordinalMeta","OrdinalMeta","createByAxisModel","rawData","categories","getOrdinalMeta","defaultOption","mergeAll","axisDefault","registerSubTypeDefaulter","nameRotate","nameTruncate","nameTextStyle","nameGap","color","axisTick","inside","axisLabel","fontSize","splitLine","splitArea","areaStyle","categoryAxis","boundaryGap","deduplication","alignWithLabel","interval","valueAxis","splitNumber","timeAxis","logAxis","logBase","SymbolClz","seriesScope","updateData","getScale","driftSymbol","parent","parsePercent","_labelHelper","getDefaultLabel","symbolProto","getSymbolSize","getItemVisual","_createSymbol","symbolPath","culling","_symbolType","stopSymbolAnimation","toLastFrame","childAt","getSymbolPath","highlight","trigger","downplay","setZ","setDraggable","hostModel","_updateCommon","fadeIn","opacity","initProps","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","getLabelDefaultText","useNameLabel","getName","useStyle","strokeNoScale","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","hoverLabelModel","hoverAnimation","cursorStyle","setColor","symbolInnerColor","liftZ","z2Origin","__z2Origin","setLabelStyle","labelFetcher","labelDataIndex","defaultText","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","incremental","ratio","animateTo","onNormal","fadeOut","keepLabel","inherits","plan","createRenderPlanner","progress","segCount","end","start","points","isLargeRender","Float32Array","dimLen","tmpIn","tmpOut","dims","isNaN","NaN","setItemLayout","setLayout","pipelineContext","large","stackResultDim","getCalculationInfo","isDimensionStacked","illegalPoint","findPointFromSeries","isIllegalPoint","inputAxesInfo","shouldHide","outputFinder","showValueMap","dataByCoordSys","updaters","showPointer","showTooltip","coordSysContainsPoint","inputAxisInfo","findInputAxisInfo","val","processOnAxis","linkTriggers","tarAxisInfo","tarKey","srcAxisInfo","srcKey","srcValItem","makeMapperParam","updateModelActually","dispatchTooltipActually","dispatchHighDownActually","newValue","dontSnap","containData","buildPayloadsBySeries","payloadBatch","snapToValue","minDist","Number","MAX_VALUE","minDiff","seriesNestestValue","dataIndices","dataDim","getAxisTooltipData","nestestValue","indicesOfNearest","diff","dist","getRawIndex","modelHelper","coordSysItem","coordSysId","coordSysIndex","coordSysType","coordSysMainType","dataByAxis","axisId","valueLabelOpt","outputAxesInfo","valItem","sampleItem","escapeConnect","lastHighlights","newHighlights","batchItem","toHighlight","toDownplay","batch","AxisPointerModel","extendComponentModel","triggerOn","animationDurationUpdate","shadowStyle","padding","backgroundColor","borderColor","borderWidth","icon","size","throttle","globalListener","AxisPointerView","offsetX","offsetY","dependencies","showContent","alwaysShowContent","displayMode","confine","showDelay","hideDelay","transitionDuration","enterable","borderRadius","extraCssText","animationEasingUpdate","buildTooltipModel","modelCascade","resultModel","pop","isInstance","refixTooltipPosition","gapH","gapV","getOuterSize","confineTooltipPosition","clientWidth","clientHeight","document","defaultView","getComputedStyle","stl","parseInt","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","calcTooltipPosition","contentSize","domWidth","domHeight","rectWidth","rectHeight","isCenterAlign","TooltipContent","numberUtil","layoutUtil","axisPointerViewHelper","proxyRect","tooltipContent","getDom","_tooltipContent","tooltipModel","wxa","_tooltipModel","_ecModel","_lastDataByCoordSys","_alwaysShowContent","setEnterable","_initGlobalListener","_keepShow","_tryShow","_hide","_lastX","_lastY","clearTimeout","_refreshUpdateTimeout","setTimeout","manuallyShowTip","from","uid","_ticket","_manuallyAxisShowTip","pointInfo","findHover","manuallyHideTip","hideLater","_showAxisTooltip","_showSeriesItemTooltip","_showComponentItemTooltip","_showOrMove","delay","_showTimout","singleDefaultHTML","singleParamsList","singleTooltipModel","itemCoordSys","axisValue","seriesDefaultHTML","valueLabel","axisValueLabel","formatTooltip","firstLine","encodeHTML","join","positionExpr","_updateContentNotChangedOnAxis","_updatePosition","_showTooltipContent","random","dataModel","dataType","tooltipTrigger","defaultHtml","asyncTicket","subTooltipModel","html","formatTpl","callback","cbTicket","setContent","getSize","vAlign","viewSize","layoutRect","moveTo","lastCoordSys","contentNotChanged","lastItemCoordSys","indexCoordSys","lastDataByAxis","thisItemCoordSys","thisDataByAxis","lastItem","indexAxis","thisItem","lastIndices","newIndices","lastIdxItem","j","newIdxItem","assembleTransition","duration","transitionText","vendors","vendorPrefix","assembleFont","cssText","round","assembleCssText","canvasSupported","zrColor","toHex","borderName","camelCase","toCamelCase","container","_zr","_x","_y","appendChild","_container","_show","_hideTimeout","onmouseenter","_enterable","_inContent","eventUtil","normalizeEvent","dispatch","onmouseleave","_hideDelay","currentStyle","domStyle","display","innerHTML","viewportRootOffset","painter","getViewportRootOffset","offsetLeft","offsetTop","time","isShow","legendModels","findComponents","filterSelf","isSelected","SymbolDraw","symbolCtor","_symbolCtor","symbolNeedsDraw","isIgnore","clipShape","contain","normalizeUpdateOpt","makeSeriesScope","symbolDrawProto","oldData","_data","SymbolCtor","newIdx","getItemLayout","symbolEl","setItemGraphicEl","oldIdx","execute","isPersistent","updateLayout","eachItemGraphicEl","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","useHoverLayer","enableAnimation","legendFilter","isNameSpecified","LegendModel","ignoreSize","parentModel","selected","superCall","_updateData","legendData","hasSelected","select","potentialData","availableNames","eachRawSeries","seriesName","isPotential","legendDataProvider","names","mapArray","_availableNames","dataItem","unSelect","toggleSelected","orient","itemGap","itemWidth","itemHeight","inactiveColor","selectedMode","dispatchSelectAction","dispatchHighlightAction","dataName","excludeSeriesId","storage","getDisplayList","dispatchDownplayAction","_listComponent","makeBackground","newlineDisabled","_contentGroup","_backgroundEl","getContentGroup","legendModel","resetInner","itemAlign","renderInner","positionInfo","viewportSize","maxSize","mainRect","layoutInner","contentGroup","legendDrawnMap","createHashMap","selectMode","newline","getSeriesByName","getVisual","legendSymbolType","itemGroup","_createItem","set","indexOfName","itemIcon","legendGlobalTooltipModel","textX","hitRect","invisible","legendIndex","eachChild","child","__legendDataIndex","box","contentRect","componentModel","boxLayoutParams","layoutBox","positionElement","getTargetSeries","paletteScope","seiresModelMap","eachSeriesByType","__paletteScope","dataAll","getRawData","idxMap","rawIdx","filteredIdx","singleDataColor","getColorFromPalette","labelDims","len","retrieveRawValue","vals","_dataProvider","legendSelectActionHandler","methodName","selectedMap","isToggleSelect","isItemSelected","filterSeries","Cartesian","getAxesByScale","axisX","axisY","reserved","out","clampData","xScale","yScale","xAxisExtent","yAxisExtent","dimAxisMapper","_axes","_dimList","scaleType","toLowerCase","filter","_dataCoordConvert","input","method","dimList","output","Axis","coordExtent","asc","ret","clamp","containLabel","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","oldAxisGroup","_axisGroup","groupTransition","_splitAreaColors","_splitLine","splitLineModel","lineColors","lineCount","colorIndex","_splitArea","splitAreaModel","areaStyleModel","areaColors","areaColorsLen","lastSplitAreaColors","newSplitAreaColors","cIndex","prev","prepareDataCoordInfo","valueOrigin","stacked","valueStart","getValueStart","baseAxisDim","valueAxisDim","valueDim","baseDim","baseDataOffset","coordDim","dataDimsForPoint","stackedOverDimension","getStackedOnPoint","dataCoordInfo","stackedData","updateSelectedMap","targetList","_targetList","_selectTargetMap","reduce","targetMap","actionInfos","actionInfo","subType","query","isPointNull","p","drawSegment","ctx","segLen","allLen","dir","smoothMin","smoothMax","smooth","smoothMonotone","connectNulls","drawMono","apply","drawNonMono","prevIdx","k","prevP","ctrlLen","v2Copy","cp0","cp1","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","vec2","sub","v","lenPrevSeg","lenNextSeg","scaleAndAdd","vec2Min","vec2Max","getBoundingBox","smoothConstraint","ptMin","ptMax","pt","Path","fixClipWithShadow","copy","Polyline","brush","buildPath","Polygon","stackedOnPoints","stackedOnSmooth","bbox","stackedOnBBox","closePath","createDataSelectAction","dataColor","pieLayout","dataFilter","registerVisual","registerLayout","createListSimply","getPercentWithPrecision","dataSelectableMixin","retrieveRawAttr","PieSeries","extendSeriesModel","_createSelectableList","_defaultLabelLine","newOption","getInitialData","valueList","percent","defaultEmphasis","labelLineNormalOpt","labelLine","labelLineEmphasisOpt","emphasis","legendHoverLink","center","radius","minAngle","selectedOffset","hoverOffset","avoidLabelOverlap","percentPrecision","stillShowZeroSum","length2","animationType","animationEasing","mixin","updateDataSelected","hasAnimation","seriesId","toggleItemSelected","midAngle","animate","when","PiePiece","polyline","hoverIgnore","normalIgnore","sector","Sector","ChartView","piePieceProto","firstCreate","sectorShape","setShape","visualColor","lineJoin","_updateLabel","labelText","linePoints","origin","labelHoverModel","labelLineModel","labelLineHoverModel","useInsideStyle","PieView","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","piePiece","removeClipPath","setClipPath","_createClipPath","clipPath","itemLayout","RADIAN","validDataCount","sum","getSum","unitRadian","roseType","getDataExtent","restAngle","PI2","valueSumLargerThanMinAngle","currentAngle","angle","linearMap","adjustSingleSide","shiftUp","changeX","isDownList","lastDeltaX","l","deltaY","len2","deltaX","sort","b","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textY","labelPosition","labelLineLen","labelLineLen2","isLabelInside","x3","y3","getFormattedLabel","visualSymbol","layoutPoints","dataSample","createListFromArray","SeriesModel","clipOverflow","step","showSymbol","showAllSymbol","sampling","progressive","hoverLayerThreshold","isPointsSame","points1","points2","getSmooth","getAxisExtentWithGap","halfBandWidth","getStackedOnPoints","createGridClipShape","forSymbol","xExtent","yExtent","expandSize","createPolarClipShape","polar","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","visualMeta","dimension","dimName","dimInfo","getDimensionInfo","colorStops","stops","stopLen","outerColors","minCoord","maxCoord","coordSpan","unshift","gradient","LinearGradient","getIsIgnoreFunc","isAuto","canShowAllSymbolForCategory","categoryDataDim","labelMap","availSize","dataLen","lineAnimationDiff","_poly","_helper","lineGroup","symbolDraw","_symbolDraw","_lineGroup","isCoordSysPolar","prevCoordSys","_coordSys","_polyline","polygon","_polygon","isAreaChart","isEmpty","isIgnoreFunc","__temp","_step","_newPolygon","_stackedOnPoints","_points","_updateAnimation","_newPolyline","stackedOnSeries","_valueOrigin","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","cmd","idx1","ptIdx","animators","during","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","diffItem","pointAdded","currentPt","rawIndex","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","modifyOutputEnd","rate","sampler","samplers","setData","downSample","indexSampler","average","frame","nearest","getMarkerPosition","getLayout","barMinHeight","barMinAngle","largeThreshold","progressiveChunkMode","setLabel","normalStyle","labelPositionOutside","fixPosition","_barGrid","largeLayout","BaseBarSeries","brushSelector","getProgressive","getProgressiveThreshold","progressiveThreshold","removeRect","removeSector","updateStyle","isPolar","itemStyleModel","getBarItemStyle","getLineWidth","rawLayout","BAR_BORDER_WIDTH_QUERY","createLarge","startPoint","valueIdx","LargePath","__startPoint","__valueIdx","setLargeStyle","barItemStyle","extendChartView","_updateDrawMode","coordinateSystemType","_isLargeDraw","_renderLarge","_renderNormal","incrementalPrepareRender","_clear","incrementalRender","_incrementalRenderLarge","isLargeDraw","isHorizontalOrRadial","hasValue","elementCreator","newIndex","oldIndex","noop","cartesian2d","isUpdate","rectShape","animateProperty","animateTarget","isRadial","fixedLineWidth","signX","signY","makeStyleMapper","excludes","getBorderLineDash","lineDash"],"mappings":"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","file":"static/js/BarReact.4a94bb09.chunk.js","sourcesContent":["webpackJsonp([1],Array(175).concat([\n/* 175 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__ = __webpack_require__(76);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip__ = __webpack_require__(195);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_grid__ = __webpack_require__(217);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_grid___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_grid__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_bar__ = __webpack_require__(255);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_bar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_bar__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_legend__ = __webpack_require__(209);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_legend___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_legend__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_echarts_lib_chart_pie__ = __webpack_require__(231);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_echarts_lib_chart_pie___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_echarts_lib_chart_pie__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_echarts_lib_chart_line__ = __webpack_require__(236);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_echarts_lib_chart_line___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_echarts_lib_chart_line__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**\r\n * Created by yongyuehuang on 2017/8/5.\r\n *///必须\nvar BarReact=function(_React$Component){_inherits(BarReact,_React$Component);function BarReact(props){_classCallCheck(this,BarReact);var _this=_possibleConstructorReturn(this,(BarReact.__proto__||Object.getPrototypeOf(BarReact)).call(this,props));_this.initPie=_this.initPie.bind(_this);return _this;}_createClass(BarReact,[{key:'initPie',value:function initPie(){var _props$option=this.props.option,option=_props$option===undefined?{}:_props$option;//外部传入的data数据\nvar myChart=__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default.a.init(this.ID);//初始化echarts\n//设置options\nmyChart.setOption(option);window.onresize=function(){//myChart.showLoading();\nmyChart.resize();};}},{key:'componentDidMount',value:function componentDidMount(){this.initPie();}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie();}},{key:'render',value:function render(){var _this2=this;var _props=this.props,_props$width=_props.width,width=_props$width===undefined?\"100%\":_props$width,_props$height=_props.height,height=_props$height===undefined?\"100%\":_props$height;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{ref:function ref(ID){return _this2.ID=ID;},style:{width:width,height:height}});}}]);return BarReact;}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);/* harmony default export */ __webpack_exports__[\"default\"] = (BarReact);\n\n/***/ }),\n/* 176 */,\n/* 177 */,\n/* 178 */,\n/* 179 */,\n/* 180 */,\n/* 181 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Model = __webpack_require__(12);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n// allAxesInfo should be updated when setOption performed.\n\nfunction collect(ecModel, api) {\n  var result = {\n    /**\n     * key: makeKey(axis.model)\n     * value: {\n     *      axis,\n     *      coordSys,\n     *      axisPointerModel,\n     *      triggerTooltip,\n     *      involveSeries,\n     *      snap,\n     *      seriesModels,\n     *      seriesDataCount\n     * }\n     */\n    axesInfo: {},\n    seriesInvolved: false,\n\n    /**\n     * key: makeKey(coordSys.model)\n     * value: Object: key makeKey(axis.model), value: axisInfo\n     */\n    coordSysAxesInfo: {},\n    coordSysMap: {}\n  };\n  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.\n\n  result.seriesInvolved && collectSeriesInfo(result, ecModel);\n  return result;\n}\n\nfunction collectAxesInfo(result, ecModel, api) {\n  var globalTooltipModel = ecModel.getComponent('tooltip');\n  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.\n\n  var linksOption = globalAxisPointerModel.get('link', true) || [];\n  var linkGroups = []; // Collect axes info.\n\n  each(api.getCoordinateSystems(), function (coordSys) {\n    // Some coordinate system do not support axes, like geo.\n    if (!coordSys.axisPointerEnabled) {\n      return;\n    }\n\n    var coordSysKey = makeKey(coordSys.model);\n    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer\n    // for user. So we enable seting tooltip on coordSys model.\n\n    var coordSysModel = coordSys.model;\n    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.\n    // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n\n    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not\n    // show but axisPointer will show as normal.\n    && baseTooltipModel.get('show')) {\n      // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n      // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n\n      if (triggerAxis || cross) {\n        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));\n      }\n\n      if (cross) {\n        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n      }\n    } // fromTooltip: true | false | 'cross'\n    // triggerTooltip: true | false | null\n\n\n    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n      var axisPointerShow = axisPointerModel.get('show');\n\n      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {\n        return;\n      }\n\n      if (triggerTooltip == null) {\n        triggerTooltip = axisPointerModel.get('triggerTooltip');\n      }\n\n      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;\n      var snap = axisPointerModel.get('snap');\n      var key = makeKey(axis.model);\n      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n\n      var axisInfo = result.axesInfo[key] = {\n        key: key,\n        axis: axis,\n        coordSys: coordSys,\n        axisPointerModel: axisPointerModel,\n        triggerTooltip: triggerTooltip,\n        involveSeries: involveSeries,\n        snap: snap,\n        useHandle: isHandleTrigger(axisPointerModel),\n        seriesModels: []\n      };\n      axesInfoInCoordSys[key] = axisInfo;\n      result.seriesInvolved |= involveSeries;\n      var groupIndex = getLinkGroupIndex(linksOption, axis);\n\n      if (groupIndex != null) {\n        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {\n          axesInfo: {}\n        });\n        linkGroup.axesInfo[key] = axisInfo;\n        linkGroup.mapper = linksOption[groupIndex].mapper;\n        axisInfo.linkGroup = linkGroup;\n      }\n    }\n  });\n}\n\nfunction makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {\n  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n  var volatileOption = {};\n  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {\n    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n  }); // category axis do not auto snap, otherwise some tick that do not\n  // has value can not be hovered. value/time/log axis default snap if\n  // triggered from tooltip and trigger tooltip.\n\n  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.\n  // Only these properties can be overrided from tooltip to axisPointer.\n\n  if (tooltipAxisPointerModel.get('type') === 'cross') {\n    volatileOption.type = 'line';\n  }\n\n  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.\n\n  labelOption.show == null && (labelOption.show = false);\n\n  if (fromTooltip === 'cross') {\n    // When 'cross', both axes show labels.\n    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get('label.show');\n    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style\n    // (cross style is dashed by default)\n\n    if (!triggerTooltip) {\n      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);\n    }\n  }\n\n  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));\n}\n\nfunction collectSeriesInfo(result, ecModel) {\n  // Prepare data for axis trigger\n  ecModel.eachSeries(function (seriesModel) {\n    // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n    var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n\n    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {\n      return;\n    }\n\n    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n      var axis = axisInfo.axis;\n\n      if (coordSys.getAxis(axis.dim) === axis) {\n        axisInfo.seriesModels.push(seriesModel);\n        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n        axisInfo.seriesDataCount += seriesModel.getData().count();\n      }\n    });\n  }, this);\n}\n/**\n * For example:\n * {\n *     axisPointer: {\n *         links: [{\n *             xAxisIndex: [2, 4],\n *             yAxisIndex: 'all'\n *         }, {\n *             xAxisId: ['a5', 'a7'],\n *             xAxisName: 'xxx'\n *         }]\n *     }\n * }\n */\n\n\nfunction getLinkGroupIndex(linksOption, axis) {\n  var axisModel = axis.model;\n  var dim = axis.dim;\n\n  for (var i = 0; i < linksOption.length; i++) {\n    var linkOption = linksOption[i] || {};\n\n    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {\n      return i;\n    }\n  }\n}\n\nfunction checkPropInLink(linkPropValue, axisPropValue) {\n  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;\n}\n\nfunction fixValue(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n\n  if (!axisInfo) {\n    return;\n  }\n\n  var axisPointerModel = axisInfo.axisPointerModel;\n  var scale = axisInfo.axis.scale;\n  var option = axisPointerModel.option;\n  var status = axisPointerModel.get('status');\n  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.\n\n  if (value != null) {\n    value = scale.parse(value);\n  }\n\n  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value\n  // and status should be initialized.\n\n  if (status == null) {\n    option.status = useHandle ? 'show' : 'hide';\n  }\n\n  var extent = scale.getExtent().slice();\n  extent[0] > extent[1] && extent.reverse();\n\n  if ( // Pick a value on axis when initializing.\n  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n  // where we should re-pick a value to keep `handle` displaying normally.\n  || value > extent[1]) {\n    // Make handle displayed on the end of the axis when init, which looks better.\n    value = extent[1];\n  }\n\n  if (value < extent[0]) {\n    value = extent[0];\n  }\n\n  option.value = value;\n\n  if (useHandle) {\n    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n  }\n}\n\nfunction getAxisInfo(axisModel) {\n  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n}\n\nfunction getAxisPointerModel(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n  return axisInfo && axisInfo.axisPointerModel;\n}\n\nfunction isHandleTrigger(axisPointerModel) {\n  return !!axisPointerModel.get('handle.show');\n}\n/**\n * @param {module:echarts/model/Model} model\n * @return {string} unique key\n */\n\n\nfunction makeKey(model) {\n  return model.type + '||' + model.id;\n}\n\nexports.collect = collect;\nexports.fixValue = fixValue;\nexports.getAxisInfo = getAxisInfo;\nexports.getAxisPointerModel = getAxisPointerModel;\nexports.makeKey = makeKey;\n\n/***/ }),\n/* 182 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(0);\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = __webpack_require__(9);\n\nvar graphic = __webpack_require__(11);\n\nvar Model = __webpack_require__(12);\n\nvar _number = __webpack_require__(5);\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = __webpack_require__(77);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = __webpack_require__(18);\n\nvar _vector = __webpack_require__(2);\n\nvar v2ApplyTransform = _vector.applyTransform;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n    var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;\n\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];\n          symbol.attr({\n            rotation: point.rotate,\n            position: pos,\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticksCoords[i].tickValue,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {\n      itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickValue);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickValue,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: formattedLabel,\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always use formatted label as\n      // input. But in interval scale the formatted label is like '223,445', which\n      // maked user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = rawLabel;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;\n\n/***/ }),\n/* 183 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(76);\n\nvar axisPointerModelHelper = __webpack_require__(181);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Base class of AxisView.\n */\nvar AxisView = echarts.extendComponentView({\n  type: 'axis',\n\n  /**\n   * @private\n   */\n  _axisPointer: null,\n\n  /**\n   * @protected\n   * @type {string}\n   */\n  axisPointerClass: null,\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    // FIXME\n    // This process should proformed after coordinate systems updated\n    // (axis scale updated), and should be performed each time update.\n    // So put it here temporarily, although it is not appropriate to\n    // put a model-writing procedure in `view`.\n    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n    AxisView.superApply(this, 'render', arguments);\n    updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n  },\n\n  /**\n   * Action handler.\n   * @public\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/model/Global} ecModel\n   * @param {module:echarts/ExtensionAPI} api\n   * @param {Object} payload\n   */\n  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n    updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    var axisPointer = this._axisPointer;\n    axisPointer && axisPointer.remove(api);\n    AxisView.superApply(this, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    disposeAxisPointer(this, api);\n    AxisView.superApply(this, 'dispose', arguments);\n  }\n});\n\nfunction updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n\n  if (!Clazz) {\n    return;\n  }\n\n  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);\n}\n\nfunction disposeAxisPointer(axisView, ecModel, api) {\n  var axisPointer = axisView._axisPointer;\n  axisPointer && axisPointer.dispose(ecModel, api);\n  axisView._axisPointer = null;\n}\n\nvar axisPointerClazz = [];\n\nAxisView.registerAxisPointerClass = function (type, clazz) {\n  axisPointerClazz[type] = clazz;\n};\n\nAxisView.getAxisPointerClass = function (type) {\n  return type && axisPointerClazz[type];\n};\n\nvar _default = AxisView;\nmodule.exports = _default;\n\n/***/ }),\n/* 184 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar axisPointerModelHelper = __webpack_require__(181);\n\nvar axisTrigger = __webpack_require__(201);\n\n__webpack_require__(202);\n\n__webpack_require__(203);\n\n__webpack_require__(189);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// CartesianAxisPointer is not supposed to be required here. But consider\n// echarts.simple.js and online build tooltip, which only require gridSimple,\n// CartesianAxisPointer should be able to required somewhere.\necharts.registerPreprocessor(function (option) {\n  // Always has a global axisPointerModel for default setting.\n  if (option) {\n    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});\n    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link\n    // is not set, remain null/undefined, otherwise it will\n    // override existent link setting.\n\n    if (link && !zrUtil.isArray(link)) {\n      option.axisPointer.link = [link];\n    }\n  }\n}); // This process should proformed after coordinate systems created\n// and series data processed. So put it on statistic processing stage.\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n  // allAxesInfo should be updated when setOption performed.\n  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);\n}); // Broadcast to all views.\n\necharts.registerAction({\n  type: 'updateAxisPointer',\n  event: 'updateAxisPointer',\n  update: ':updateAxisPointer'\n}, axisTrigger);\n\n/***/ }),\n/* 185 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(11);\n\nvar textContain = __webpack_require__(14);\n\nvar formatUtil = __webpack_require__(9);\n\nvar matrix = __webpack_require__(18);\n\nvar axisHelper = __webpack_require__(30);\n\nvar AxisBuilder = __webpack_require__(182);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\n\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get('label.precision'),\n    formatter: axisPointerModel.get('label.formatter')\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get('axisLine.lineStyle.color');\n  }\n\n  elOption.label = {\n    shape: {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      r: labelModel.get('borderRadius')\n    },\n    position: position.slice(),\n    // TODO: rich\n    style: {\n      text: text,\n      textFont: font,\n      textFill: labelModel.getTextColor(),\n      textPosition: 'inside',\n      fill: bgColor,\n      stroke: labelModel.get('borderColor') || 'transparent',\n      lineWidth: labelModel.get('borderWidth') || 0,\n      shadowBlur: labelModel.get('shadowBlur'),\n      shadowColor: labelModel.get('shadowColor'),\n      shadowOffsetX: labelModel.get('shadowOffsetX'),\n      shadowOffsetY: labelModel.get('shadowOffsetY')\n    },\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\n\n\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  value = axis.scale.parse(value);\n  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which\n  // helps to debounce when when moving label.\n  value, {\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params = {\n      value: axisHelper.getAxisRawValue(axis, value),\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params);\n    }\n  }\n\n  return text;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\n\n\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\n\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\n\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}\n\nexports.buildElStyle = buildElStyle;\nexports.buildLabelElOption = buildLabelElOption;\nexports.getValueLabel = getValueLabel;\nexports.getTransformedPosition = getTransformedPosition;\nexports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;\nexports.makeLineShape = makeLineShape;\nexports.makeRectShape = makeRectShape;\nexports.makeSectorShape = makeSectorShape;\n\n/***/ }),\n/* 186 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar modelUtil = __webpack_require__(1);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} {point: [x, y], el: ...} point Will not be null.\n */\nfunction _default(finder, ecModel) {\n  var point = [];\n  var seriesIndex = finder.seriesIndex;\n  var seriesModel;\n\n  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {\n    return {\n      point: []\n    };\n  }\n\n  var data = seriesModel.getData();\n  var dataIndex = modelUtil.queryDataIndex(data, finder);\n\n  if (dataIndex == null || dataIndex < 0 || zrUtil.isArray(dataIndex)) {\n    return {\n      point: []\n    };\n  }\n\n  var el = data.getItemGraphicEl(dataIndex);\n  var coordSys = seriesModel.coordinateSystem;\n\n  if (seriesModel.getTooltipPosition) {\n    point = seriesModel.getTooltipPosition(dataIndex) || [];\n  } else if (coordSys && coordSys.dataToPoint) {\n    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {\n      return data.mapDimension(dim);\n    }), dataIndex, true)) || [];\n  } else if (el) {\n    // Use graphic bounding rect\n    var rect = el.getBoundingRect().clone();\n    rect.applyTransform(el.transform);\n    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n\n  return {\n    point: point,\n    el: el\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 187 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar env = __webpack_require__(7);\n\nvar _model = __webpack_require__(1);\n\nvar makeInner = _model.makeInner;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\nvar each = zrUtil.each;\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n * @param {Function} handler\n *      param: {string} currTrigger\n *      param: {Array.<number>} point\n */\n\nfunction register(key, api, handler) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  inner(zr).records || (inner(zr).records = {});\n  initGlobalListeners(zr, api);\n  var record = inner(zr).records[key] || (inner(zr).records[key] = {});\n  record.handler = handler;\n}\n\nfunction initGlobalListeners(zr, api) {\n  if (inner(zr).initialized) {\n    return;\n  }\n\n  inner(zr).initialized = true;\n  useHandler('click', zrUtil.curry(doEnter, 'click'));\n  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);\n\n  useHandler('globalout', onLeave);\n\n  function useHandler(eventType, cb) {\n    zr.on(eventType, function (e) {\n      var dis = makeDispatchAction(api);\n      each(inner(zr).records, function (record) {\n        record && cb(record, e, dis.dispatchAction);\n      });\n      dispatchTooltipFinally(dis.pendings, api);\n    });\n  }\n}\n\nfunction dispatchTooltipFinally(pendings, api) {\n  var showLen = pendings.showTip.length;\n  var hideLen = pendings.hideTip.length;\n  var actuallyPayload;\n\n  if (showLen) {\n    actuallyPayload = pendings.showTip[showLen - 1];\n  } else if (hideLen) {\n    actuallyPayload = pendings.hideTip[hideLen - 1];\n  }\n\n  if (actuallyPayload) {\n    actuallyPayload.dispatchAction = null;\n    api.dispatchAction(actuallyPayload);\n  }\n}\n\nfunction onLeave(record, e, dispatchAction) {\n  record.handler('leave', null, dispatchAction);\n}\n\nfunction doEnter(currTrigger, record, e, dispatchAction) {\n  record.handler(currTrigger, e, dispatchAction);\n}\n\nfunction makeDispatchAction(api) {\n  var pendings = {\n    showTip: [],\n    hideTip: []\n  }; // FIXME\n  // better approach?\n  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n  // So we have to add \"final stage\" to merge those dispatched actions.\n\n  var dispatchAction = function (payload) {\n    var pendingList = pendings[payload.type];\n\n    if (pendingList) {\n      pendingList.push(payload);\n    } else {\n      payload.dispatchAction = dispatchAction;\n      api.dispatchAction(payload);\n    }\n  };\n\n  return {\n    dispatchAction: dispatchAction,\n    pendings: pendings\n  };\n}\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction unregister(key, api) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  var record = (inner(zr).records || {})[key];\n\n  if (record) {\n    inner(zr).records[key] = null;\n  }\n}\n\nexports.register = register;\nexports.unregister = unregister;\n\n/***/ }),\n/* 188 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(11);\n\n__webpack_require__(196);\n\n__webpack_require__(222);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n/***/ }),\n/* 189 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(11);\n\nvar BaseAxisPointer = __webpack_require__(194);\n\nvar viewHelper = __webpack_require__(185);\n\nvar cartesianAxisHelper = __webpack_require__(190);\n\nvar AxisView = __webpack_require__(183);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar CartesianAxisPointer = BaseAxisPointer.extend({\n  /**\n   * @override\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisPointerType = axisPointerModel.get('type');\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = viewHelper.buildElStyle(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n\n    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n  },\n\n  /**\n   * @override\n   */\n  getHandleTransform: function (value, axisModel, axisPointerModel) {\n    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n      labelInside: false\n    });\n    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n    return {\n      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n    };\n  },\n\n  /**\n   * @override\n   */\n  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisExtent = axis.getGlobalExtent(true);\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var dimIndex = axis.dim === 'x' ? 0 : 1;\n    var currPosition = transform.position;\n    currPosition[dimIndex] += delta[dimIndex];\n    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n    var cursorPoint = [cursorOtherValue, cursorOtherValue];\n    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.\n\n    var tooltipOptions = [{\n      verticalAlign: 'middle'\n    }, {\n      align: 'center'\n    }];\n    return {\n      position: currPosition,\n      rotation: transform.rotation,\n      cursorPoint: cursorPoint,\n      tooltipOption: tooltipOptions[dimIndex]\n    };\n  }\n});\n\nfunction getCartesian(grid, axis) {\n  var opt = {};\n  opt[axis.dim + 'AxisIndex'] = axis.index;\n  return grid.getCartesian(opt);\n}\n\nvar pointerShapeBuilder = {\n  line: function (axis, pixelValue, otherExtent, elStyle) {\n    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));\n    graphic.subPixelOptimizeLine({\n      shape: targetShape,\n      style: elStyle\n    });\n    return {\n      type: 'Line',\n      shape: targetShape\n    };\n  },\n  shadow: function (axis, pixelValue, otherExtent, elStyle) {\n    var bandWidth = Math.max(1, axis.getBandWidth());\n    var span = otherExtent[1] - otherExtent[0];\n    return {\n      type: 'Rect',\n      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))\n    };\n  }\n};\n\nfunction getAxisDimIndex(axis) {\n  return axis.dim === 'x' ? 0 : 1;\n}\n\nAxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\nvar _default = CartesianAxisPointer;\nmodule.exports = _default;\n\n/***/ }),\n/* 190 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Can only be called after coordinate system creation stage.\n * (Can be called before coordinate system update stage).\n *\n * @param {Object} opt {labelInside}\n * @return {Object} {\n *  position, rotation, labelDirection, labelOffset,\n *  tickDirection, labelRotate, z2\n * }\n */\nfunction layout(gridModel, axisModel, opt) {\n  opt = opt || {};\n  var grid = gridModel.coordinateSystem;\n  var axis = axisModel.axis;\n  var layout = {};\n  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];\n  var rawAxisPosition = axis.position;\n  var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;\n  var axisDim = axis.dim;\n  var rect = grid.getRect();\n  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n  var idx = {\n    left: 0,\n    right: 1,\n    top: 0,\n    bottom: 1,\n    onZero: 2\n  };\n  var axisOffset = axisModel.get('offset') || 0;\n  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n  if (otherAxisOnZeroOf) {\n    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));\n    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n  } // Axis position\n\n\n  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation\n\n  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim\n\n  var dirMap = {\n    top: -1,\n    bottom: 1,\n    left: -1,\n    right: 1\n  };\n  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n  layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n  if (axisModel.get('axisTick.inside')) {\n    layout.tickDirection = -layout.tickDirection;\n  }\n\n  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n    layout.labelDirection = -layout.labelDirection;\n  } // Special label rotation\n\n\n  var labelRotate = axisModel.get('axisLabel.rotate');\n  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea\n\n  layout.z2 = 1;\n  return layout;\n}\n\nexports.layout = layout;\n\n/***/ }),\n/* 191 */\n/***/ (function(module, exports) {\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    // For legend.\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      var keepAspect = seriesModel.get('symbolKeepAspect');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize,\n        symbolKeepAspect: keepAspect\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n          var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n\n          if (itemSymbolKeepAspect != null) {\n            data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 192 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createDimensions = __webpack_require__(45);\n\nvar List = __webpack_require__(41);\n\nvar _util = __webpack_require__(0);\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 193 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar ComponentModel = __webpack_require__(13);\n\nvar axisModelCreator = __webpack_require__(197);\n\nvar axisModelCommonMixin = __webpack_require__(82);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n/***/ }),\n/* 194 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar clazzUtil = __webpack_require__(8);\n\nvar graphic = __webpack_require__(11);\n\nvar axisPointerModelHelper = __webpack_require__(181);\n\nvar eventTool = __webpack_require__(31);\n\nvar throttleUtil = __webpack_require__(43);\n\nvar _model = __webpack_require__(1);\n\nvar makeInner = _model.makeInner;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\nvar clone = zrUtil.clone;\nvar bind = zrUtil.bind;\n/**\n * Base axis pointer class in 2D.\n * Implemenents {module:echarts/component/axis/IAxisPointer}.\n */\n\nfunction BaseAxisPointer() {}\n\nBaseAxisPointer.prototype = {\n  /**\n   * @private\n   */\n  _group: null,\n\n  /**\n   * @private\n   */\n  _lastGraphicKey: null,\n\n  /**\n   * @private\n   */\n  _handle: null,\n\n  /**\n   * @private\n   */\n  _dragging: false,\n\n  /**\n   * @private\n   */\n  _lastValue: null,\n\n  /**\n   * @private\n   */\n  _lastStatus: null,\n\n  /**\n   * @private\n   */\n  _payloadInfo: null,\n\n  /**\n   * In px, arbitrary value. Do not set too small,\n   * no animation is ok for most cases.\n   * @protected\n   */\n  animationThreshold: 15,\n\n  /**\n   * @implement\n   */\n  render: function (axisModel, axisPointerModel, api, forceRender) {\n    var value = axisPointerModel.get('value');\n    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not\n    // be replaced when user calling setOption in not merge mode.\n\n    this._axisModel = axisModel;\n    this._axisPointerModel = axisPointerModel;\n    this._api = api; // Optimize: `render` will be called repeatly during mouse move.\n    // So it is power consuming if performing `render` each time,\n    // especially on mobile device.\n\n    if (!forceRender && this._lastValue === value && this._lastStatus === status) {\n      return;\n    }\n\n    this._lastValue = value;\n    this._lastStatus = status;\n    var group = this._group;\n    var handle = this._handle;\n\n    if (!status || status === 'hide') {\n      // Do not clear here, for animation better.\n      group && group.hide();\n      handle && handle.hide();\n      return;\n    }\n\n    group && group.show();\n    handle && handle.show(); // Otherwise status is 'show'\n\n    var elOption = {};\n    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.\n\n    var graphicKey = elOption.graphicKey;\n\n    if (graphicKey !== this._lastGraphicKey) {\n      this.clear(api);\n    }\n\n    this._lastGraphicKey = graphicKey;\n    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);\n\n    if (!group) {\n      group = this._group = new graphic.Group();\n      this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n      this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n      api.getZr().add(group);\n    } else {\n      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n    }\n\n    updateMandatoryProps(group, axisPointerModel, true);\n\n    this._renderHandle(value);\n  },\n\n  /**\n   * @implement\n   */\n  remove: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @implement\n   */\n  dispose: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @protected\n   */\n  determineAnimation: function (axisModel, axisPointerModel) {\n    var animation = axisPointerModel.get('animation');\n    var axis = axisModel.axis;\n    var isCategoryAxis = axis.type === 'category';\n    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.\n\n    if (!useSnap && !isCategoryAxis) {\n      return false;\n    }\n\n    if (animation === 'auto' || animation == null) {\n      var animationThreshold = this.animationThreshold;\n\n      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n        return true;\n      } // It is important to auto animation when snap used. Consider if there is\n      // a dataZoom, animation will be disabled when too many points exist, while\n      // it will be enabled for better visual effect when little points exist.\n\n\n      if (useSnap) {\n        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n        var axisExtent = axis.getExtent(); // Approximate band width\n\n        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n      }\n\n      return false;\n    }\n\n    return animation === true;\n  },\n\n  /**\n   * add {pointer, label, graphicKey} to elOption\n   * @protected\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.\n  },\n\n  /**\n   * @protected\n   */\n  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n    var pointerOption = elOption.pointer;\n\n    if (pointerOption) {\n      var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));\n      group.add(pointerEl);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n    if (elOption.label) {\n      var labelEl = inner(group).labelEl = new graphic.Rect(clone(elOption.label));\n      group.add(labelEl);\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updatePointerEl: function (group, elOption, updateProps) {\n    var pointerEl = inner(group).pointerEl;\n\n    if (pointerEl) {\n      pointerEl.setStyle(elOption.pointer.style);\n      updateProps(pointerEl, {\n        shape: elOption.pointer.shape\n      });\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n    var labelEl = inner(group).labelEl;\n\n    if (labelEl) {\n      labelEl.setStyle(elOption.label.style);\n      updateProps(labelEl, {\n        // Consider text length change in vertical axis, animation should\n        // be used on shape, otherwise the effect will be weird.\n        shape: elOption.label.shape,\n        position: elOption.label.position\n      });\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _renderHandle: function (value) {\n    if (this._dragging || !this.updateHandleTransform) {\n      return;\n    }\n\n    var axisPointerModel = this._axisPointerModel;\n\n    var zr = this._api.getZr();\n\n    var handle = this._handle;\n    var handleModel = axisPointerModel.getModel('handle');\n    var status = axisPointerModel.get('status');\n\n    if (!handleModel.get('show') || !status || status === 'hide') {\n      handle && zr.remove(handle);\n      this._handle = null;\n      return;\n    }\n\n    var isInit;\n\n    if (!this._handle) {\n      isInit = true;\n      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {\n        cursor: 'move',\n        draggable: true,\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n        drift: bind(this._onHandleDragMove, this),\n        ondragend: bind(this._onHandleDragEnd, this)\n      });\n      zr.add(handle);\n    }\n\n    updateMandatoryProps(handle, axisPointerModel, false); // update style\n\n    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position\n\n    var handleSize = handleModel.get('size');\n\n    if (!zrUtil.isArray(handleSize)) {\n      handleSize = [handleSize, handleSize];\n    }\n\n    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');\n\n    this._moveHandleToValue(value, isInit);\n  },\n\n  /**\n   * @private\n   */\n  _moveHandleToValue: function (value, isInit) {\n    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragMove: function (dx, dy) {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    this._dragging = true; // Persistent for throttle.\n\n    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);\n    this._payloadInfo = trans;\n    handle.stopAnimation();\n    handle.attr(getHandleTransProps(trans));\n    inner(handle).lastProp = null;\n\n    this._doDispatchAxisPointer();\n  },\n\n  /**\n   * Throttled method.\n   * @private\n   */\n  _doDispatchAxisPointer: function () {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var payloadInfo = this._payloadInfo;\n    var axisModel = this._axisModel;\n\n    this._api.dispatchAction({\n      type: 'updateAxisPointer',\n      x: payloadInfo.cursorPoint[0],\n      y: payloadInfo.cursorPoint[1],\n      tooltipOption: payloadInfo.tooltipOption,\n      axesInfo: [{\n        axisDim: axisModel.axis.dim,\n        axisIndex: axisModel.componentIndex\n      }]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragEnd: function (moveAnimation) {\n    this._dragging = false;\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with\n    // axisPointer. So move handle to align the exact value position when\n    // drag ended.\n\n\n    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle\n    // button, and will be hidden after finger left handle button.\n\n\n    this._api.dispatchAction({\n      type: 'hideTip'\n    });\n  },\n\n  /**\n   * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {number} value\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0}\n   */\n  getHandleTransform: null,\n\n  /**\n   * * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {Object} transform {position, rotation}\n   * @param {Array.<number>} delta [dx, dy]\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n   */\n  updateHandleTransform: null,\n\n  /**\n   * @private\n   */\n  clear: function (api) {\n    this._lastValue = null;\n    this._lastStatus = null;\n    var zr = api.getZr();\n    var group = this._group;\n    var handle = this._handle;\n\n    if (zr && group) {\n      this._lastGraphicKey = null;\n      group && zr.remove(group);\n      handle && zr.remove(handle);\n      this._group = null;\n      this._handle = null;\n      this._payloadInfo = null;\n    }\n  },\n\n  /**\n   * @protected\n   */\n  doClear: function () {// Implemented by sub-class if necessary.\n  },\n\n  /**\n   * @protected\n   * @param {Array.<number>} xy\n   * @param {Array.<number>} wh\n   * @param {number} [xDimIndex=0] or 1\n   */\n  buildLabel: function (xy, wh, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n      x: xy[xDimIndex],\n      y: xy[1 - xDimIndex],\n      width: wh[xDimIndex],\n      height: wh[1 - xDimIndex]\n    };\n  }\n};\nBaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\nfunction updateProps(animationModel, moveAnimation, el, props) {\n  // Animation optimize.\n  if (!propsEqual(inner(el).lastProp, props)) {\n    inner(el).lastProp = props;\n    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));\n  }\n}\n\nfunction propsEqual(lastProps, newProps) {\n  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n    var equals = true;\n    zrUtil.each(newProps, function (item, key) {\n      equals = equals && propsEqual(lastProps[key], item);\n    });\n    return !!equals;\n  } else {\n    return lastProps === newProps;\n  }\n}\n\nfunction updateLabelShowHide(labelEl, axisPointerModel) {\n  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n}\n\nfunction getHandleTransProps(trans) {\n  return {\n    position: trans.position.slice(),\n    rotation: trans.rotation || 0\n  };\n}\n\nfunction updateMandatoryProps(group, axisPointerModel, silent) {\n  var z = axisPointerModel.get('z');\n  var zlevel = axisPointerModel.get('zlevel');\n  group && group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n      el.silent = silent;\n    }\n  });\n}\n\nclazzUtil.enableClassExtend(BaseAxisPointer);\nvar _default = BaseAxisPointer;\nmodule.exports = _default;\n\n/***/ }),\n/* 195 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n__webpack_require__(184);\n\n__webpack_require__(204);\n\n__webpack_require__(205);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME Better way to pack data in graphic element\n\n/**\n * @action\n * @property {string} type\n * @property {number} seriesIndex\n * @property {number} dataIndex\n * @property {number} [x]\n * @property {number} [y]\n */\necharts.registerAction({\n  type: 'showTip',\n  event: 'showTip',\n  update: 'tooltip:manuallyShowTip'\n}, // noop\nfunction () {});\necharts.registerAction({\n  type: 'hideTip',\n  event: 'hideTip',\n  update: 'tooltip:manuallyHideTip'\n}, // noop\nfunction () {});\n\n/***/ }),\n/* 196 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = __webpack_require__(0);\n\nvar isObject = _util.isObject;\nvar each = _util.each;\nvar map = _util.map;\nvar indexOf = _util.indexOf;\nvar retrieve = _util.retrieve;\n\nvar _layout = __webpack_require__(29);\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar _axisHelper = __webpack_require__(30);\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar ifAxisCrossZero = _axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\nvar estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;\n\nvar Cartesian2D = __webpack_require__(218);\n\nvar Axis2D = __webpack_require__(220);\n\nvar CoordinateSystem = __webpack_require__(42);\n\nvar _dataStackHelper = __webpack_require__(32);\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\n__webpack_require__(221);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxis ? [otherAxis] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxis;\n  var axisModel = axis.model;\n  var onZero = axisModel.get('axisLine.onZero');\n  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxis = otherAxes[onZeroAxisIndex];\n    }\n\n    return;\n  } // Find the first available other axis.\n\n\n  for (var idx in otherAxes) {\n    if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])) {\n      otherAxis = otherAxes[idx];\n      break;\n    }\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = estimateLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(data.mapDimension(axis.dim, true), function (dim) {\n      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension\n      // is [0.1, 0.5], the extent of the `stackResultDimension`\n      // is [7, 9], the final extent should not include [0.1, 0.5].\n      data, getStackedDimension(data, dim));\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n/***/ }),\n/* 197 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar axisDefault = __webpack_require__(198);\n\nvar ComponentModel = __webpack_require__(13);\n\nvar _layout = __webpack_require__(29);\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n\nvar OrdinalMeta = __webpack_require__(85);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      /**\n       * @readOnly\n       */\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n\n      /**\n       * @override\n       */\n      optionUpdated: function () {\n        var thisOption = this.option;\n\n        if (thisOption.type === 'category') {\n          this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);\n        }\n      },\n\n      /**\n       * Should not be called before all of 'getInitailData' finished.\n       * Because categories are collected during initializing data.\n       */\n      getCategories: function (rawData) {\n        var option = this.option; // FIXME\n        // warning if called before all of 'getInitailData' finished.\n\n        if (option.type === 'category') {\n          if (rawData) {\n            return option.data;\n          }\n\n          return this.__ordinalMeta.categories;\n        }\n      },\n      getOrdinalMeta: function () {\n        return this.__ordinalMeta;\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 198 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // By degree. By defualt auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // The arrow at both ends the the axis.\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  // Only usefull in the case like: category is\n  // ['2012-01-01', '2012-01-02', ...], where the input\n  // data has been ensured not duplicate and is large data.\n  // null means \"auto\":\n  // if axis.data provided, do not deduplication,\n  // else do deduplication.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For value axis, [GAP, GAP], where\n  // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)\n  boundaryGap: [0, 0],\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  // Min value of the axis. can be:\n  // + a number\n  // + 'dataMin': use the min value in data.\n  // + null/undefined: auto decide min value (consider pretty look and boundaryGap).\n  // min: null,\n  // Max value of the axis. can be:\n  // + a number\n  // + 'dataMax': use the max value in data.\n  // + null/undefined: auto decide max value (consider pretty look and boundaryGap).\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // Optional value can be:\n  // + `false`: always include value 0.\n  // + `true`: the extent do not consider value 0.\n  // scale: false,\n  // AxisTick and axisLabel and splitLine are caculated based on splitNumber.\n  splitNumber: 5 // Interval specifies the span of the ticks is mandatorily.\n  // interval: null\n  // Specify min interval when auto calculate tick interval.\n  // minInterval: null\n  // Specify max interval when auto calculate tick interval.\n  // maxInterval: null\n\n}, defaultOption);\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n/***/ }),\n/* 199 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar _symbol = __webpack_require__(77);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(11);\n\nvar _number = __webpack_require__(5);\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = __webpack_require__(214);\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/Symbol\n */\n\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n/**\n * @public\n * @static\n * @param {module:echarts/data/List} data\n * @param {number} dataIndex\n * @return {Array.<number>} [width, height]\n */\n\nvar getSymbolSize = SymbolClz.getSymbolSize = function (data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n};\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');\n\n    this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var liftZ = data.getItemVisual(idx, 'liftZ');\n  var z2Origin = symbolPath.__z2Origin;\n\n  if (liftZ != null) {\n    if (z2Origin == null) {\n      symbolPath.__z2Origin = symbolPath.z2;\n      symbolPath.z2 += liftZ;\n    }\n  } else if (z2Origin != null) {\n    symbolPath.z2 = z2Origin;\n    symbolPath.__z2Origin = null;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n/***/ }),\n/* 200 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(0);\n\nvar map = _util.map;\n\nvar createRenderPlanner = __webpack_require__(44);\n\nvar _dataStackHelper = __webpack_require__(32);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n      if (isDimensionStacked(data, dims[0]\n      /*, dims[1]*/\n      )) {\n        dims[0] = stackResultDim;\n      }\n\n      if (isDimensionStacked(data, dims[1]\n      /*, dims[0]*/\n      )) {\n        dims[1] = stackResultDim;\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i);\n            var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 201 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar _model = __webpack_require__(1);\n\nvar makeInner = _model.makeInner;\n\nvar modelHelper = __webpack_require__(181);\n\nvar findPointFromSeries = __webpack_require__(186);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar curry = zrUtil.curry;\nvar inner = makeInner();\n/**\n * Basic logic: check all axis, if they do not demand show/highlight,\n * then hide/downplay them.\n *\n * @param {Object} coordSysAxesInfo\n * @param {Object} payload\n * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n * @param {Object} [payload.dataIndex] finder, restrict target axes.\n * @param {Object} [payload.axesInfo] finder, restrict target axes.\n *        [{\n *          axisDim: 'x'|'y'|'angle'|...,\n *          axisIndex: ...,\n *          value: ...\n *        }, ...]\n * @param {Function} [payload.dispatchAction]\n * @param {Object} [payload.tooltipOption]\n * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n *        which can be specified in dispatchAction\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n * @return {Object} content of event obj for echarts.connect.\n */\n\nfunction _default(payload, ecModel, api) {\n  var currTrigger = payload.currTrigger;\n  var point = [payload.x, payload.y];\n  var finder = payload;\n  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending\n  // See #6121. But we are not able to reproduce it yet.\n\n  if (!coordSysAxesInfo) {\n    return;\n  }\n\n  if (illegalPoint(point)) {\n    // Used in the default behavior of `connection`: use the sample seriesIndex\n    // and dataIndex. And also used in the tooltipView trigger.\n    point = findPointFromSeries({\n      seriesIndex: finder.seriesIndex,\n      // Do not use dataIndexInside from other ec instance.\n      // FIXME: auto detect it?\n      dataIndex: finder.dataIndex\n    }, ecModel).point;\n  }\n\n  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n  // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n  // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n  // and dataIndex.\n\n  var inputAxesInfo = finder.axesInfo;\n  var axesInfo = coordSysAxesInfo.axesInfo;\n  var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n  var outputFinder = {};\n  var showValueMap = {};\n  var dataByCoordSys = {\n    list: [],\n    map: {}\n  };\n  var updaters = {\n    showPointer: curry(showPointer, showValueMap),\n    showTooltip: curry(showTooltip, dataByCoordSys)\n  }; // Process for triggered axes.\n\n  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n    // If a point given, it must be contained by the coordinate system.\n    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n      var axis = axisInfo.axis;\n      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.\n\n      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n        var val = inputAxisInfo && inputAxisInfo.value;\n\n        if (val == null && !isIllegalPoint) {\n          val = axis.pointToData(point);\n        }\n\n        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n      }\n    });\n  }); // Process for linked axes.\n\n  var linkTriggers = {};\n  each(axesInfo, function (tarAxisInfo, tarKey) {\n    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.\n\n    if (linkGroup && !showValueMap[tarKey]) {\n      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.\n\n        if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n          var val = srcValItem.value;\n          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));\n          linkTriggers[tarAxisInfo.key] = val;\n        }\n      });\n    }\n  });\n  each(linkTriggers, function (val, tarKey) {\n    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n  });\n  updateModelActually(showValueMap, axesInfo, outputFinder);\n  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n  dispatchHighDownActually(axesInfo, dispatchAction, api);\n  return outputFinder;\n}\n\nfunction processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n  var axis = axisInfo.axis;\n\n  if (axis.scale.isBlank() || !axis.containData(newValue)) {\n    return;\n  }\n\n  if (!axisInfo.involveSeries) {\n    updaters.showPointer(axisInfo, newValue);\n    return;\n  } // Heavy calculation. So put it after axis.containData checking.\n\n\n  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n  var payloadBatch = payloadInfo.payloadBatch;\n  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.\n  // By defualt use the first involved series data as a sample to connect.\n\n  if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n    zrUtil.extend(outputFinder, payloadBatch[0]);\n  } // If no linkSource input, this process is for collecting link\n  // target, where snap should not be accepted.\n\n\n  if (!dontSnap && axisInfo.snap) {\n    if (axis.containData(snapToValue) && snapToValue != null) {\n      newValue = snapToValue;\n    }\n  }\n\n  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be\n  // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n\n  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n}\n\nfunction buildPayloadsBySeries(value, axisInfo) {\n  var axis = axisInfo.axis;\n  var dim = axis.dim;\n  var snapToValue = value;\n  var payloadBatch = [];\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n  each(axisInfo.seriesModels, function (series, idx) {\n    var dataDim = series.getData().mapDimension(dim, true);\n    var seriesNestestValue;\n    var dataIndices;\n\n    if (series.getAxisTooltipData) {\n      var result = series.getAxisTooltipData(dataDim, value, axis);\n      dataIndices = result.dataIndices;\n      seriesNestestValue = result.nestestValue;\n    } else {\n      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex\n      // when data length is not same.\n      // false,\n      axis.type === 'category' ? 0.5 : null);\n\n      if (!dataIndices.length) {\n        return;\n      }\n\n      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n    }\n\n    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n      return;\n    }\n\n    var diff = value - seriesNestestValue;\n    var dist = Math.abs(diff); // Consider category case\n\n    if (dist <= minDist) {\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        snapToValue = seriesNestestValue;\n        payloadBatch.length = 0;\n      }\n\n      each(dataIndices, function (dataIndex) {\n        payloadBatch.push({\n          seriesIndex: series.seriesIndex,\n          dataIndexInside: dataIndex,\n          dataIndex: series.getData().getRawIndex(dataIndex)\n        });\n      });\n    }\n  });\n  return {\n    payloadBatch: payloadBatch,\n    snapToValue: snapToValue\n  };\n}\n\nfunction showPointer(showValueMap, axisInfo, value, payloadBatch) {\n  showValueMap[axisInfo.key] = {\n    value: value,\n    payloadBatch: payloadBatch\n  };\n}\n\nfunction showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n  var payloadBatch = payloadInfo.payloadBatch;\n  var axis = axisInfo.axis;\n  var axisModel = axis.model;\n  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,\n  // whose length will be used to judge whether dispatch action.\n\n  if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n    return;\n  }\n\n  var coordSysModel = axisInfo.coordSys.model;\n  var coordSysKey = modelHelper.makeKey(coordSysModel);\n  var coordSysItem = dataByCoordSys.map[coordSysKey];\n\n  if (!coordSysItem) {\n    coordSysItem = dataByCoordSys.map[coordSysKey] = {\n      coordSysId: coordSysModel.id,\n      coordSysIndex: coordSysModel.componentIndex,\n      coordSysType: coordSysModel.type,\n      coordSysMainType: coordSysModel.mainType,\n      dataByAxis: []\n    };\n    dataByCoordSys.list.push(coordSysItem);\n  }\n\n  coordSysItem.dataByAxis.push({\n    axisDim: axis.dim,\n    axisIndex: axisModel.componentIndex,\n    axisType: axisModel.type,\n    axisId: axisModel.id,\n    value: value,\n    // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n    // depends that all models have been updated. So it should not be performed\n    // here. Considering axisPointerModel used here is volatile, which is hard\n    // to be retrieve in TooltipView, we prepare parameters here.\n    valueLabelOpt: {\n      precision: axisPointerModel.get('label.precision'),\n      formatter: axisPointerModel.get('label.formatter')\n    },\n    seriesDataIndices: payloadBatch.slice()\n  });\n}\n\nfunction updateModelActually(showValueMap, axesInfo, outputFinder) {\n  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    var valItem = showValueMap[key];\n\n    if (valItem) {\n      !axisInfo.useHandle && (option.status = 'show');\n      option.value = valItem.value; // For label formatter param and highlight.\n\n      option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n    } // When always show (e.g., handle used), remain\n    // original value and status.\n    else {\n        // If hide, value still need to be set, consider\n        // click legend to toggle axis blank.\n        !axisInfo.useHandle && (option.status = 'hide');\n      } // If status is 'hide', should be no info in payload.\n\n\n    option.status === 'show' && outputAxesInfo.push({\n      axisDim: axisInfo.axis.dim,\n      axisIndex: axisInfo.axis.model.componentIndex,\n      value: option.value\n    });\n  });\n}\n\nfunction dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n  // Basic logic: If no showTip required, hideTip will be dispatched.\n  if (illegalPoint(point) || !dataByCoordSys.list.length) {\n    dispatchAction({\n      type: 'hideTip'\n    });\n    return;\n  } // In most case only one axis (or event one series is used). It is\n  // convinient to fetch payload.seriesIndex and payload.dataIndex\n  // dirtectly. So put the first seriesIndex and dataIndex of the first\n  // axis on the payload.\n\n\n  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n  dispatchAction({\n    type: 'showTip',\n    escapeConnect: true,\n    x: point[0],\n    y: point[1],\n    tooltipOption: payload.tooltipOption,\n    position: payload.position,\n    dataIndexInside: sampleItem.dataIndexInside,\n    dataIndex: sampleItem.dataIndex,\n    seriesIndex: sampleItem.seriesIndex,\n    dataByCoordSys: dataByCoordSys.list\n  });\n}\n\nfunction dispatchHighDownActually(axesInfo, dispatchAction, api) {\n  // FIXME\n  // highlight status modification shoule be a stage of main process?\n  // (Consider confilct (e.g., legend and axisPointer) and setOption)\n  var zr = api.getZr();\n  var highDownKey = 'axisPointerLastHighlights';\n  var lastHighlights = inner(zr)[highDownKey] || {};\n  var newHighlights = inner(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.\n  // Build hash map and remove duplicate incidentally.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n      newHighlights[key] = batchItem;\n    });\n  }); // Diff.\n\n  var toHighlight = [];\n  var toDownplay = [];\n  zrUtil.each(lastHighlights, function (batchItem, key) {\n    !newHighlights[key] && toDownplay.push(batchItem);\n  });\n  zrUtil.each(newHighlights, function (batchItem, key) {\n    !lastHighlights[key] && toHighlight.push(batchItem);\n  });\n  toDownplay.length && api.dispatchAction({\n    type: 'downplay',\n    escapeConnect: true,\n    batch: toDownplay\n  });\n  toHighlight.length && api.dispatchAction({\n    type: 'highlight',\n    escapeConnect: true,\n    batch: toHighlight\n  });\n}\n\nfunction findInputAxisInfo(inputAxesInfo, axisInfo) {\n  for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n    var inputAxisInfo = inputAxesInfo[i];\n\n    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {\n      return inputAxisInfo;\n    }\n  }\n}\n\nfunction makeMapperParam(axisInfo) {\n  var axisModel = axisInfo.axis.model;\n  var item = {};\n  var dim = item.axisDim = axisInfo.axis.dim;\n  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n  item.axisName = item[dim + 'AxisName'] = axisModel.name;\n  item.axisId = item[dim + 'AxisId'] = axisModel.id;\n  return item;\n}\n\nfunction illegalPoint(point) {\n  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 202 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisPointerModel = echarts.extendComponentModel({\n  type: 'axisPointer',\n  coordSysAxesInfo: null,\n  defaultOption: {\n    // 'auto' means that show when triggered by tooltip or handle.\n    show: 'auto',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: null,\n    // set default in AxisPonterView.js\n    zlevel: 0,\n    z: 50,\n    type: 'line',\n    // axispointer triggered by tootip determine snap automatically,\n    // see `modelHelper`.\n    snap: false,\n    triggerTooltip: true,\n    value: null,\n    status: null,\n    // Init value depends on whether handle is used.\n    // [group0, group1, ...]\n    // Each group can be: {\n    //      mapper: function () {},\n    //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n    //      xAxisId: ...,\n    //      yAxisName: ...,\n    //      angleAxisIndex: ...\n    // }\n    // mapper: can be ignored.\n    //      input: {axisInfo, value}\n    //      output: {axisInfo, value}\n    link: [],\n    // Do not set 'auto' here, otherwise global animation: false\n    // will not effect at this axispointer.\n    animation: null,\n    animationDurationUpdate: 200,\n    lineStyle: {\n      color: '#aaa',\n      width: 1,\n      type: 'solid'\n    },\n    shadowStyle: {\n      color: 'rgba(150,150,150,0.3)'\n    },\n    label: {\n      show: true,\n      formatter: null,\n      // string | Function\n      precision: 'auto',\n      // Or a number like 0, 1, 2 ...\n      margin: 3,\n      color: '#fff',\n      padding: [5, 7, 5, 7],\n      backgroundColor: 'auto',\n      // default: axis line color\n      borderColor: null,\n      borderWidth: 0,\n      shadowBlur: 3,\n      shadowColor: '#aaa' // Considering applicability, common style should\n      // better not have shadowOffset.\n      // shadowOffsetX: 0,\n      // shadowOffsetY: 2\n\n    },\n    handle: {\n      show: false,\n      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',\n      // jshint ignore:line\n      size: 45,\n      // handle margin is from symbol center to axis, which is stable when circular move.\n      margin: 50,\n      // color: '#1b8bbd'\n      // color: '#2f4554'\n      color: '#333',\n      shadowBlur: 3,\n      shadowColor: '#aaa',\n      shadowOffsetX: 0,\n      shadowOffsetY: 2,\n      // For mobile performance\n      throttle: 40\n    }\n  }\n});\nvar _default = AxisPointerModel;\nmodule.exports = _default;\n\n/***/ }),\n/* 203 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar globalListener = __webpack_require__(187);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisPointerView = echarts.extendComponentView({\n  type: 'axisPointer',\n  render: function (globalAxisPointerModel, ecModel, api) {\n    var globalTooltipModel = ecModel.getComponent('tooltip');\n    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable\n    // AxisPointerView to be independent to Tooltip.\n\n    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {\n        dispatchAction({\n          type: 'updateAxisPointer',\n          currTrigger: currTrigger,\n          x: e && e.offsetX,\n          y: e && e.offsetY\n        });\n      }\n    });\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    globalListener.unregister(api.getZr(), 'axisPointer');\n    AxisPointerView.superApply(this._model, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    globalListener.unregister('axisPointer', api);\n    AxisPointerView.superApply(this._model, 'dispose', arguments);\n  }\n});\nvar _default = AxisPointerView;\nmodule.exports = _default;\n\n/***/ }),\n/* 204 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = echarts.extendComponentModel({\n  type: 'tooltip',\n  dependencies: ['axisPointer'],\n  defaultOption: {\n    zlevel: 0,\n    z: 8,\n    show: true,\n    // tooltip主体内容\n    showContent: true,\n    // 'trigger' only works on coordinate system.\n    // 'item' | 'axis' | 'none'\n    trigger: 'item',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: 'mousemove|click',\n    alwaysShowContent: false,\n    displayMode: 'single',\n    // 'single' | 'multipleByCoordSys'\n    // 位置 {Array} | {Function}\n    // position: null\n    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n    // align: null,\n    // verticalAlign: null,\n    // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\n    confine: false,\n    // 内容格式器：{string}（Template） ¦ {Function}\n    // formatter: null\n    showDelay: 0,\n    // 隐藏延迟，单位ms\n    hideDelay: 100,\n    // 动画变换时间，单位s\n    transitionDuration: 0.4,\n    enterable: false,\n    // 提示背景颜色，默认为透明度为0.7的黑色\n    backgroundColor: 'rgba(50,50,50,0.7)',\n    // 提示边框颜色\n    borderColor: '#333',\n    // 提示边框圆角，单位px，默认为4\n    borderRadius: 4,\n    // 提示边框线宽，单位px，默认为0（无边框）\n    borderWidth: 0,\n    // 提示内边距，单位px，默认各方向内边距为5，\n    // 接受数组分别设定上右下左边距，同css\n    padding: 5,\n    // Extra css text\n    extraCssText: '',\n    // 坐标轴指示器，坐标轴触发有效\n    axisPointer: {\n      // 默认为直线\n      // 可选为：'line' | 'shadow' | 'cross'\n      type: 'line',\n      // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n      // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n      // 默认 'auto'，会选择类型为 category 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n      // 极坐标系会默认选择 angle 轴\n      axis: 'auto',\n      animation: 'auto',\n      animationDurationUpdate: 200,\n      animationEasingUpdate: 'exponentialOut',\n      crossStyle: {\n        color: '#999',\n        width: 1,\n        type: 'dashed',\n        // TODO formatter\n        textStyle: {} // lineStyle and shadowStyle should not be specified here,\n        // otherwise it will always override those styles on option.axisPointer.\n\n      }\n    },\n    textStyle: {\n      color: '#fff',\n      fontSize: 14\n    }\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n/* 205 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar env = __webpack_require__(7);\n\nvar TooltipContent = __webpack_require__(206);\n\nvar formatUtil = __webpack_require__(9);\n\nvar numberUtil = __webpack_require__(5);\n\nvar graphic = __webpack_require__(11);\n\nvar findPointFromSeries = __webpack_require__(186);\n\nvar layoutUtil = __webpack_require__(29);\n\nvar Model = __webpack_require__(12);\n\nvar globalListener = __webpack_require__(187);\n\nvar axisHelper = __webpack_require__(30);\n\nvar axisPointerViewHelper = __webpack_require__(185);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar bind = zrUtil.bind;\nvar each = zrUtil.each;\nvar parsePercent = numberUtil.parsePercent;\nvar proxyRect = new graphic.Rect({\n  shape: {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  }\n});\n\nvar _default = echarts.extendComponentView({\n  type: 'tooltip',\n  init: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    var tooltipContent = new TooltipContent(api.getDom(), api);\n    this._tooltipContent = tooltipContent;\n  },\n  render: function (tooltipModel, ecModel, api) {\n    if (env.node || env.wxa) {\n      return;\n    } // Reset\n\n\n    this.group.removeAll();\n    /**\n     * @private\n     * @type {module:echarts/component/tooltip/TooltipModel}\n     */\n\n    this._tooltipModel = tooltipModel;\n    /**\n     * @private\n     * @type {module:echarts/model/Global}\n     */\n\n    this._ecModel = ecModel;\n    /**\n     * @private\n     * @type {module:echarts/ExtensionAPI}\n     */\n\n    this._api = api;\n    /**\n     * Should be cleaned when render.\n     * @private\n     * @type {Array.<Array.<Object>>}\n     */\n\n    this._lastDataByCoordSys = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n    var tooltipContent = this._tooltipContent;\n    tooltipContent.update();\n    tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n    this._initGlobalListener();\n\n    this._keepShow();\n  },\n  _initGlobalListener: function () {\n    var tooltipModel = this._tooltipModel;\n    var triggerOn = tooltipModel.get('triggerOn');\n    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none') {\n        if (triggerOn.indexOf(currTrigger) >= 0) {\n          this._tryShow(e, dispatchAction);\n        } else if (currTrigger === 'leave') {\n          this._hide(dispatchAction);\n        }\n      }\n    }, this));\n  },\n  _keepShow: function () {\n    var tooltipModel = this._tooltipModel;\n    var ecModel = this._ecModel;\n    var api = this._api; // Try to keep the tooltip show when refreshing\n\n    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,\n    // self.manuallyShowTip({x, y}) might cause tooltip hide,\n    // which is not expected.\n    && tooltipModel.get('triggerOn') !== 'none') {\n      var self = this;\n      clearTimeout(this._refreshUpdateTimeout);\n      this._refreshUpdateTimeout = setTimeout(function () {\n        // Show tip next tick after other charts are rendered\n        // In case highlight action has wrong result\n        // FIXME\n        self.manuallyShowTip(tooltipModel, ecModel, api, {\n          x: self._lastX,\n          y: self._lastY\n        });\n      });\n    }\n  },\n\n  /**\n   * Show tip manually by\n   * dispatchAction({\n   *     type: 'showTip',\n   *     x: 10,\n   *     y: 10\n   * });\n   * Or\n   * dispatchAction({\n   *      type: 'showTip',\n   *      seriesIndex: 0,\n   *      dataIndex or dataIndexInside or name\n   * });\n   *\n   *  TODO Batch\n   */\n  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n    if (payload.from === this.uid || env.node) {\n      return;\n    }\n\n    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket\n\n    this._ticket = ''; // When triggered from axisPointer.\n\n    var dataByCoordSys = payload.dataByCoordSys;\n\n    if (payload.tooltip && payload.x != null && payload.y != null) {\n      var el = proxyRect;\n      el.position = [payload.x, payload.y];\n      el.update();\n      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        target: el\n      }, dispatchAction);\n    } else if (dataByCoordSys) {\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        event: {},\n        dataByCoordSys: payload.dataByCoordSys,\n        tooltipOption: payload.tooltipOption\n      }, dispatchAction);\n    } else if (payload.seriesIndex != null) {\n      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n        return;\n      }\n\n      var pointInfo = findPointFromSeries(payload, ecModel);\n      var cx = pointInfo.point[0];\n      var cy = pointInfo.point[1];\n\n      if (cx != null && cy != null) {\n        this._tryShow({\n          offsetX: cx,\n          offsetY: cy,\n          position: payload.position,\n          target: pointInfo.el,\n          event: {}\n        }, dispatchAction);\n      }\n    } else if (payload.x != null && payload.y != null) {\n      // FIXME\n      // should wrap dispatchAction like `axisPointer/globalListener` ?\n      api.dispatchAction({\n        type: 'updateAxisPointer',\n        x: payload.x,\n        y: payload.y\n      });\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        target: api.getZr().findHover(payload.x, payload.y).target,\n        event: {}\n      }, dispatchAction);\n    }\n  },\n  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n    var tooltipContent = this._tooltipContent;\n\n    if (!this._alwaysShowContent && this._tooltipModel) {\n      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n    }\n\n    this._lastX = this._lastY = null;\n\n    if (payload.from !== this.uid) {\n      this._hide(makeDispatchAction(payload, api));\n    }\n  },\n  // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n  // and tooltip.\n  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n    var seriesIndex = payload.seriesIndex;\n    var dataIndex = payload.dataIndex;\n    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n      return;\n    }\n\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n    if (!seriesModel) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);\n\n    if (tooltipModel.get('trigger') !== 'axis') {\n      return;\n    }\n\n    api.dispatchAction({\n      type: 'updateAxisPointer',\n      seriesIndex: seriesIndex,\n      dataIndex: dataIndex,\n      position: payload.position\n    });\n    return true;\n  },\n  _tryShow: function (e, dispatchAction) {\n    var el = e.target;\n    var tooltipModel = this._tooltipModel;\n\n    if (!tooltipModel) {\n      return;\n    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\n\n    this._lastX = e.offsetX;\n    this._lastY = e.offsetY;\n    var dataByCoordSys = e.dataByCoordSys;\n\n    if (dataByCoordSys && dataByCoordSys.length) {\n      this._showAxisTooltip(dataByCoordSys, e);\n    } // Always show item tooltip if mouse is on the element with dataIndex\n    else if (el && el.dataIndex != null) {\n        this._lastDataByCoordSys = null;\n\n        this._showSeriesItemTooltip(e, el, dispatchAction);\n      } // Tooltip provided directly. Like legend.\n      else if (el && el.tooltip) {\n          this._lastDataByCoordSys = null;\n\n          this._showComponentItemTooltip(e, el, dispatchAction);\n        } else {\n          this._lastDataByCoordSys = null;\n\n          this._hide(dispatchAction);\n        }\n  },\n  _showOrMove: function (tooltipModel, cb) {\n    // showDelay is used in this case: tooltip.enterable is set\n    // as true. User intent to move mouse into tooltip and click\n    // something. `showDelay` makes it easyer to enter the content\n    // but tooltip do not move immediately.\n    var delay = tooltipModel.get('showDelay');\n    cb = zrUtil.bind(cb, this);\n    clearTimeout(this._showTimout);\n    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();\n  },\n  _showAxisTooltip: function (dataByCoordSys, e) {\n    var ecModel = this._ecModel;\n    var globalTooltipModel = this._tooltipModel;\n    var point = [e.offsetX, e.offsetY];\n    var singleDefaultHTML = [];\n    var singleParamsList = [];\n    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);\n    each(dataByCoordSys, function (itemCoordSys) {\n      // var coordParamList = [];\n      // var coordDefaultHTML = [];\n      // var coordTooltipModel = buildTooltipModel([\n      //     e.tooltipOption,\n      //     itemCoordSys.tooltipOption,\n      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n      //     globalTooltipModel\n      // ]);\n      // var displayMode = coordTooltipModel.get('displayMode');\n      // var paramsList = displayMode === 'single' ? singleParamsList : [];\n      each(itemCoordSys.dataByAxis, function (item) {\n        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n        var axisValue = item.value;\n        var seriesDefaultHTML = [];\n\n        if (!axisModel || axisValue == null) {\n          return;\n        }\n\n        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);\n        zrUtil.each(item.seriesDataIndices, function (idxItem) {\n          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n          var dataIndex = idxItem.dataIndexInside;\n          var dataParams = series && series.getDataParams(dataIndex);\n          dataParams.axisDim = item.axisDim;\n          dataParams.axisIndex = item.axisIndex;\n          dataParams.axisType = item.axisType;\n          dataParams.axisId = item.axisId;\n          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n          dataParams.axisValueLabel = valueLabel;\n\n          if (dataParams) {\n            singleParamsList.push(dataParams);\n            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n          }\n        }); // Default tooltip content\n        // FIXME\n        // (1) shold be the first data which has name?\n        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\n        var firstLine = valueLabel;\n        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));\n      });\n    }, this); // In most case, the second axis is shown upper than the first one.\n\n    singleDefaultHTML.reverse();\n    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n    var positionExpr = e.position;\n\n    this._showOrMove(singleTooltipModel, function () {\n      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);\n      } else {\n        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);\n      }\n    }); // Do not trigger events here, because this branch only be entered\n    // from dispatchAction.\n\n  },\n  _showSeriesItemTooltip: function (e, el, dispatchAction) {\n    var ecModel = this._ecModel; // Use dataModel in element if possible\n    // Used when mouseover on a element like markPoint or edge\n    // In which case, the data is not main data in series.\n\n    var seriesIndex = el.seriesIndex;\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.\n\n    var dataModel = el.dataModel || seriesModel;\n    var dataIndex = el.dataIndex;\n    var dataType = el.dataType;\n    var data = dataModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);\n    var tooltipTrigger = tooltipModel.get('trigger');\n\n    if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n      return;\n    }\n\n    var params = dataModel.getDataParams(dataIndex, dataType);\n    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n    this._showOrMove(tooltipModel, function () {\n      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);\n    }); // FIXME\n    // duplicated showtip if manuallyShowTip is called from dispatchAction.\n\n\n    dispatchAction({\n      type: 'showTip',\n      dataIndexInside: dataIndex,\n      dataIndex: data.getRawIndex(dataIndex),\n      seriesIndex: seriesIndex,\n      from: this.uid\n    });\n  },\n  _showComponentItemTooltip: function (e, el, dispatchAction) {\n    var tooltipOpt = el.tooltip;\n\n    if (typeof tooltipOpt === 'string') {\n      var content = tooltipOpt;\n      tooltipOpt = {\n        content: content,\n        // Fixed formatter\n        formatter: content\n      };\n    }\n\n    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n    var defaultHtml = subTooltipModel.get('content');\n    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`\n    // only works on cooridinate system. In fact, we have not found case\n    // that requires setting `trigger` nothing on component yet.\n\n    this._showOrMove(subTooltipModel, function () {\n      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);\n    }); // If not dispatch showTip, tip may be hide triggered by axis.\n\n\n    dispatchAction({\n      type: 'showTip',\n      from: this.uid\n    });\n  },\n  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\n    // Reset ticket\n    this._ticket = '';\n\n    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n      return;\n    }\n\n    var tooltipContent = this._tooltipContent;\n    var formatter = tooltipModel.get('formatter');\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var html = defaultHtml;\n\n    if (formatter && typeof formatter === 'string') {\n      html = formatUtil.formatTpl(formatter, params, true);\n    } else if (typeof formatter === 'function') {\n      var callback = bind(function (cbTicket, html) {\n        if (cbTicket === this._ticket) {\n          tooltipContent.setContent(html);\n\n          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n        }\n      }, this);\n      this._ticket = asyncTicket;\n      html = formatter(params, asyncTicket, callback);\n    }\n\n    tooltipContent.setContent(html);\n    tooltipContent.show(tooltipModel);\n\n    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n  },\n\n  /**\n   * @param  {string|Function|Array.<number>|Object} positionExpr\n   * @param  {number} x Mouse x\n   * @param  {number} y Mouse y\n   * @param  {boolean} confine Whether confine tooltip content in view rect.\n   * @param  {Object|<Array.<Object>} params\n   * @param  {module:zrender/Element} el target element\n   * @param  {module:echarts/ExtensionAPI} api\n   * @return {Array.<number>}\n   */\n  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n    var viewWidth = this._api.getWidth();\n\n    var viewHeight = this._api.getHeight();\n\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var contentSize = content.getSize();\n    var align = tooltipModel.get('align');\n    var vAlign = tooltipModel.get('verticalAlign');\n    var rect = el && el.getBoundingRect().clone();\n    el && rect.applyTransform(el.transform);\n\n    if (typeof positionExpr === 'function') {\n      // Callback of position can be an array or a string specify the position\n      positionExpr = positionExpr([x, y], params, content.el, rect, {\n        viewSize: [viewWidth, viewHeight],\n        contentSize: contentSize.slice()\n      });\n    }\n\n    if (zrUtil.isArray(positionExpr)) {\n      x = parsePercent(positionExpr[0], viewWidth);\n      y = parsePercent(positionExpr[1], viewHeight);\n    } else if (zrUtil.isObject(positionExpr)) {\n      positionExpr.width = contentSize[0];\n      positionExpr.height = contentSize[1];\n      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {\n        width: viewWidth,\n        height: viewHeight\n      });\n      x = layoutRect.x;\n      y = layoutRect.y;\n      align = null; // When positionExpr is left/top/right/bottom,\n      // align and verticalAlign will not work.\n\n      vAlign = null;\n    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n    else if (typeof positionExpr === 'string' && el) {\n        var pos = calcTooltipPosition(positionExpr, rect, contentSize);\n        x = pos[0];\n        y = pos[1];\n      } else {\n        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);\n        x = pos[0];\n        y = pos[1];\n      }\n\n    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n    if (tooltipModel.get('confine')) {\n      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);\n      x = pos[0];\n      y = pos[1];\n    }\n\n    content.moveTo(x, y);\n  },\n  // FIXME\n  // Should we remove this but leave this to user?\n  _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n    var lastCoordSys = this._lastDataByCoordSys;\n    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;\n    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n        var thisItem = thisDataByAxis[indexAxis] || {};\n        var lastIndices = lastItem.seriesDataIndices || [];\n        var newIndices = thisItem.seriesDataIndices || [];\n        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;\n        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n          var newIdxItem = newIndices[j];\n          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n        });\n      });\n    });\n    this._lastDataByCoordSys = dataByCoordSys;\n    return !!contentNotChanged;\n  },\n  _hide: function (dispatchAction) {\n    // Do not directly hideLater here, because this behavior may be prevented\n    // in dispatchAction when showTip is dispatched.\n    // FIXME\n    // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n    this._lastDataByCoordSys = null;\n    dispatchAction({\n      type: 'hideTip',\n      from: this.uid\n    });\n  },\n  dispose: function (ecModel, api) {\n    if (env.node || env.wxa) {\n      return;\n    }\n\n    this._tooltipContent.hide();\n\n    globalListener.unregister('itemTooltip', api);\n  }\n});\n/**\n * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n * From top to bottom. (the last one should be globalTooltipModel);\n */\n\n\nfunction buildTooltipModel(modelCascade) {\n  var resultModel = modelCascade.pop();\n\n  while (modelCascade.length) {\n    var tooltipOpt = modelCascade.pop();\n\n    if (tooltipOpt) {\n      if (Model.isInstance(tooltipOpt)) {\n        tooltipOpt = tooltipOpt.get('tooltip', true);\n      } // In each data item tooltip can be simply write:\n      // {\n      //  value: 10,\n      //  tooltip: 'Something you need to know'\n      // }\n\n\n      if (typeof tooltipOpt === 'string') {\n        tooltipOpt = {\n          formatter: tooltipOpt\n        };\n      }\n\n      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n    }\n  }\n\n  return resultModel;\n}\n\nfunction makeDispatchAction(payload, api) {\n  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n}\n\nfunction refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n\n  if (gapH != null) {\n    if (x + width + gapH > viewWidth) {\n      x -= width + gapH;\n    } else {\n      x += gapH;\n    }\n  }\n\n  if (gapV != null) {\n    if (y + height + gapV > viewHeight) {\n      y -= height + gapV;\n    } else {\n      y += gapV;\n    }\n  }\n\n  return [x, y];\n}\n\nfunction confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n  x = Math.min(x + width, viewWidth) - width;\n  y = Math.min(y + height, viewHeight) - height;\n  x = Math.max(x, 0);\n  y = Math.max(y, 0);\n  return [x, y];\n}\n\nfunction getOuterSize(el) {\n  var width = el.clientWidth;\n  var height = el.clientHeight; // Consider browser compatibility.\n  // IE8 does not support getComputedStyle.\n\n  if (document.defaultView && document.defaultView.getComputedStyle) {\n    var stl = document.defaultView.getComputedStyle(el);\n\n    if (stl) {\n      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nfunction calcTooltipPosition(position, rect, contentSize) {\n  var domWidth = contentSize[0];\n  var domHeight = contentSize[1];\n  var gap = 5;\n  var x = 0;\n  var y = 0;\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n\n  switch (position) {\n    case 'inside':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'top':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y - domHeight - gap;\n      break;\n\n    case 'bottom':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight + gap;\n      break;\n\n    case 'left':\n      x = rect.x - domWidth - gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'right':\n      x = rect.x + rectWidth + gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n  }\n\n  return [x, y];\n}\n\nfunction isCenterAlign(align) {\n  return align === 'center' || align === 'middle';\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 206 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar zrColor = __webpack_require__(19);\n\nvar eventUtil = __webpack_require__(31);\n\nvar env = __webpack_require__(7);\n\nvar formatUtil = __webpack_require__(9);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar toCamelCase = formatUtil.toCamelCase;\nvar vendors = ['', '-webkit-', '-moz-', '-o-'];\nvar gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n/**\n * @param {number} duration\n * @return {string}\n * @inner\n */\n\nfunction assembleTransition(duration) {\n  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;\n  return zrUtil.map(vendors, function (vendorPrefix) {\n    return vendorPrefix + 'transition:' + transitionText;\n  }).join(';');\n}\n/**\n * @param {Object} textStyle\n * @return {string}\n * @inner\n */\n\n\nfunction assembleFont(textStyleModel) {\n  var cssText = [];\n  var fontSize = textStyleModel.get('fontSize');\n  var color = textStyleModel.getTextColor();\n  color && cssText.push('color:' + color);\n  cssText.push('font:' + textStyleModel.getFont());\n  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n  each(['decoration', 'align'], function (name) {\n    var val = textStyleModel.get(name);\n    val && cssText.push('text-' + name + ':' + val);\n  });\n  return cssText.join(';');\n}\n/**\n * @param {Object} tooltipModel\n * @return {string}\n * @inner\n */\n\n\nfunction assembleCssText(tooltipModel) {\n  var cssText = [];\n  var transitionDuration = tooltipModel.get('transitionDuration');\n  var backgroundColor = tooltipModel.get('backgroundColor');\n  var textStyleModel = tooltipModel.getModel('textStyle');\n  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.\n\n  transitionDuration && cssText.push(assembleTransition(transitionDuration));\n\n  if (backgroundColor) {\n    if (env.canvasSupported) {\n      cssText.push('background-Color:' + backgroundColor);\n    } else {\n      // for ie\n      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));\n      cssText.push('filter:alpha(opacity=70)');\n    }\n  } // Border style\n\n\n  each(['width', 'color', 'radius'], function (name) {\n    var borderName = 'border-' + name;\n    var camelCase = toCamelCase(borderName);\n    var val = tooltipModel.get(camelCase);\n    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n  }); // Text style\n\n  cssText.push(assembleFont(textStyleModel)); // Padding\n\n  if (padding != null) {\n    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n  }\n\n  return cssText.join(';') + ';';\n}\n/**\n * @alias module:echarts/component/tooltip/TooltipContent\n * @constructor\n */\n\n\nfunction TooltipContent(container, api) {\n  if (env.wxa) {\n    return null;\n  }\n\n  var el = document.createElement('div');\n  var zr = this._zr = api.getZr();\n  this.el = el;\n  this._x = api.getWidth() / 2;\n  this._y = api.getHeight() / 2;\n  container.appendChild(el);\n  this._container = container;\n  this._show = false;\n  /**\n   * @private\n   */\n\n  this._hideTimeout;\n  var self = this;\n\n  el.onmouseenter = function () {\n    // clear the timeout in hideLater and keep showing tooltip\n    if (self._enterable) {\n      clearTimeout(self._hideTimeout);\n      self._show = true;\n    }\n\n    self._inContent = true;\n  };\n\n  el.onmousemove = function (e) {\n    e = e || window.event;\n\n    if (!self._enterable) {\n      // Try trigger zrender event to avoid mouse\n      // in and out shape too frequently\n      var handler = zr.handler;\n      eventUtil.normalizeEvent(container, e, true);\n      handler.dispatch('mousemove', e);\n    }\n  };\n\n  el.onmouseleave = function () {\n    if (self._enterable) {\n      if (self._show) {\n        self.hideLater(self._hideDelay);\n      }\n    }\n\n    self._inContent = false;\n  };\n}\n\nTooltipContent.prototype = {\n  constructor: TooltipContent,\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  _enterable: true,\n\n  /**\n   * Update when tooltip is rendered\n   */\n  update: function () {\n    // FIXME\n    // Move this logic to ec main?\n    var container = this._container;\n    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);\n    var domStyle = container.style;\n\n    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n      domStyle.position = 'relative';\n    } // Hide the tooltip\n    // PENDING\n    // this.hide();\n\n  },\n  show: function (tooltipModel) {\n    clearTimeout(this._hideTimeout);\n    var el = this.el;\n    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');\n    el.style.display = el.innerHTML ? 'block' : 'none';\n    this._show = true;\n  },\n  setContent: function (content) {\n    this.el.innerHTML = content == null ? '' : content;\n  },\n  setEnterable: function (enterable) {\n    this._enterable = enterable;\n  },\n  getSize: function () {\n    var el = this.el;\n    return [el.clientWidth, el.clientHeight];\n  },\n  moveTo: function (x, y) {\n    // xy should be based on canvas root. But tooltipContent is\n    // the sibling of canvas root. So padding of ec container\n    // should be considered here.\n    var zr = this._zr;\n    var viewportRootOffset;\n\n    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n      x += viewportRootOffset.offsetLeft;\n      y += viewportRootOffset.offsetTop;\n    }\n\n    var style = this.el.style;\n    style.left = x + 'px';\n    style.top = y + 'px';\n    this._x = x;\n    this._y = y;\n  },\n  hide: function () {\n    this.el.style.display = 'none';\n    this._show = false;\n  },\n  hideLater: function (time) {\n    if (this._show && !(this._inContent && this._enterable)) {\n      if (time) {\n        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times\n\n        this._show = false;\n        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n      } else {\n        this.hide();\n      }\n    }\n  },\n  isShow: function () {\n    return this._show;\n  }\n};\nvar _default = TooltipContent;\nmodule.exports = _default;\n\n/***/ }),\n/* 207 */\n/***/ (function(module, exports) {\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 208 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(11);\n\nvar SymbolClz = __webpack_require__(199);\n\nvar _util = __webpack_require__(0);\n\nvar isObject = _util.isObject;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n/***/ }),\n/* 209 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n__webpack_require__(210);\n\n__webpack_require__(215);\n\n__webpack_require__(211);\n\nvar legendFilter = __webpack_require__(216);\n\nvar Component = __webpack_require__(13);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n/***/ }),\n/* 210 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar Model = __webpack_require__(12);\n\nvar _model = __webpack_require__(1);\n\nvar isNameSpecified = _model.isNameSpecified;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // 一级层叠\n    zlevel: 0,\n    // 二级层叠\n    z: 4,\n    show: true,\n    // 布局方式，默认为水平布局，可选为：\n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // 水平对齐\n    // 'auto' | 'left' | 'right'\n    // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // 图例边框颜色\n    borderColor: '#ccc',\n    borderRadius: 0,\n    // 图例边框线宽，单位px，默认为0（无边框）\n    borderWidth: 0,\n    // 图例内边距，单位px，默认各方向内边距为5，\n    // 接受数组分别设定上右下左边距，同css\n    padding: 5,\n    // 各个item之间的间隔，单位px，默认为10，\n    // 横向布局时为水平间隔，纵向布局时为纵向间隔\n    itemGap: 10,\n    // 图例图形宽度\n    itemWidth: 25,\n    // 图例图形高度\n    itemHeight: 14,\n    // 图例关闭时候的颜色\n    inactiveColor: '#ccc',\n    textStyle: {\n      // 图例文字颜色\n      color: '#333'\n    },\n    // formatter: '',\n    // 选择模式，默认开启图例开关\n    selectedMode: true,\n    // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n    // selected: null,\n    // 图例内容（详见legend.data，数组中每一项代表一个item\n    // data: [],\n    // Tooltip 相关配置\n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n/***/ }),\n/* 211 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar _symbol = __webpack_require__(77);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(11);\n\nvar _listComponent = __webpack_require__(212);\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = __webpack_require__(29);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    var excludeSeriesId = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);\n    });\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      } // Representitive series.\n\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api, excludeSeriesId));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode); // FIXME: consider different series has items with the same name.\n\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api, excludeSeriesId));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var symbolKeepAspect = legendModel.get('symbolKeepAspect');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend\n    symbolKeepAspect == null ? true : symbolKeepAspect)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend\n      symbolKeepAspect == null ? true : symbolKeepAspect));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 212 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _layout = __webpack_require__(29);\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = __webpack_require__(9);\n\nvar graphic = __webpack_require__(11);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n/***/ }),\n/* 213 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(0);\n\nvar createHashMap = _util.createHashMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 214 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _dataProvider = __webpack_require__(20);\n\nvar retrieveRawValue = _dataProvider.retrieveRawValue;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/data/List} data\n * @param {number} dataIndex\n * @return {string} label string. Not null/undefined\n */\nfunction getDefaultLabel(data, dataIndex) {\n  var labelDims = data.mapDimension('defaultedLabel', true);\n  var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)\n\n  if (len === 1) {\n    return retrieveRawValue(data, dataIndex, labelDims[0]);\n  } else if (len) {\n    var vals = [];\n\n    for (var i = 0; i < labelDims.length; i++) {\n      var val = retrieveRawValue(data, dataIndex, labelDims[i]);\n      vals.push(val);\n    }\n\n    return vals.join(' ');\n  }\n}\n\nexports.getDefaultLabel = getDefaultLabel;\n\n/***/ }),\n/* 215 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n/***/ }),\n/* 216 */\n/***/ (function(module, exports) {\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 217 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(188);\n\n__webpack_require__(189);\n\n__webpack_require__(184);\n\n/***/ }),\n/* 218 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Cartesian = __webpack_require__(219);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, reserved, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  clampData: function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));\n    return out;\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n/***/ }),\n/* 219 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n/***/ }),\n/* 220 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Axis = __webpack_require__(81);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * Implemented in <module:echarts/coord/cartesian/Grid>.\n   * @return {Array.<module:echarts/coord/cartesian/Axis2D>}\n   *         If not on zero of other axis, return null/undefined.\n   *         If no axes, return an empty array.\n   */\n  getAxesOnZeroOf: null,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n/***/ }),\n/* 221 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(193);\n\nvar ComponentModel = __webpack_require__(13);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n/* 222 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(193);\n\n__webpack_require__(223);\n\n/***/ }),\n/* 223 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(11);\n\nvar AxisBuilder = __webpack_require__(182);\n\nvar AxisView = __webpack_require__(183);\n\nvar cartesianAxisHelper = __webpack_require__(190);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n  remove: function () {\n    this._splitAreaColors = null;\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitAreaModel,\n      clamp: true\n    });\n\n    if (!ticksCoords.length) {\n      return;\n    } // For Making appropriate splitArea animation, the color and anid\n    // should be corresponding to previous one if possible.\n\n\n    var areaColorsLen = areaColors.length;\n    var lastSplitAreaColors = this._splitAreaColors;\n    var newSplitAreaColors = zrUtil.createHashMap();\n    var colorIndex = 0;\n\n    if (lastSplitAreaColors) {\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n        if (cIndex != null) {\n          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n          break;\n        }\n      }\n    }\n\n    var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prev;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n        prev = x + width;\n      } else {\n        x = gridRect.x;\n        y = prev;\n        width = gridRect.width;\n        height = tickCoord - y;\n        prev = y + height;\n      }\n\n      var tickValue = ticksCoords[i - 1].tickValue;\n      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: tickValue != null ? 'area_' + tickValue : null,\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      colorIndex = (colorIndex + 1) % areaColorsLen;\n    }\n\n    this._splitAreaColors = newSplitAreaColors;\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n/***/ }),\n/* 224 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _dataStackHelper = __webpack_require__(32);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = __webpack_require__(0);\n\nvar map = _util.map;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var dims = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  var stacked;\n  var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n  if (stacked |= isDimensionStacked(data, dims[0]\n  /*, dims[1]*/\n  )) {\n    // jshint ignore:line\n    dims[0] = stackResultDim;\n  }\n\n  if (stacked |= isDimensionStacked(data, dims[1]\n  /*, dims[0]*/\n  )) {\n    // jshint ignore:line\n    dims[1] = stackResultDim;\n  }\n\n  return {\n    dataDimsForPoint: dims,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: !!stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n/***/ }),\n/* 225 */,\n/* 226 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n/* 227 */,\n/* 228 */,\n/* 229 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 230 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(3);\n\nvar vec2 = __webpack_require__(2);\n\nvar fixClipWithShadow = __webpack_require__(88);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n/***/ }),\n/* 231 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\n__webpack_require__(232);\n\n__webpack_require__(233);\n\nvar createDataSelectAction = __webpack_require__(229);\n\nvar dataColor = __webpack_require__(213);\n\nvar pieLayout = __webpack_require__(234);\n\nvar dataFilter = __webpack_require__(207);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n/***/ }),\n/* 232 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar createListSimply = __webpack_require__(192);\n\nvar zrUtil = __webpack_require__(0);\n\nvar modelUtil = __webpack_require__(1);\n\nvar _number = __webpack_require__(5);\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = __webpack_require__(226);\n\nvar _dataProvider = __webpack_require__(20);\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // 默认全局居中\n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // 默认顺时针\n    clockwise: true,\n    startAngle: 90,\n    // 最小角度改为0\n    minAngle: 0,\n    // 选中时扇区偏移量\n    selectedOffset: 10,\n    // 高亮扇区偏移量\n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // 选择模式，默认关闭，可选single，multiple\n    // selectedMode: false,\n    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n      // 默认使用全局文本样式，详见TEXTSTYLE\n      // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // 引导线两段中的第一段长度\n      length: 15,\n      // 引导线两段中的第二段长度\n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: 各异,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n/***/ }),\n/* 233 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(11);\n\nvar ChartView = __webpack_require__(79);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n/***/ }),\n/* 234 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _number = __webpack_require__(5);\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = __webpack_require__(235);\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 235 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar textContain = __webpack_require__(14);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // 压\n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // 弹\n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // 右侧\n    ? Number.MAX_VALUE // 下\n    : 0 // 上\n    : isDownList // 左侧\n    ? Number.MAX_VALUE // 下\n    : 0; // 上\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // 右下，左下\n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // 右上，左上\n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 236 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n__webpack_require__(237);\n\n__webpack_require__(238);\n\nvar visualSymbol = __webpack_require__(191);\n\nvar layoutPoints = __webpack_require__(200);\n\nvar dataSample = __webpack_require__(240);\n\n__webpack_require__(188);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n/***/ }),\n/* 237 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = __webpack_require__(80);\n\nvar SeriesModel = __webpack_require__(78);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    symbol: 'emptyCircle',\n    symbolSize: 4,\n    symbolRotate: null,\n    showSymbol: true,\n    // `false`: follow the label interval strategy.\n    // `true`: show all symbols.\n    // `'auto'`: If possible, show all symbols, otherwise\n    //           follow the label interval strategy.\n    showAllSymbol: 'auto',\n    // Whether to connect break point.\n    connectNulls: false,\n    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n/* 238 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(0);\n\nvar SymbolDraw = __webpack_require__(208);\n\nvar SymbolClz = __webpack_require__(199);\n\nvar lineAnimationDiff = __webpack_require__(239);\n\nvar graphic = __webpack_require__(11);\n\nvar modelUtil = __webpack_require__(1);\n\nvar _poly = __webpack_require__(230);\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = __webpack_require__(79);\n\nvar _number = __webpack_require__(5);\n\nvar round = _number.round;\n\nvar _helper = __webpack_require__(224);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, forSymbol, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y; // Avoid float number rounding error for symbol on the edge of axis extent.\n  // See #7913 and `test/dataZoom-clip.html`.\n\n  if (forSymbol) {\n    x -= 0.5;\n    width += 0.5;\n    y -= 0.5;\n    height += 0.5;\n  } else {\n    var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n    var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n    if (isHorizontal) {\n      y -= expandSize;\n      height += expandSize * 2;\n    } else {\n      x -= expandSize;\n      width += expandSize * 2;\n    }\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, forSymbol, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent().slice();\n  radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180; // Avoid float number rounding error for symbol on the edge of axis extent.\n\n  if (forSymbol) {\n    radiusExtent[0] -= 0.5;\n    radiusExtent[1] += 0.5;\n  }\n\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: round(polar.cx, 1),\n      cy: round(polar.cy, 1),\n      r0: round(radiusExtent[0], 1),\n      r: round(radiusExtent[1], 1),\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, forSymbol, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, forSymbol, seriesModel) : createGridClipShape(coordSys, hasAnimation, forSymbol, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nfunction getIsIgnoreFunc(seriesModel, data, coordSys) {\n  var showAllSymbol = seriesModel.get('showAllSymbol');\n  var isAuto = showAllSymbol === 'auto';\n\n  if (showAllSymbol && !isAuto) {\n    return;\n  }\n\n  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n  if (!categoryAxis) {\n    return;\n  } // Note that category label interval strategy might bring some weird effect\n  // in some scenario: users may wonder why some of the symbols are not\n  // displayed. So we show all symbols as possible as we can.\n\n\n  if (isAuto // Simplify the logic, do not determine label overlap here.\n  && canShowAllSymbolForCategory(categoryAxis, data)) {\n    return;\n  } // Otherwise follow the label interval strategy on category axis.\n\n\n  var categoryDataDim = data.mapDimension(categoryAxis.dim);\n  var labelMap = {};\n  zrUtil.each(categoryAxis.getViewLabels(), function (labelItem) {\n    labelMap[labelItem.tickValue] = 1;\n  });\n  return function (dataIndex) {\n    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));\n  };\n}\n\nfunction canShowAllSymbolForCategory(categoryAxis, data) {\n  // In mose cases, line is monotonous on category axis, and the label size\n  // is close with each other. So we check the symbol size and some of the\n  // label size alone with the category axis to estimate whether all symbol\n  // can be shown without overlap.\n  var axisExtent = categoryAxis.getExtent();\n  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();\n  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.\n  // Sampling some points, max 5.\n\n  var dataLen = data.count();\n  var step = Math.max(1, Math.round(dataLen / 5));\n\n  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {\n    if (SymbolClz.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.\n    )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number\n    * 1.5 > availSize) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, false, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      } // Update clipPath\n\n\n      lineGroup.setClipPath(createClipShape(coordSys, false, false, seriesModel)); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n/* 239 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _helper = __webpack_require__(224);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 240 */\n/***/ (function(module, exports) {\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(max) ? max : NaN;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(min) ? min : NaN;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    modifyOutputEnd: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            // Only support sample the first dim mapped from value axis.\n            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 241 */,\n/* 242 */,\n/* 243 */,\n/* 244 */,\n/* 245 */,\n/* 246 */,\n/* 247 */,\n/* 248 */,\n/* 249 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SeriesModel = __webpack_require__(78);\n\nvar createListFromArray = __webpack_require__(80);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = SeriesModel.extend({\n  type: 'series.__base_bar__',\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  getMarkerPosition: function (value) {\n    var coordSys = this.coordinateSystem;\n\n    if (coordSys) {\n      // PENDING if clamp ?\n      var pt = coordSys.dataToPoint(coordSys.clampData(value));\n      var data = this.getData();\n      var offset = data.getLayout('offset');\n      var size = data.getLayout('size');\n      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n      pt[offsetIndex] += offset + size / 2;\n      return pt;\n    }\n\n    return [NaN, NaN];\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // 最小高度改为0\n    barMinHeight: 0,\n    // 最小角度为0，仅对极坐标系下的柱状图有效\n    barMinAngle: 0,\n    // cursor: null,\n    large: false,\n    largeThreshold: 400,\n    progressive: 5e3,\n    progressiveChunkMode: 'mod',\n    // barMaxWidth: null,\n    // 默认自适应\n    // barWidth: null,\n    // 柱间距离，默认为柱形宽度的30%，可设固定值\n    // barGap: '30%',\n    // 类目间柱形距离，默认为类目间距的20%，可设固定值\n    // barCategoryGap: '20%',\n    // label: {\n    //      show: false\n    // },\n    itemStyle: {},\n    emphasis: {}\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n/* 250 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(11);\n\nvar _labelHelper = __webpack_require__(214);\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label');\n  var hoverLabelModel = itemModel.getModel('emphasis.label');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nexports.setLabel = setLabel;\n\n/***/ }),\n/* 251 */,\n/* 252 */,\n/* 253 */,\n/* 254 */,\n/* 255 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar _barGrid = __webpack_require__(87);\n\nvar layout = _barGrid.layout;\nvar largeLayout = _barGrid.largeLayout;\n\n__webpack_require__(196);\n\n__webpack_require__(256);\n\n__webpack_require__(257);\n\n__webpack_require__(188);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// In case developer forget to include grid component\necharts.registerLayout(zrUtil.curry(layout, 'bar')); // Should after normal bar layout, otherwise it is blocked by normal bar layout.\n\necharts.registerLayout(largeLayout);\necharts.registerVisual({\n  seriesType: 'bar',\n  reset: function (seriesModel) {\n    // Visual coding for legend\n    seriesModel.getData().setVisual('legendSymbol', 'roundRect');\n  }\n});\n\n/***/ }),\n/* 256 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BaseBarSeries = __webpack_require__(249);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = BaseBarSeries.extend({\n  type: 'series.bar',\n  dependencies: ['grid', 'polar'],\n  brushSelector: 'rect',\n\n  /**\n   * @override\n   */\n  getProgressive: function () {\n    // Do not support progressive in normal mode.\n    return this.get('large') ? this.get('progressive') : false;\n  },\n\n  /**\n   * @override\n   */\n  getProgressiveThreshold: function () {\n    // Do not support progressive in normal mode.\n    var progressiveThreshold = this.get('progressiveThreshold');\n    var largeThreshold = this.get('largeThreshold');\n\n    if (largeThreshold > progressiveThreshold) {\n      progressiveThreshold = largeThreshold;\n    }\n\n    return progressiveThreshold;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n/* 257 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(11);\n\nvar _helper = __webpack_require__(250);\n\nvar setLabel = _helper.setLabel;\n\nvar Model = __webpack_require__(12);\n\nvar barItemStyle = __webpack_require__(258);\n\nvar Path = __webpack_require__(3);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'barBorderWidth']; // FIXME\n// Just for compatible with ec2.\n\nzrUtil.extend(Model.prototype, barItemStyle);\n\nvar _default = echarts.extendChartView({\n  type: 'bar',\n  render: function (seriesModel, ecModel, api) {\n    this._updateDrawMode(seriesModel);\n\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api);\n    } else {}\n\n    return this.group;\n  },\n  incrementalPrepareRender: function (seriesModel, ecModel, api) {\n    this._clear();\n\n    this._updateDrawMode(seriesModel);\n  },\n  incrementalRender: function (params, seriesModel, ecModel, api) {\n    // Do not support progressive in normal mode.\n    this._incrementalRenderLarge(params, seriesModel);\n  },\n  _updateDrawMode: function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n\n    if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n\n      this._clear();\n    }\n  },\n  _renderNormal: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).update(function (newIndex, oldIndex) {\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (el) {\n        graphic.updateProps(el, {\n          shape: layout\n        }, animationModel, newIndex);\n      } else {\n        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);\n      }\n\n      data.setItemGraphicEl(newIndex, el); // Add back\n\n      group.add(el);\n      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n\n      if (coord.type === 'cartesian2d') {\n        el && removeRect(dataIndex, animationModel, el);\n      } else {\n        el && removeSector(dataIndex, animationModel, el);\n      }\n    }).execute();\n    this._data = data;\n  },\n  _renderLarge: function (seriesModel, ecModel, api) {\n    this._clear();\n\n    createLarge(seriesModel, this.group);\n  },\n  _incrementalRenderLarge: function (params, seriesModel) {\n    createLarge(seriesModel, this.group, true);\n  },\n  dispose: zrUtil.noop,\n  remove: function (ecModel) {\n    this._clear(ecModel);\n  },\n  _clear: function (ecModel) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel && ecModel.get('animation') && data && !this._isLargeDraw) {\n      data.eachItemGraphicEl(function (el) {\n        if (el.type === 'sector') {\n          removeSector(el.dataIndex, ecModel, el);\n        } else {\n          removeRect(el.dataIndex, ecModel, el);\n        }\n      });\n    } else {\n      group.removeAll();\n    }\n\n    this._data = null;\n  }\n});\n\nvar elementCreator = {\n  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var rect = new graphic.Rect({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      var animateTarget = {};\n      rectShape[animateProperty] = 0;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return rect;\n  },\n  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {\n    // Keep the same logic with bar in catesion: use end value to control\n    // direction. Notice that if clockwise is true (by default), the sector\n    // will always draw clockwisely, no matter whether endAngle is greater\n    // or less than startAngle.\n    var clockwise = layout.startAngle < layout.endAngle;\n    var sector = new graphic.Sector({\n      shape: zrUtil.defaults({\n        clockwise: clockwise\n      }, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return sector;\n  }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      width: 0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      r: el.shape.r0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nvar getLayout = {\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var color = data.getItemVisual(dataIndex, 'color');\n  var opacity = data.getItemVisual(dataIndex, 'opacity');\n  var itemStyleModel = itemModel.getModel('itemStyle');\n  var hoverStyle = itemModel.getModel('emphasis.itemStyle').getBarItemStyle();\n\n  if (!isPolar) {\n    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n  }\n\n  el.useStyle(zrUtil.defaults({\n    fill: color,\n    opacity: opacity\n  }, itemStyleModel.getBarItemStyle()));\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\n  if (!isPolar) {\n    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);\n  }\n\n  graphic.setHoverStyle(el, hoverStyle);\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nvar LargePath = Path.extend({\n  type: 'largeBar',\n  shape: {\n    points: []\n  },\n  buildPath: function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n    var startPoint = this.__startPoint;\n    var valueIdx = this.__valueIdx;\n\n    for (var i = 0; i < points.length; i += 2) {\n      startPoint[this.__valueIdx] = points[i + valueIdx];\n      ctx.moveTo(startPoint[0], startPoint[1]);\n      ctx.lineTo(points[i], points[i + 1]);\n    }\n  }\n});\n\nfunction createLarge(seriesModel, group, incremental) {\n  // TODO support polar\n  var data = seriesModel.getData();\n  var startPoint = [];\n  var valueIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;\n  startPoint[1 - valueIdx] = data.getLayout('valueAxisStart');\n  var el = new LargePath({\n    shape: {\n      points: data.getLayout('largePoints')\n    },\n    incremental: !!incremental,\n    __startPoint: startPoint,\n    __valueIdx: valueIdx\n  });\n  group.add(el);\n  setLargeStyle(el, seriesModel, data);\n}\n\nfunction setLargeStyle(el, seriesModel, data) {\n  var borderColor = data.getVisual('borderColor') || data.getVisual('color');\n  var itemStyle = seriesModel.getModel('itemStyle').getItemStyle(['color', 'borderColor']);\n  el.useStyle(itemStyle);\n  el.style.fill = null;\n  el.style.stroke = borderColor;\n  el.style.lineWidth = data.getLayout('barWidth');\n}\n\nmodule.exports = _default;\n\n/***/ }),\n/* 258 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar makeStyleMapper = __webpack_require__(33);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getBarItemStyle: function (excludes) {\n    var style = getBarItemStyle(this, excludes);\n\n    if (this.getBorderLineDash) {\n      var lineDash = this.getBorderLineDash();\n      lineDash && (style.lineDash = lineDash);\n    }\n\n    return style;\n  }\n};\nmodule.exports = _default;\n\n/***/ })\n]));\n\n\n// WEBPACK FOOTER //\n// static/js/BarReact.4a94bb09.chunk.js","/**\r\n * Created by yongyuehuang on 2017/8/5.\r\n */\r\nimport React from 'react'\r\nimport echarts from 'echarts/lib/echarts' //必须\r\nimport 'echarts/lib/component/tooltip'\r\nimport 'echarts/lib/component/grid'\r\nimport 'echarts/lib/chart/bar'\r\nimport 'echarts/lib/component/legend'\r\nimport 'echarts/lib/chart/pie'\r\nimport 'echarts/lib/chart/line'\r\n\r\nexport default class BarReact extends React.Component {\r\n  \r\n  constructor(props) {\r\n    super(props)\r\n    this.initPie = this.initPie.bind(this)\r\n  }\r\n  \r\n  initPie() {\r\n    const { option={} } = this.props //外部传入的data数据\r\n \r\n    let myChart = echarts.init(this.ID) //初始化echarts\r\n    //设置options\r\n    myChart.setOption(option)\r\n    window.onresize = function() {\r\n      //myChart.showLoading();\r\n      myChart.resize()\r\n    }\r\n  }\r\n  \r\n  componentDidMount() {\r\n    this.initPie()\r\n  }\r\n  \r\n  componentDidUpdate() {\r\n    this.initPie()\r\n  }\r\n  \r\n  render() {\r\n    const { width=\"100%\", height=\"100%\"} = this.props\r\n    return <div ref={ID => this.ID = ID} style={{width, height}}></div>\r\n  }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/EchartsDemo/BarReact.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n// allAxesInfo should be updated when setOption performed.\n\nfunction collect(ecModel, api) {\n  var result = {\n    /**\n     * key: makeKey(axis.model)\n     * value: {\n     *      axis,\n     *      coordSys,\n     *      axisPointerModel,\n     *      triggerTooltip,\n     *      involveSeries,\n     *      snap,\n     *      seriesModels,\n     *      seriesDataCount\n     * }\n     */\n    axesInfo: {},\n    seriesInvolved: false,\n\n    /**\n     * key: makeKey(coordSys.model)\n     * value: Object: key makeKey(axis.model), value: axisInfo\n     */\n    coordSysAxesInfo: {},\n    coordSysMap: {}\n  };\n  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.\n\n  result.seriesInvolved && collectSeriesInfo(result, ecModel);\n  return result;\n}\n\nfunction collectAxesInfo(result, ecModel, api) {\n  var globalTooltipModel = ecModel.getComponent('tooltip');\n  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.\n\n  var linksOption = globalAxisPointerModel.get('link', true) || [];\n  var linkGroups = []; // Collect axes info.\n\n  each(api.getCoordinateSystems(), function (coordSys) {\n    // Some coordinate system do not support axes, like geo.\n    if (!coordSys.axisPointerEnabled) {\n      return;\n    }\n\n    var coordSysKey = makeKey(coordSys.model);\n    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer\n    // for user. So we enable seting tooltip on coordSys model.\n\n    var coordSysModel = coordSys.model;\n    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.\n    // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n\n    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not\n    // show but axisPointer will show as normal.\n    && baseTooltipModel.get('show')) {\n      // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n      // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n\n      if (triggerAxis || cross) {\n        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));\n      }\n\n      if (cross) {\n        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n      }\n    } // fromTooltip: true | false | 'cross'\n    // triggerTooltip: true | false | null\n\n\n    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n      var axisPointerShow = axisPointerModel.get('show');\n\n      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {\n        return;\n      }\n\n      if (triggerTooltip == null) {\n        triggerTooltip = axisPointerModel.get('triggerTooltip');\n      }\n\n      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;\n      var snap = axisPointerModel.get('snap');\n      var key = makeKey(axis.model);\n      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n\n      var axisInfo = result.axesInfo[key] = {\n        key: key,\n        axis: axis,\n        coordSys: coordSys,\n        axisPointerModel: axisPointerModel,\n        triggerTooltip: triggerTooltip,\n        involveSeries: involveSeries,\n        snap: snap,\n        useHandle: isHandleTrigger(axisPointerModel),\n        seriesModels: []\n      };\n      axesInfoInCoordSys[key] = axisInfo;\n      result.seriesInvolved |= involveSeries;\n      var groupIndex = getLinkGroupIndex(linksOption, axis);\n\n      if (groupIndex != null) {\n        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {\n          axesInfo: {}\n        });\n        linkGroup.axesInfo[key] = axisInfo;\n        linkGroup.mapper = linksOption[groupIndex].mapper;\n        axisInfo.linkGroup = linkGroup;\n      }\n    }\n  });\n}\n\nfunction makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {\n  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n  var volatileOption = {};\n  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {\n    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n  }); // category axis do not auto snap, otherwise some tick that do not\n  // has value can not be hovered. value/time/log axis default snap if\n  // triggered from tooltip and trigger tooltip.\n\n  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.\n  // Only these properties can be overrided from tooltip to axisPointer.\n\n  if (tooltipAxisPointerModel.get('type') === 'cross') {\n    volatileOption.type = 'line';\n  }\n\n  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.\n\n  labelOption.show == null && (labelOption.show = false);\n\n  if (fromTooltip === 'cross') {\n    // When 'cross', both axes show labels.\n    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get('label.show');\n    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style\n    // (cross style is dashed by default)\n\n    if (!triggerTooltip) {\n      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);\n    }\n  }\n\n  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));\n}\n\nfunction collectSeriesInfo(result, ecModel) {\n  // Prepare data for axis trigger\n  ecModel.eachSeries(function (seriesModel) {\n    // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n    var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n\n    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {\n      return;\n    }\n\n    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n      var axis = axisInfo.axis;\n\n      if (coordSys.getAxis(axis.dim) === axis) {\n        axisInfo.seriesModels.push(seriesModel);\n        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n        axisInfo.seriesDataCount += seriesModel.getData().count();\n      }\n    });\n  }, this);\n}\n/**\n * For example:\n * {\n *     axisPointer: {\n *         links: [{\n *             xAxisIndex: [2, 4],\n *             yAxisIndex: 'all'\n *         }, {\n *             xAxisId: ['a5', 'a7'],\n *             xAxisName: 'xxx'\n *         }]\n *     }\n * }\n */\n\n\nfunction getLinkGroupIndex(linksOption, axis) {\n  var axisModel = axis.model;\n  var dim = axis.dim;\n\n  for (var i = 0; i < linksOption.length; i++) {\n    var linkOption = linksOption[i] || {};\n\n    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {\n      return i;\n    }\n  }\n}\n\nfunction checkPropInLink(linkPropValue, axisPropValue) {\n  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;\n}\n\nfunction fixValue(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n\n  if (!axisInfo) {\n    return;\n  }\n\n  var axisPointerModel = axisInfo.axisPointerModel;\n  var scale = axisInfo.axis.scale;\n  var option = axisPointerModel.option;\n  var status = axisPointerModel.get('status');\n  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.\n\n  if (value != null) {\n    value = scale.parse(value);\n  }\n\n  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value\n  // and status should be initialized.\n\n  if (status == null) {\n    option.status = useHandle ? 'show' : 'hide';\n  }\n\n  var extent = scale.getExtent().slice();\n  extent[0] > extent[1] && extent.reverse();\n\n  if ( // Pick a value on axis when initializing.\n  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n  // where we should re-pick a value to keep `handle` displaying normally.\n  || value > extent[1]) {\n    // Make handle displayed on the end of the axis when init, which looks better.\n    value = extent[1];\n  }\n\n  if (value < extent[0]) {\n    value = extent[0];\n  }\n\n  option.value = value;\n\n  if (useHandle) {\n    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n  }\n}\n\nfunction getAxisInfo(axisModel) {\n  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n}\n\nfunction getAxisPointerModel(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n  return axisInfo && axisInfo.axisPointerModel;\n}\n\nfunction isHandleTrigger(axisPointerModel) {\n  return !!axisPointerModel.get('handle.show');\n}\n/**\n * @param {module:echarts/model/Model} model\n * @return {string} unique key\n */\n\n\nfunction makeKey(model) {\n  return model.type + '||' + model.id;\n}\n\nexports.collect = collect;\nexports.fixValue = fixValue;\nexports.getAxisInfo = getAxisInfo;\nexports.getAxisPointerModel = getAxisPointerModel;\nexports.makeKey = makeKey;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/modelHelper.js\n// module id = 181\n// module chunks = 0 1 2 3 4 5","var _util = require(\"zrender/lib/core/util\");\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _number = require(\"../../util/number\");\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar _vector = require(\"zrender/lib/core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n    var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;\n\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];\n          symbol.attr({\n            rotation: point.rotate,\n            position: pos,\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticksCoords[i].tickValue,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {\n      itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickValue);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickValue,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: formattedLabel,\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always use formatted label as\n      // input. But in interval scale the formatted label is like '223,445', which\n      // maked user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = rawLabel;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/AxisBuilder.js\n// module id = 182\n// module chunks = 0 1 2 3 4 5 6","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar axisPointerModelHelper = require(\"../axisPointer/modelHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Base class of AxisView.\n */\nvar AxisView = echarts.extendComponentView({\n  type: 'axis',\n\n  /**\n   * @private\n   */\n  _axisPointer: null,\n\n  /**\n   * @protected\n   * @type {string}\n   */\n  axisPointerClass: null,\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    // FIXME\n    // This process should proformed after coordinate systems updated\n    // (axis scale updated), and should be performed each time update.\n    // So put it here temporarily, although it is not appropriate to\n    // put a model-writing procedure in `view`.\n    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n    AxisView.superApply(this, 'render', arguments);\n    updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n  },\n\n  /**\n   * Action handler.\n   * @public\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/model/Global} ecModel\n   * @param {module:echarts/ExtensionAPI} api\n   * @param {Object} payload\n   */\n  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n    updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    var axisPointer = this._axisPointer;\n    axisPointer && axisPointer.remove(api);\n    AxisView.superApply(this, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    disposeAxisPointer(this, api);\n    AxisView.superApply(this, 'dispose', arguments);\n  }\n});\n\nfunction updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n\n  if (!Clazz) {\n    return;\n  }\n\n  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);\n}\n\nfunction disposeAxisPointer(axisView, ecModel, api) {\n  var axisPointer = axisView._axisPointer;\n  axisPointer && axisPointer.dispose(ecModel, api);\n  axisView._axisPointer = null;\n}\n\nvar axisPointerClazz = [];\n\nAxisView.registerAxisPointerClass = function (type, clazz) {\n  axisPointerClazz[type] = clazz;\n};\n\nAxisView.getAxisPointerClass = function (type) {\n  return type && axisPointerClazz[type];\n};\n\nvar _default = AxisView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/AxisView.js\n// module id = 183\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisPointerModelHelper = require(\"./axisPointer/modelHelper\");\n\nvar axisTrigger = require(\"./axisPointer/axisTrigger\");\n\nrequire(\"./axisPointer/AxisPointerModel\");\n\nrequire(\"./axisPointer/AxisPointerView\");\n\nrequire(\"./axisPointer/CartesianAxisPointer\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// CartesianAxisPointer is not supposed to be required here. But consider\n// echarts.simple.js and online build tooltip, which only require gridSimple,\n// CartesianAxisPointer should be able to required somewhere.\necharts.registerPreprocessor(function (option) {\n  // Always has a global axisPointerModel for default setting.\n  if (option) {\n    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});\n    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link\n    // is not set, remain null/undefined, otherwise it will\n    // override existent link setting.\n\n    if (link && !zrUtil.isArray(link)) {\n      option.axisPointer.link = [link];\n    }\n  }\n}); // This process should proformed after coordinate systems created\n// and series data processed. So put it on statistic processing stage.\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n  // allAxesInfo should be updated when setOption performed.\n  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);\n}); // Broadcast to all views.\n\necharts.registerAction({\n  type: 'updateAxisPointer',\n  event: 'updateAxisPointer',\n  update: ':updateAxisPointer'\n}, axisTrigger);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer.js\n// module id = 184\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar AxisBuilder = require(\"../axis/AxisBuilder\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\n\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get('label.precision'),\n    formatter: axisPointerModel.get('label.formatter')\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get('axisLine.lineStyle.color');\n  }\n\n  elOption.label = {\n    shape: {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      r: labelModel.get('borderRadius')\n    },\n    position: position.slice(),\n    // TODO: rich\n    style: {\n      text: text,\n      textFont: font,\n      textFill: labelModel.getTextColor(),\n      textPosition: 'inside',\n      fill: bgColor,\n      stroke: labelModel.get('borderColor') || 'transparent',\n      lineWidth: labelModel.get('borderWidth') || 0,\n      shadowBlur: labelModel.get('shadowBlur'),\n      shadowColor: labelModel.get('shadowColor'),\n      shadowOffsetX: labelModel.get('shadowOffsetX'),\n      shadowOffsetY: labelModel.get('shadowOffsetY')\n    },\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\n\n\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  value = axis.scale.parse(value);\n  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which\n  // helps to debounce when when moving label.\n  value, {\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params = {\n      value: axisHelper.getAxisRawValue(axis, value),\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params);\n    }\n  }\n\n  return text;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\n\n\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\n\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\n\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}\n\nexports.buildElStyle = buildElStyle;\nexports.buildLabelElOption = buildLabelElOption;\nexports.getValueLabel = getValueLabel;\nexports.getTransformedPosition = getTransformedPosition;\nexports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;\nexports.makeLineShape = makeLineShape;\nexports.makeRectShape = makeRectShape;\nexports.makeSectorShape = makeSectorShape;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/viewHelper.js\n// module id = 185\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} {point: [x, y], el: ...} point Will not be null.\n */\nfunction _default(finder, ecModel) {\n  var point = [];\n  var seriesIndex = finder.seriesIndex;\n  var seriesModel;\n\n  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {\n    return {\n      point: []\n    };\n  }\n\n  var data = seriesModel.getData();\n  var dataIndex = modelUtil.queryDataIndex(data, finder);\n\n  if (dataIndex == null || dataIndex < 0 || zrUtil.isArray(dataIndex)) {\n    return {\n      point: []\n    };\n  }\n\n  var el = data.getItemGraphicEl(dataIndex);\n  var coordSys = seriesModel.coordinateSystem;\n\n  if (seriesModel.getTooltipPosition) {\n    point = seriesModel.getTooltipPosition(dataIndex) || [];\n  } else if (coordSys && coordSys.dataToPoint) {\n    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {\n      return data.mapDimension(dim);\n    }), dataIndex, true)) || [];\n  } else if (el) {\n    // Use graphic bounding rect\n    var rect = el.getBoundingRect().clone();\n    rect.applyTransform(el.transform);\n    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n\n  return {\n    point: point,\n    el: el\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js\n// module id = 186\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\nvar each = zrUtil.each;\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n * @param {Function} handler\n *      param: {string} currTrigger\n *      param: {Array.<number>} point\n */\n\nfunction register(key, api, handler) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  inner(zr).records || (inner(zr).records = {});\n  initGlobalListeners(zr, api);\n  var record = inner(zr).records[key] || (inner(zr).records[key] = {});\n  record.handler = handler;\n}\n\nfunction initGlobalListeners(zr, api) {\n  if (inner(zr).initialized) {\n    return;\n  }\n\n  inner(zr).initialized = true;\n  useHandler('click', zrUtil.curry(doEnter, 'click'));\n  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);\n\n  useHandler('globalout', onLeave);\n\n  function useHandler(eventType, cb) {\n    zr.on(eventType, function (e) {\n      var dis = makeDispatchAction(api);\n      each(inner(zr).records, function (record) {\n        record && cb(record, e, dis.dispatchAction);\n      });\n      dispatchTooltipFinally(dis.pendings, api);\n    });\n  }\n}\n\nfunction dispatchTooltipFinally(pendings, api) {\n  var showLen = pendings.showTip.length;\n  var hideLen = pendings.hideTip.length;\n  var actuallyPayload;\n\n  if (showLen) {\n    actuallyPayload = pendings.showTip[showLen - 1];\n  } else if (hideLen) {\n    actuallyPayload = pendings.hideTip[hideLen - 1];\n  }\n\n  if (actuallyPayload) {\n    actuallyPayload.dispatchAction = null;\n    api.dispatchAction(actuallyPayload);\n  }\n}\n\nfunction onLeave(record, e, dispatchAction) {\n  record.handler('leave', null, dispatchAction);\n}\n\nfunction doEnter(currTrigger, record, e, dispatchAction) {\n  record.handler(currTrigger, e, dispatchAction);\n}\n\nfunction makeDispatchAction(api) {\n  var pendings = {\n    showTip: [],\n    hideTip: []\n  }; // FIXME\n  // better approach?\n  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n  // So we have to add \"final stage\" to merge those dispatched actions.\n\n  var dispatchAction = function (payload) {\n    var pendingList = pendings[payload.type];\n\n    if (pendingList) {\n      pendingList.push(payload);\n    } else {\n      payload.dispatchAction = dispatchAction;\n      api.dispatchAction(payload);\n    }\n  };\n\n  return {\n    dispatchAction: dispatchAction,\n    pendings: pendings\n  };\n}\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction unregister(key, api) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  var record = (inner(zr).records || {})[key];\n\n  if (record) {\n    inner(zr).records[key] = null;\n  }\n}\n\nexports.register = register;\nexports.unregister = unregister;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/globalListener.js\n// module id = 187\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../util/graphic\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./axis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/gridSimple.js\n// module id = 188\n// module chunks = 0 1 2 3 4","var graphic = require(\"../../util/graphic\");\n\nvar BaseAxisPointer = require(\"./BaseAxisPointer\");\n\nvar viewHelper = require(\"./viewHelper\");\n\nvar cartesianAxisHelper = require(\"../../coord/cartesian/cartesianAxisHelper\");\n\nvar AxisView = require(\"../axis/AxisView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar CartesianAxisPointer = BaseAxisPointer.extend({\n  /**\n   * @override\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisPointerType = axisPointerModel.get('type');\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = viewHelper.buildElStyle(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n\n    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n  },\n\n  /**\n   * @override\n   */\n  getHandleTransform: function (value, axisModel, axisPointerModel) {\n    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n      labelInside: false\n    });\n    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n    return {\n      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n    };\n  },\n\n  /**\n   * @override\n   */\n  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisExtent = axis.getGlobalExtent(true);\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var dimIndex = axis.dim === 'x' ? 0 : 1;\n    var currPosition = transform.position;\n    currPosition[dimIndex] += delta[dimIndex];\n    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n    var cursorPoint = [cursorOtherValue, cursorOtherValue];\n    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.\n\n    var tooltipOptions = [{\n      verticalAlign: 'middle'\n    }, {\n      align: 'center'\n    }];\n    return {\n      position: currPosition,\n      rotation: transform.rotation,\n      cursorPoint: cursorPoint,\n      tooltipOption: tooltipOptions[dimIndex]\n    };\n  }\n});\n\nfunction getCartesian(grid, axis) {\n  var opt = {};\n  opt[axis.dim + 'AxisIndex'] = axis.index;\n  return grid.getCartesian(opt);\n}\n\nvar pointerShapeBuilder = {\n  line: function (axis, pixelValue, otherExtent, elStyle) {\n    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));\n    graphic.subPixelOptimizeLine({\n      shape: targetShape,\n      style: elStyle\n    });\n    return {\n      type: 'Line',\n      shape: targetShape\n    };\n  },\n  shadow: function (axis, pixelValue, otherExtent, elStyle) {\n    var bandWidth = Math.max(1, axis.getBandWidth());\n    var span = otherExtent[1] - otherExtent[0];\n    return {\n      type: 'Rect',\n      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))\n    };\n  }\n};\n\nfunction getAxisDimIndex(axis) {\n  return axis.dim === 'x' ? 0 : 1;\n}\n\nAxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\nvar _default = CartesianAxisPointer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js\n// module id = 189\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Can only be called after coordinate system creation stage.\n * (Can be called before coordinate system update stage).\n *\n * @param {Object} opt {labelInside}\n * @return {Object} {\n *  position, rotation, labelDirection, labelOffset,\n *  tickDirection, labelRotate, z2\n * }\n */\nfunction layout(gridModel, axisModel, opt) {\n  opt = opt || {};\n  var grid = gridModel.coordinateSystem;\n  var axis = axisModel.axis;\n  var layout = {};\n  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];\n  var rawAxisPosition = axis.position;\n  var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;\n  var axisDim = axis.dim;\n  var rect = grid.getRect();\n  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n  var idx = {\n    left: 0,\n    right: 1,\n    top: 0,\n    bottom: 1,\n    onZero: 2\n  };\n  var axisOffset = axisModel.get('offset') || 0;\n  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n  if (otherAxisOnZeroOf) {\n    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));\n    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n  } // Axis position\n\n\n  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation\n\n  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim\n\n  var dirMap = {\n    top: -1,\n    bottom: 1,\n    left: -1,\n    right: 1\n  };\n  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n  layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n  if (axisModel.get('axisTick.inside')) {\n    layout.tickDirection = -layout.tickDirection;\n  }\n\n  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n    layout.labelDirection = -layout.labelDirection;\n  } // Special label rotation\n\n\n  var labelRotate = axisModel.get('axisLabel.rotate');\n  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea\n\n  layout.z2 = 1;\n  return layout;\n}\n\nexports.layout = layout;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js\n// module id = 190\n// module chunks = 0 1 2 3 4 5","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    // For legend.\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      var keepAspect = seriesModel.get('symbolKeepAspect');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize,\n        symbolKeepAspect: keepAspect\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n          var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n\n          if (itemSymbolKeepAspect != null) {\n            data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/symbol.js\n// module id = 191\n// module chunks = 0 1 3 4 6","var createDimensions = require(\"../../data/helper/createDimensions\");\n\nvar List = require(\"../../data/List\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListSimply.js\n// module id = 192\n// module chunks = 0 1 2 5 6","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\nvar axisModelCreator = require(\"../axisModelCreator\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/AxisModel.js\n// module id = 193\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar clazzUtil = require(\"../../util/clazz\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar axisPointerModelHelper = require(\"./modelHelper\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar throttleUtil = require(\"../../util/throttle\");\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\nvar clone = zrUtil.clone;\nvar bind = zrUtil.bind;\n/**\n * Base axis pointer class in 2D.\n * Implemenents {module:echarts/component/axis/IAxisPointer}.\n */\n\nfunction BaseAxisPointer() {}\n\nBaseAxisPointer.prototype = {\n  /**\n   * @private\n   */\n  _group: null,\n\n  /**\n   * @private\n   */\n  _lastGraphicKey: null,\n\n  /**\n   * @private\n   */\n  _handle: null,\n\n  /**\n   * @private\n   */\n  _dragging: false,\n\n  /**\n   * @private\n   */\n  _lastValue: null,\n\n  /**\n   * @private\n   */\n  _lastStatus: null,\n\n  /**\n   * @private\n   */\n  _payloadInfo: null,\n\n  /**\n   * In px, arbitrary value. Do not set too small,\n   * no animation is ok for most cases.\n   * @protected\n   */\n  animationThreshold: 15,\n\n  /**\n   * @implement\n   */\n  render: function (axisModel, axisPointerModel, api, forceRender) {\n    var value = axisPointerModel.get('value');\n    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not\n    // be replaced when user calling setOption in not merge mode.\n\n    this._axisModel = axisModel;\n    this._axisPointerModel = axisPointerModel;\n    this._api = api; // Optimize: `render` will be called repeatly during mouse move.\n    // So it is power consuming if performing `render` each time,\n    // especially on mobile device.\n\n    if (!forceRender && this._lastValue === value && this._lastStatus === status) {\n      return;\n    }\n\n    this._lastValue = value;\n    this._lastStatus = status;\n    var group = this._group;\n    var handle = this._handle;\n\n    if (!status || status === 'hide') {\n      // Do not clear here, for animation better.\n      group && group.hide();\n      handle && handle.hide();\n      return;\n    }\n\n    group && group.show();\n    handle && handle.show(); // Otherwise status is 'show'\n\n    var elOption = {};\n    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.\n\n    var graphicKey = elOption.graphicKey;\n\n    if (graphicKey !== this._lastGraphicKey) {\n      this.clear(api);\n    }\n\n    this._lastGraphicKey = graphicKey;\n    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);\n\n    if (!group) {\n      group = this._group = new graphic.Group();\n      this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n      this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n      api.getZr().add(group);\n    } else {\n      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n    }\n\n    updateMandatoryProps(group, axisPointerModel, true);\n\n    this._renderHandle(value);\n  },\n\n  /**\n   * @implement\n   */\n  remove: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @implement\n   */\n  dispose: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @protected\n   */\n  determineAnimation: function (axisModel, axisPointerModel) {\n    var animation = axisPointerModel.get('animation');\n    var axis = axisModel.axis;\n    var isCategoryAxis = axis.type === 'category';\n    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.\n\n    if (!useSnap && !isCategoryAxis) {\n      return false;\n    }\n\n    if (animation === 'auto' || animation == null) {\n      var animationThreshold = this.animationThreshold;\n\n      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n        return true;\n      } // It is important to auto animation when snap used. Consider if there is\n      // a dataZoom, animation will be disabled when too many points exist, while\n      // it will be enabled for better visual effect when little points exist.\n\n\n      if (useSnap) {\n        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n        var axisExtent = axis.getExtent(); // Approximate band width\n\n        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n      }\n\n      return false;\n    }\n\n    return animation === true;\n  },\n\n  /**\n   * add {pointer, label, graphicKey} to elOption\n   * @protected\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.\n  },\n\n  /**\n   * @protected\n   */\n  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n    var pointerOption = elOption.pointer;\n\n    if (pointerOption) {\n      var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));\n      group.add(pointerEl);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n    if (elOption.label) {\n      var labelEl = inner(group).labelEl = new graphic.Rect(clone(elOption.label));\n      group.add(labelEl);\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updatePointerEl: function (group, elOption, updateProps) {\n    var pointerEl = inner(group).pointerEl;\n\n    if (pointerEl) {\n      pointerEl.setStyle(elOption.pointer.style);\n      updateProps(pointerEl, {\n        shape: elOption.pointer.shape\n      });\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n    var labelEl = inner(group).labelEl;\n\n    if (labelEl) {\n      labelEl.setStyle(elOption.label.style);\n      updateProps(labelEl, {\n        // Consider text length change in vertical axis, animation should\n        // be used on shape, otherwise the effect will be weird.\n        shape: elOption.label.shape,\n        position: elOption.label.position\n      });\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _renderHandle: function (value) {\n    if (this._dragging || !this.updateHandleTransform) {\n      return;\n    }\n\n    var axisPointerModel = this._axisPointerModel;\n\n    var zr = this._api.getZr();\n\n    var handle = this._handle;\n    var handleModel = axisPointerModel.getModel('handle');\n    var status = axisPointerModel.get('status');\n\n    if (!handleModel.get('show') || !status || status === 'hide') {\n      handle && zr.remove(handle);\n      this._handle = null;\n      return;\n    }\n\n    var isInit;\n\n    if (!this._handle) {\n      isInit = true;\n      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {\n        cursor: 'move',\n        draggable: true,\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n        drift: bind(this._onHandleDragMove, this),\n        ondragend: bind(this._onHandleDragEnd, this)\n      });\n      zr.add(handle);\n    }\n\n    updateMandatoryProps(handle, axisPointerModel, false); // update style\n\n    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position\n\n    var handleSize = handleModel.get('size');\n\n    if (!zrUtil.isArray(handleSize)) {\n      handleSize = [handleSize, handleSize];\n    }\n\n    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');\n\n    this._moveHandleToValue(value, isInit);\n  },\n\n  /**\n   * @private\n   */\n  _moveHandleToValue: function (value, isInit) {\n    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragMove: function (dx, dy) {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    this._dragging = true; // Persistent for throttle.\n\n    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);\n    this._payloadInfo = trans;\n    handle.stopAnimation();\n    handle.attr(getHandleTransProps(trans));\n    inner(handle).lastProp = null;\n\n    this._doDispatchAxisPointer();\n  },\n\n  /**\n   * Throttled method.\n   * @private\n   */\n  _doDispatchAxisPointer: function () {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var payloadInfo = this._payloadInfo;\n    var axisModel = this._axisModel;\n\n    this._api.dispatchAction({\n      type: 'updateAxisPointer',\n      x: payloadInfo.cursorPoint[0],\n      y: payloadInfo.cursorPoint[1],\n      tooltipOption: payloadInfo.tooltipOption,\n      axesInfo: [{\n        axisDim: axisModel.axis.dim,\n        axisIndex: axisModel.componentIndex\n      }]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragEnd: function (moveAnimation) {\n    this._dragging = false;\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with\n    // axisPointer. So move handle to align the exact value position when\n    // drag ended.\n\n\n    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle\n    // button, and will be hidden after finger left handle button.\n\n\n    this._api.dispatchAction({\n      type: 'hideTip'\n    });\n  },\n\n  /**\n   * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {number} value\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0}\n   */\n  getHandleTransform: null,\n\n  /**\n   * * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {Object} transform {position, rotation}\n   * @param {Array.<number>} delta [dx, dy]\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n   */\n  updateHandleTransform: null,\n\n  /**\n   * @private\n   */\n  clear: function (api) {\n    this._lastValue = null;\n    this._lastStatus = null;\n    var zr = api.getZr();\n    var group = this._group;\n    var handle = this._handle;\n\n    if (zr && group) {\n      this._lastGraphicKey = null;\n      group && zr.remove(group);\n      handle && zr.remove(handle);\n      this._group = null;\n      this._handle = null;\n      this._payloadInfo = null;\n    }\n  },\n\n  /**\n   * @protected\n   */\n  doClear: function () {// Implemented by sub-class if necessary.\n  },\n\n  /**\n   * @protected\n   * @param {Array.<number>} xy\n   * @param {Array.<number>} wh\n   * @param {number} [xDimIndex=0] or 1\n   */\n  buildLabel: function (xy, wh, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n      x: xy[xDimIndex],\n      y: xy[1 - xDimIndex],\n      width: wh[xDimIndex],\n      height: wh[1 - xDimIndex]\n    };\n  }\n};\nBaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\nfunction updateProps(animationModel, moveAnimation, el, props) {\n  // Animation optimize.\n  if (!propsEqual(inner(el).lastProp, props)) {\n    inner(el).lastProp = props;\n    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));\n  }\n}\n\nfunction propsEqual(lastProps, newProps) {\n  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n    var equals = true;\n    zrUtil.each(newProps, function (item, key) {\n      equals = equals && propsEqual(lastProps[key], item);\n    });\n    return !!equals;\n  } else {\n    return lastProps === newProps;\n  }\n}\n\nfunction updateLabelShowHide(labelEl, axisPointerModel) {\n  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n}\n\nfunction getHandleTransProps(trans) {\n  return {\n    position: trans.position.slice(),\n    rotation: trans.rotation || 0\n  };\n}\n\nfunction updateMandatoryProps(group, axisPointerModel, silent) {\n  var z = axisPointerModel.get('z');\n  var zlevel = axisPointerModel.get('zlevel');\n  group && group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n      el.silent = silent;\n    }\n  });\n}\n\nclazzUtil.enableClassExtend(BaseAxisPointer);\nvar _default = BaseAxisPointer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js\n// module id = 194\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../echarts\");\n\nrequire(\"./axisPointer\");\n\nrequire(\"./tooltip/TooltipModel\");\n\nrequire(\"./tooltip/TooltipView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME Better way to pack data in graphic element\n\n/**\n * @action\n * @property {string} type\n * @property {number} seriesIndex\n * @property {number} dataIndex\n * @property {number} [x]\n * @property {number} [y]\n */\necharts.registerAction({\n  type: 'showTip',\n  event: 'showTip',\n  update: 'tooltip:manuallyShowTip'\n}, // noop\nfunction () {});\necharts.registerAction({\n  type: 'hideTip',\n  event: 'hideTip',\n  update: 'tooltip:manuallyHideTip'\n}, // noop\nfunction () {});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip.js\n// module id = 195\n// module chunks = 0 1 2 3 4 5","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\nvar each = _util.each;\nvar map = _util.map;\nvar indexOf = _util.indexOf;\nvar retrieve = _util.retrieve;\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar _axisHelper = require(\"../../coord/axisHelper\");\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar ifAxisCrossZero = _axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\nvar estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\nrequire(\"./GridModel\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxis ? [otherAxis] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxis;\n  var axisModel = axis.model;\n  var onZero = axisModel.get('axisLine.onZero');\n  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxis = otherAxes[onZeroAxisIndex];\n    }\n\n    return;\n  } // Find the first available other axis.\n\n\n  for (var idx in otherAxes) {\n    if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])) {\n      otherAxis = otherAxes[idx];\n      break;\n    }\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = estimateLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(data.mapDimension(axis.dim, true), function (dim) {\n      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension\n      // is [0.1, 0.5], the extent of the `stackResultDimension`\n      // is [7, 9], the final extent should not include [0.1, 0.5].\n      data, getStackedDimension(data, dim));\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Grid.js\n// module id = 196\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisDefault = require(\"./axisDefault\");\n\nvar ComponentModel = require(\"../model/Component\");\n\nvar _layout = require(\"../util/layout\");\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n\nvar OrdinalMeta = require(\"../data/OrdinalMeta\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      /**\n       * @readOnly\n       */\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n\n      /**\n       * @override\n       */\n      optionUpdated: function () {\n        var thisOption = this.option;\n\n        if (thisOption.type === 'category') {\n          this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);\n        }\n      },\n\n      /**\n       * Should not be called before all of 'getInitailData' finished.\n       * Because categories are collected during initializing data.\n       */\n      getCategories: function (rawData) {\n        var option = this.option; // FIXME\n        // warning if called before all of 'getInitailData' finished.\n\n        if (option.type === 'category') {\n          if (rawData) {\n            return option.data;\n          }\n\n          return this.__ordinalMeta.categories;\n        }\n      },\n      getOrdinalMeta: function () {\n        return this.__ordinalMeta;\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/axisModelCreator.js\n// module id = 197\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // By degree. By defualt auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // The arrow at both ends the the axis.\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  // Only usefull in the case like: category is\n  // ['2012-01-01', '2012-01-02', ...], where the input\n  // data has been ensured not duplicate and is large data.\n  // null means \"auto\":\n  // if axis.data provided, do not deduplication,\n  // else do deduplication.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For value axis, [GAP, GAP], where\n  // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)\n  boundaryGap: [0, 0],\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  // Min value of the axis. can be:\n  // + a number\n  // + 'dataMin': use the min value in data.\n  // + null/undefined: auto decide min value (consider pretty look and boundaryGap).\n  // min: null,\n  // Max value of the axis. can be:\n  // + a number\n  // + 'dataMax': use the max value in data.\n  // + null/undefined: auto decide max value (consider pretty look and boundaryGap).\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // Optional value can be:\n  // + `false`: always include value 0.\n  // + `true`: the extent do not consider value 0.\n  // scale: false,\n  // AxisTick and axisLabel and splitLine are caculated based on splitNumber.\n  splitNumber: 5 // Interval specifies the span of the ticks is mandatorily.\n  // interval: null\n  // Specify min interval when auto calculate tick interval.\n  // minInterval: null\n  // Specify max interval when auto calculate tick interval.\n  // maxInterval: null\n\n}, defaultOption);\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/axisDefault.js\n// module id = 198\n// module chunks = 0 1 2 3 4 6","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/Symbol\n */\n\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n/**\n * @public\n * @static\n * @param {module:echarts/data/List} data\n * @param {number} dataIndex\n * @return {Array.<number>} [width, height]\n */\n\nvar getSymbolSize = SymbolClz.getSymbolSize = function (data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n};\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');\n\n    this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var liftZ = data.getItemVisual(idx, 'liftZ');\n  var z2Origin = symbolPath.__z2Origin;\n\n  if (liftZ != null) {\n    if (z2Origin == null) {\n      symbolPath.__z2Origin = symbolPath.z2;\n      symbolPath.z2 += liftZ;\n    }\n  } else if (z2Origin != null) {\n    symbolPath.z2 = z2Origin;\n    symbolPath.__z2Origin = null;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/Symbol.js\n// module id = 199\n// module chunks = 0 1 3 4","var _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n      if (isDimensionStacked(data, dims[0]\n      /*, dims[1]*/\n      )) {\n        dims[0] = stackResultDim;\n      }\n\n      if (isDimensionStacked(data, dims[1]\n      /*, dims[0]*/\n      )) {\n        dims[1] = stackResultDim;\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i);\n            var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/layout/points.js\n// module id = 200\n// module chunks = 0 1 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\n\nvar modelHelper = require(\"./modelHelper\");\n\nvar findPointFromSeries = require(\"./findPointFromSeries\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar curry = zrUtil.curry;\nvar inner = makeInner();\n/**\n * Basic logic: check all axis, if they do not demand show/highlight,\n * then hide/downplay them.\n *\n * @param {Object} coordSysAxesInfo\n * @param {Object} payload\n * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n * @param {Object} [payload.dataIndex] finder, restrict target axes.\n * @param {Object} [payload.axesInfo] finder, restrict target axes.\n *        [{\n *          axisDim: 'x'|'y'|'angle'|...,\n *          axisIndex: ...,\n *          value: ...\n *        }, ...]\n * @param {Function} [payload.dispatchAction]\n * @param {Object} [payload.tooltipOption]\n * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n *        which can be specified in dispatchAction\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n * @return {Object} content of event obj for echarts.connect.\n */\n\nfunction _default(payload, ecModel, api) {\n  var currTrigger = payload.currTrigger;\n  var point = [payload.x, payload.y];\n  var finder = payload;\n  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending\n  // See #6121. But we are not able to reproduce it yet.\n\n  if (!coordSysAxesInfo) {\n    return;\n  }\n\n  if (illegalPoint(point)) {\n    // Used in the default behavior of `connection`: use the sample seriesIndex\n    // and dataIndex. And also used in the tooltipView trigger.\n    point = findPointFromSeries({\n      seriesIndex: finder.seriesIndex,\n      // Do not use dataIndexInside from other ec instance.\n      // FIXME: auto detect it?\n      dataIndex: finder.dataIndex\n    }, ecModel).point;\n  }\n\n  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n  // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n  // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n  // and dataIndex.\n\n  var inputAxesInfo = finder.axesInfo;\n  var axesInfo = coordSysAxesInfo.axesInfo;\n  var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n  var outputFinder = {};\n  var showValueMap = {};\n  var dataByCoordSys = {\n    list: [],\n    map: {}\n  };\n  var updaters = {\n    showPointer: curry(showPointer, showValueMap),\n    showTooltip: curry(showTooltip, dataByCoordSys)\n  }; // Process for triggered axes.\n\n  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n    // If a point given, it must be contained by the coordinate system.\n    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n      var axis = axisInfo.axis;\n      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.\n\n      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n        var val = inputAxisInfo && inputAxisInfo.value;\n\n        if (val == null && !isIllegalPoint) {\n          val = axis.pointToData(point);\n        }\n\n        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n      }\n    });\n  }); // Process for linked axes.\n\n  var linkTriggers = {};\n  each(axesInfo, function (tarAxisInfo, tarKey) {\n    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.\n\n    if (linkGroup && !showValueMap[tarKey]) {\n      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.\n\n        if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n          var val = srcValItem.value;\n          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));\n          linkTriggers[tarAxisInfo.key] = val;\n        }\n      });\n    }\n  });\n  each(linkTriggers, function (val, tarKey) {\n    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n  });\n  updateModelActually(showValueMap, axesInfo, outputFinder);\n  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n  dispatchHighDownActually(axesInfo, dispatchAction, api);\n  return outputFinder;\n}\n\nfunction processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n  var axis = axisInfo.axis;\n\n  if (axis.scale.isBlank() || !axis.containData(newValue)) {\n    return;\n  }\n\n  if (!axisInfo.involveSeries) {\n    updaters.showPointer(axisInfo, newValue);\n    return;\n  } // Heavy calculation. So put it after axis.containData checking.\n\n\n  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n  var payloadBatch = payloadInfo.payloadBatch;\n  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.\n  // By defualt use the first involved series data as a sample to connect.\n\n  if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n    zrUtil.extend(outputFinder, payloadBatch[0]);\n  } // If no linkSource input, this process is for collecting link\n  // target, where snap should not be accepted.\n\n\n  if (!dontSnap && axisInfo.snap) {\n    if (axis.containData(snapToValue) && snapToValue != null) {\n      newValue = snapToValue;\n    }\n  }\n\n  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be\n  // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n\n  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n}\n\nfunction buildPayloadsBySeries(value, axisInfo) {\n  var axis = axisInfo.axis;\n  var dim = axis.dim;\n  var snapToValue = value;\n  var payloadBatch = [];\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n  each(axisInfo.seriesModels, function (series, idx) {\n    var dataDim = series.getData().mapDimension(dim, true);\n    var seriesNestestValue;\n    var dataIndices;\n\n    if (series.getAxisTooltipData) {\n      var result = series.getAxisTooltipData(dataDim, value, axis);\n      dataIndices = result.dataIndices;\n      seriesNestestValue = result.nestestValue;\n    } else {\n      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex\n      // when data length is not same.\n      // false,\n      axis.type === 'category' ? 0.5 : null);\n\n      if (!dataIndices.length) {\n        return;\n      }\n\n      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n    }\n\n    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n      return;\n    }\n\n    var diff = value - seriesNestestValue;\n    var dist = Math.abs(diff); // Consider category case\n\n    if (dist <= minDist) {\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        snapToValue = seriesNestestValue;\n        payloadBatch.length = 0;\n      }\n\n      each(dataIndices, function (dataIndex) {\n        payloadBatch.push({\n          seriesIndex: series.seriesIndex,\n          dataIndexInside: dataIndex,\n          dataIndex: series.getData().getRawIndex(dataIndex)\n        });\n      });\n    }\n  });\n  return {\n    payloadBatch: payloadBatch,\n    snapToValue: snapToValue\n  };\n}\n\nfunction showPointer(showValueMap, axisInfo, value, payloadBatch) {\n  showValueMap[axisInfo.key] = {\n    value: value,\n    payloadBatch: payloadBatch\n  };\n}\n\nfunction showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n  var payloadBatch = payloadInfo.payloadBatch;\n  var axis = axisInfo.axis;\n  var axisModel = axis.model;\n  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,\n  // whose length will be used to judge whether dispatch action.\n\n  if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n    return;\n  }\n\n  var coordSysModel = axisInfo.coordSys.model;\n  var coordSysKey = modelHelper.makeKey(coordSysModel);\n  var coordSysItem = dataByCoordSys.map[coordSysKey];\n\n  if (!coordSysItem) {\n    coordSysItem = dataByCoordSys.map[coordSysKey] = {\n      coordSysId: coordSysModel.id,\n      coordSysIndex: coordSysModel.componentIndex,\n      coordSysType: coordSysModel.type,\n      coordSysMainType: coordSysModel.mainType,\n      dataByAxis: []\n    };\n    dataByCoordSys.list.push(coordSysItem);\n  }\n\n  coordSysItem.dataByAxis.push({\n    axisDim: axis.dim,\n    axisIndex: axisModel.componentIndex,\n    axisType: axisModel.type,\n    axisId: axisModel.id,\n    value: value,\n    // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n    // depends that all models have been updated. So it should not be performed\n    // here. Considering axisPointerModel used here is volatile, which is hard\n    // to be retrieve in TooltipView, we prepare parameters here.\n    valueLabelOpt: {\n      precision: axisPointerModel.get('label.precision'),\n      formatter: axisPointerModel.get('label.formatter')\n    },\n    seriesDataIndices: payloadBatch.slice()\n  });\n}\n\nfunction updateModelActually(showValueMap, axesInfo, outputFinder) {\n  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    var valItem = showValueMap[key];\n\n    if (valItem) {\n      !axisInfo.useHandle && (option.status = 'show');\n      option.value = valItem.value; // For label formatter param and highlight.\n\n      option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n    } // When always show (e.g., handle used), remain\n    // original value and status.\n    else {\n        // If hide, value still need to be set, consider\n        // click legend to toggle axis blank.\n        !axisInfo.useHandle && (option.status = 'hide');\n      } // If status is 'hide', should be no info in payload.\n\n\n    option.status === 'show' && outputAxesInfo.push({\n      axisDim: axisInfo.axis.dim,\n      axisIndex: axisInfo.axis.model.componentIndex,\n      value: option.value\n    });\n  });\n}\n\nfunction dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n  // Basic logic: If no showTip required, hideTip will be dispatched.\n  if (illegalPoint(point) || !dataByCoordSys.list.length) {\n    dispatchAction({\n      type: 'hideTip'\n    });\n    return;\n  } // In most case only one axis (or event one series is used). It is\n  // convinient to fetch payload.seriesIndex and payload.dataIndex\n  // dirtectly. So put the first seriesIndex and dataIndex of the first\n  // axis on the payload.\n\n\n  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n  dispatchAction({\n    type: 'showTip',\n    escapeConnect: true,\n    x: point[0],\n    y: point[1],\n    tooltipOption: payload.tooltipOption,\n    position: payload.position,\n    dataIndexInside: sampleItem.dataIndexInside,\n    dataIndex: sampleItem.dataIndex,\n    seriesIndex: sampleItem.seriesIndex,\n    dataByCoordSys: dataByCoordSys.list\n  });\n}\n\nfunction dispatchHighDownActually(axesInfo, dispatchAction, api) {\n  // FIXME\n  // highlight status modification shoule be a stage of main process?\n  // (Consider confilct (e.g., legend and axisPointer) and setOption)\n  var zr = api.getZr();\n  var highDownKey = 'axisPointerLastHighlights';\n  var lastHighlights = inner(zr)[highDownKey] || {};\n  var newHighlights = inner(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.\n  // Build hash map and remove duplicate incidentally.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n      newHighlights[key] = batchItem;\n    });\n  }); // Diff.\n\n  var toHighlight = [];\n  var toDownplay = [];\n  zrUtil.each(lastHighlights, function (batchItem, key) {\n    !newHighlights[key] && toDownplay.push(batchItem);\n  });\n  zrUtil.each(newHighlights, function (batchItem, key) {\n    !lastHighlights[key] && toHighlight.push(batchItem);\n  });\n  toDownplay.length && api.dispatchAction({\n    type: 'downplay',\n    escapeConnect: true,\n    batch: toDownplay\n  });\n  toHighlight.length && api.dispatchAction({\n    type: 'highlight',\n    escapeConnect: true,\n    batch: toHighlight\n  });\n}\n\nfunction findInputAxisInfo(inputAxesInfo, axisInfo) {\n  for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n    var inputAxisInfo = inputAxesInfo[i];\n\n    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {\n      return inputAxisInfo;\n    }\n  }\n}\n\nfunction makeMapperParam(axisInfo) {\n  var axisModel = axisInfo.axis.model;\n  var item = {};\n  var dim = item.axisDim = axisInfo.axis.dim;\n  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n  item.axisName = item[dim + 'AxisName'] = axisModel.name;\n  item.axisId = item[dim + 'AxisId'] = axisModel.id;\n  return item;\n}\n\nfunction illegalPoint(point) {\n  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/axisTrigger.js\n// module id = 201\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../../echarts\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisPointerModel = echarts.extendComponentModel({\n  type: 'axisPointer',\n  coordSysAxesInfo: null,\n  defaultOption: {\n    // 'auto' means that show when triggered by tooltip or handle.\n    show: 'auto',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: null,\n    // set default in AxisPonterView.js\n    zlevel: 0,\n    z: 50,\n    type: 'line',\n    // axispointer triggered by tootip determine snap automatically,\n    // see `modelHelper`.\n    snap: false,\n    triggerTooltip: true,\n    value: null,\n    status: null,\n    // Init value depends on whether handle is used.\n    // [group0, group1, ...]\n    // Each group can be: {\n    //      mapper: function () {},\n    //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n    //      xAxisId: ...,\n    //      yAxisName: ...,\n    //      angleAxisIndex: ...\n    // }\n    // mapper: can be ignored.\n    //      input: {axisInfo, value}\n    //      output: {axisInfo, value}\n    link: [],\n    // Do not set 'auto' here, otherwise global animation: false\n    // will not effect at this axispointer.\n    animation: null,\n    animationDurationUpdate: 200,\n    lineStyle: {\n      color: '#aaa',\n      width: 1,\n      type: 'solid'\n    },\n    shadowStyle: {\n      color: 'rgba(150,150,150,0.3)'\n    },\n    label: {\n      show: true,\n      formatter: null,\n      // string | Function\n      precision: 'auto',\n      // Or a number like 0, 1, 2 ...\n      margin: 3,\n      color: '#fff',\n      padding: [5, 7, 5, 7],\n      backgroundColor: 'auto',\n      // default: axis line color\n      borderColor: null,\n      borderWidth: 0,\n      shadowBlur: 3,\n      shadowColor: '#aaa' // Considering applicability, common style should\n      // better not have shadowOffset.\n      // shadowOffsetX: 0,\n      // shadowOffsetY: 2\n\n    },\n    handle: {\n      show: false,\n      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',\n      // jshint ignore:line\n      size: 45,\n      // handle margin is from symbol center to axis, which is stable when circular move.\n      margin: 50,\n      // color: '#1b8bbd'\n      // color: '#2f4554'\n      color: '#333',\n      shadowBlur: 3,\n      shadowColor: '#aaa',\n      shadowOffsetX: 0,\n      shadowOffsetY: 2,\n      // For mobile performance\n      throttle: 40\n    }\n  }\n});\nvar _default = AxisPointerModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js\n// module id = 202\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../../echarts\");\n\nvar globalListener = require(\"./globalListener\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisPointerView = echarts.extendComponentView({\n  type: 'axisPointer',\n  render: function (globalAxisPointerModel, ecModel, api) {\n    var globalTooltipModel = ecModel.getComponent('tooltip');\n    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable\n    // AxisPointerView to be independent to Tooltip.\n\n    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {\n        dispatchAction({\n          type: 'updateAxisPointer',\n          currTrigger: currTrigger,\n          x: e && e.offsetX,\n          y: e && e.offsetY\n        });\n      }\n    });\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    globalListener.unregister(api.getZr(), 'axisPointer');\n    AxisPointerView.superApply(this._model, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    globalListener.unregister('axisPointer', api);\n    AxisPointerView.superApply(this._model, 'dispose', arguments);\n  }\n});\nvar _default = AxisPointerView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js\n// module id = 203\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../../echarts\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = echarts.extendComponentModel({\n  type: 'tooltip',\n  dependencies: ['axisPointer'],\n  defaultOption: {\n    zlevel: 0,\n    z: 8,\n    show: true,\n    // tooltip主体内容\n    showContent: true,\n    // 'trigger' only works on coordinate system.\n    // 'item' | 'axis' | 'none'\n    trigger: 'item',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: 'mousemove|click',\n    alwaysShowContent: false,\n    displayMode: 'single',\n    // 'single' | 'multipleByCoordSys'\n    // 位置 {Array} | {Function}\n    // position: null\n    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n    // align: null,\n    // verticalAlign: null,\n    // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\n    confine: false,\n    // 内容格式器：{string}（Template） ¦ {Function}\n    // formatter: null\n    showDelay: 0,\n    // 隐藏延迟，单位ms\n    hideDelay: 100,\n    // 动画变换时间，单位s\n    transitionDuration: 0.4,\n    enterable: false,\n    // 提示背景颜色，默认为透明度为0.7的黑色\n    backgroundColor: 'rgba(50,50,50,0.7)',\n    // 提示边框颜色\n    borderColor: '#333',\n    // 提示边框圆角，单位px，默认为4\n    borderRadius: 4,\n    // 提示边框线宽，单位px，默认为0（无边框）\n    borderWidth: 0,\n    // 提示内边距，单位px，默认各方向内边距为5，\n    // 接受数组分别设定上右下左边距，同css\n    padding: 5,\n    // Extra css text\n    extraCssText: '',\n    // 坐标轴指示器，坐标轴触发有效\n    axisPointer: {\n      // 默认为直线\n      // 可选为：'line' | 'shadow' | 'cross'\n      type: 'line',\n      // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n      // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n      // 默认 'auto'，会选择类型为 category 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n      // 极坐标系会默认选择 angle 轴\n      axis: 'auto',\n      animation: 'auto',\n      animationDurationUpdate: 200,\n      animationEasingUpdate: 'exponentialOut',\n      crossStyle: {\n        color: '#999',\n        width: 1,\n        type: 'dashed',\n        // TODO formatter\n        textStyle: {} // lineStyle and shadowStyle should not be specified here,\n        // otherwise it will always override those styles on option.axisPointer.\n\n      }\n    },\n    textStyle: {\n      color: '#fff',\n      fontSize: 14\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 204\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar TooltipContent = require(\"./TooltipContent\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar findPointFromSeries = require(\"../axisPointer/findPointFromSeries\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar Model = require(\"../../model/Model\");\n\nvar globalListener = require(\"../axisPointer/globalListener\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar axisPointerViewHelper = require(\"../axisPointer/viewHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar bind = zrUtil.bind;\nvar each = zrUtil.each;\nvar parsePercent = numberUtil.parsePercent;\nvar proxyRect = new graphic.Rect({\n  shape: {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  }\n});\n\nvar _default = echarts.extendComponentView({\n  type: 'tooltip',\n  init: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    var tooltipContent = new TooltipContent(api.getDom(), api);\n    this._tooltipContent = tooltipContent;\n  },\n  render: function (tooltipModel, ecModel, api) {\n    if (env.node || env.wxa) {\n      return;\n    } // Reset\n\n\n    this.group.removeAll();\n    /**\n     * @private\n     * @type {module:echarts/component/tooltip/TooltipModel}\n     */\n\n    this._tooltipModel = tooltipModel;\n    /**\n     * @private\n     * @type {module:echarts/model/Global}\n     */\n\n    this._ecModel = ecModel;\n    /**\n     * @private\n     * @type {module:echarts/ExtensionAPI}\n     */\n\n    this._api = api;\n    /**\n     * Should be cleaned when render.\n     * @private\n     * @type {Array.<Array.<Object>>}\n     */\n\n    this._lastDataByCoordSys = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n    var tooltipContent = this._tooltipContent;\n    tooltipContent.update();\n    tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n    this._initGlobalListener();\n\n    this._keepShow();\n  },\n  _initGlobalListener: function () {\n    var tooltipModel = this._tooltipModel;\n    var triggerOn = tooltipModel.get('triggerOn');\n    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none') {\n        if (triggerOn.indexOf(currTrigger) >= 0) {\n          this._tryShow(e, dispatchAction);\n        } else if (currTrigger === 'leave') {\n          this._hide(dispatchAction);\n        }\n      }\n    }, this));\n  },\n  _keepShow: function () {\n    var tooltipModel = this._tooltipModel;\n    var ecModel = this._ecModel;\n    var api = this._api; // Try to keep the tooltip show when refreshing\n\n    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,\n    // self.manuallyShowTip({x, y}) might cause tooltip hide,\n    // which is not expected.\n    && tooltipModel.get('triggerOn') !== 'none') {\n      var self = this;\n      clearTimeout(this._refreshUpdateTimeout);\n      this._refreshUpdateTimeout = setTimeout(function () {\n        // Show tip next tick after other charts are rendered\n        // In case highlight action has wrong result\n        // FIXME\n        self.manuallyShowTip(tooltipModel, ecModel, api, {\n          x: self._lastX,\n          y: self._lastY\n        });\n      });\n    }\n  },\n\n  /**\n   * Show tip manually by\n   * dispatchAction({\n   *     type: 'showTip',\n   *     x: 10,\n   *     y: 10\n   * });\n   * Or\n   * dispatchAction({\n   *      type: 'showTip',\n   *      seriesIndex: 0,\n   *      dataIndex or dataIndexInside or name\n   * });\n   *\n   *  TODO Batch\n   */\n  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n    if (payload.from === this.uid || env.node) {\n      return;\n    }\n\n    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket\n\n    this._ticket = ''; // When triggered from axisPointer.\n\n    var dataByCoordSys = payload.dataByCoordSys;\n\n    if (payload.tooltip && payload.x != null && payload.y != null) {\n      var el = proxyRect;\n      el.position = [payload.x, payload.y];\n      el.update();\n      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        target: el\n      }, dispatchAction);\n    } else if (dataByCoordSys) {\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        event: {},\n        dataByCoordSys: payload.dataByCoordSys,\n        tooltipOption: payload.tooltipOption\n      }, dispatchAction);\n    } else if (payload.seriesIndex != null) {\n      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n        return;\n      }\n\n      var pointInfo = findPointFromSeries(payload, ecModel);\n      var cx = pointInfo.point[0];\n      var cy = pointInfo.point[1];\n\n      if (cx != null && cy != null) {\n        this._tryShow({\n          offsetX: cx,\n          offsetY: cy,\n          position: payload.position,\n          target: pointInfo.el,\n          event: {}\n        }, dispatchAction);\n      }\n    } else if (payload.x != null && payload.y != null) {\n      // FIXME\n      // should wrap dispatchAction like `axisPointer/globalListener` ?\n      api.dispatchAction({\n        type: 'updateAxisPointer',\n        x: payload.x,\n        y: payload.y\n      });\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        target: api.getZr().findHover(payload.x, payload.y).target,\n        event: {}\n      }, dispatchAction);\n    }\n  },\n  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n    var tooltipContent = this._tooltipContent;\n\n    if (!this._alwaysShowContent && this._tooltipModel) {\n      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n    }\n\n    this._lastX = this._lastY = null;\n\n    if (payload.from !== this.uid) {\n      this._hide(makeDispatchAction(payload, api));\n    }\n  },\n  // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n  // and tooltip.\n  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n    var seriesIndex = payload.seriesIndex;\n    var dataIndex = payload.dataIndex;\n    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n      return;\n    }\n\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n    if (!seriesModel) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);\n\n    if (tooltipModel.get('trigger') !== 'axis') {\n      return;\n    }\n\n    api.dispatchAction({\n      type: 'updateAxisPointer',\n      seriesIndex: seriesIndex,\n      dataIndex: dataIndex,\n      position: payload.position\n    });\n    return true;\n  },\n  _tryShow: function (e, dispatchAction) {\n    var el = e.target;\n    var tooltipModel = this._tooltipModel;\n\n    if (!tooltipModel) {\n      return;\n    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\n\n    this._lastX = e.offsetX;\n    this._lastY = e.offsetY;\n    var dataByCoordSys = e.dataByCoordSys;\n\n    if (dataByCoordSys && dataByCoordSys.length) {\n      this._showAxisTooltip(dataByCoordSys, e);\n    } // Always show item tooltip if mouse is on the element with dataIndex\n    else if (el && el.dataIndex != null) {\n        this._lastDataByCoordSys = null;\n\n        this._showSeriesItemTooltip(e, el, dispatchAction);\n      } // Tooltip provided directly. Like legend.\n      else if (el && el.tooltip) {\n          this._lastDataByCoordSys = null;\n\n          this._showComponentItemTooltip(e, el, dispatchAction);\n        } else {\n          this._lastDataByCoordSys = null;\n\n          this._hide(dispatchAction);\n        }\n  },\n  _showOrMove: function (tooltipModel, cb) {\n    // showDelay is used in this case: tooltip.enterable is set\n    // as true. User intent to move mouse into tooltip and click\n    // something. `showDelay` makes it easyer to enter the content\n    // but tooltip do not move immediately.\n    var delay = tooltipModel.get('showDelay');\n    cb = zrUtil.bind(cb, this);\n    clearTimeout(this._showTimout);\n    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();\n  },\n  _showAxisTooltip: function (dataByCoordSys, e) {\n    var ecModel = this._ecModel;\n    var globalTooltipModel = this._tooltipModel;\n    var point = [e.offsetX, e.offsetY];\n    var singleDefaultHTML = [];\n    var singleParamsList = [];\n    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);\n    each(dataByCoordSys, function (itemCoordSys) {\n      // var coordParamList = [];\n      // var coordDefaultHTML = [];\n      // var coordTooltipModel = buildTooltipModel([\n      //     e.tooltipOption,\n      //     itemCoordSys.tooltipOption,\n      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n      //     globalTooltipModel\n      // ]);\n      // var displayMode = coordTooltipModel.get('displayMode');\n      // var paramsList = displayMode === 'single' ? singleParamsList : [];\n      each(itemCoordSys.dataByAxis, function (item) {\n        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n        var axisValue = item.value;\n        var seriesDefaultHTML = [];\n\n        if (!axisModel || axisValue == null) {\n          return;\n        }\n\n        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);\n        zrUtil.each(item.seriesDataIndices, function (idxItem) {\n          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n          var dataIndex = idxItem.dataIndexInside;\n          var dataParams = series && series.getDataParams(dataIndex);\n          dataParams.axisDim = item.axisDim;\n          dataParams.axisIndex = item.axisIndex;\n          dataParams.axisType = item.axisType;\n          dataParams.axisId = item.axisId;\n          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n          dataParams.axisValueLabel = valueLabel;\n\n          if (dataParams) {\n            singleParamsList.push(dataParams);\n            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n          }\n        }); // Default tooltip content\n        // FIXME\n        // (1) shold be the first data which has name?\n        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\n        var firstLine = valueLabel;\n        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));\n      });\n    }, this); // In most case, the second axis is shown upper than the first one.\n\n    singleDefaultHTML.reverse();\n    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n    var positionExpr = e.position;\n\n    this._showOrMove(singleTooltipModel, function () {\n      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);\n      } else {\n        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);\n      }\n    }); // Do not trigger events here, because this branch only be entered\n    // from dispatchAction.\n\n  },\n  _showSeriesItemTooltip: function (e, el, dispatchAction) {\n    var ecModel = this._ecModel; // Use dataModel in element if possible\n    // Used when mouseover on a element like markPoint or edge\n    // In which case, the data is not main data in series.\n\n    var seriesIndex = el.seriesIndex;\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.\n\n    var dataModel = el.dataModel || seriesModel;\n    var dataIndex = el.dataIndex;\n    var dataType = el.dataType;\n    var data = dataModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);\n    var tooltipTrigger = tooltipModel.get('trigger');\n\n    if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n      return;\n    }\n\n    var params = dataModel.getDataParams(dataIndex, dataType);\n    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n    this._showOrMove(tooltipModel, function () {\n      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);\n    }); // FIXME\n    // duplicated showtip if manuallyShowTip is called from dispatchAction.\n\n\n    dispatchAction({\n      type: 'showTip',\n      dataIndexInside: dataIndex,\n      dataIndex: data.getRawIndex(dataIndex),\n      seriesIndex: seriesIndex,\n      from: this.uid\n    });\n  },\n  _showComponentItemTooltip: function (e, el, dispatchAction) {\n    var tooltipOpt = el.tooltip;\n\n    if (typeof tooltipOpt === 'string') {\n      var content = tooltipOpt;\n      tooltipOpt = {\n        content: content,\n        // Fixed formatter\n        formatter: content\n      };\n    }\n\n    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n    var defaultHtml = subTooltipModel.get('content');\n    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`\n    // only works on cooridinate system. In fact, we have not found case\n    // that requires setting `trigger` nothing on component yet.\n\n    this._showOrMove(subTooltipModel, function () {\n      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);\n    }); // If not dispatch showTip, tip may be hide triggered by axis.\n\n\n    dispatchAction({\n      type: 'showTip',\n      from: this.uid\n    });\n  },\n  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\n    // Reset ticket\n    this._ticket = '';\n\n    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n      return;\n    }\n\n    var tooltipContent = this._tooltipContent;\n    var formatter = tooltipModel.get('formatter');\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var html = defaultHtml;\n\n    if (formatter && typeof formatter === 'string') {\n      html = formatUtil.formatTpl(formatter, params, true);\n    } else if (typeof formatter === 'function') {\n      var callback = bind(function (cbTicket, html) {\n        if (cbTicket === this._ticket) {\n          tooltipContent.setContent(html);\n\n          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n        }\n      }, this);\n      this._ticket = asyncTicket;\n      html = formatter(params, asyncTicket, callback);\n    }\n\n    tooltipContent.setContent(html);\n    tooltipContent.show(tooltipModel);\n\n    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n  },\n\n  /**\n   * @param  {string|Function|Array.<number>|Object} positionExpr\n   * @param  {number} x Mouse x\n   * @param  {number} y Mouse y\n   * @param  {boolean} confine Whether confine tooltip content in view rect.\n   * @param  {Object|<Array.<Object>} params\n   * @param  {module:zrender/Element} el target element\n   * @param  {module:echarts/ExtensionAPI} api\n   * @return {Array.<number>}\n   */\n  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n    var viewWidth = this._api.getWidth();\n\n    var viewHeight = this._api.getHeight();\n\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var contentSize = content.getSize();\n    var align = tooltipModel.get('align');\n    var vAlign = tooltipModel.get('verticalAlign');\n    var rect = el && el.getBoundingRect().clone();\n    el && rect.applyTransform(el.transform);\n\n    if (typeof positionExpr === 'function') {\n      // Callback of position can be an array or a string specify the position\n      positionExpr = positionExpr([x, y], params, content.el, rect, {\n        viewSize: [viewWidth, viewHeight],\n        contentSize: contentSize.slice()\n      });\n    }\n\n    if (zrUtil.isArray(positionExpr)) {\n      x = parsePercent(positionExpr[0], viewWidth);\n      y = parsePercent(positionExpr[1], viewHeight);\n    } else if (zrUtil.isObject(positionExpr)) {\n      positionExpr.width = contentSize[0];\n      positionExpr.height = contentSize[1];\n      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {\n        width: viewWidth,\n        height: viewHeight\n      });\n      x = layoutRect.x;\n      y = layoutRect.y;\n      align = null; // When positionExpr is left/top/right/bottom,\n      // align and verticalAlign will not work.\n\n      vAlign = null;\n    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n    else if (typeof positionExpr === 'string' && el) {\n        var pos = calcTooltipPosition(positionExpr, rect, contentSize);\n        x = pos[0];\n        y = pos[1];\n      } else {\n        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);\n        x = pos[0];\n        y = pos[1];\n      }\n\n    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n    if (tooltipModel.get('confine')) {\n      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);\n      x = pos[0];\n      y = pos[1];\n    }\n\n    content.moveTo(x, y);\n  },\n  // FIXME\n  // Should we remove this but leave this to user?\n  _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n    var lastCoordSys = this._lastDataByCoordSys;\n    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;\n    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n        var thisItem = thisDataByAxis[indexAxis] || {};\n        var lastIndices = lastItem.seriesDataIndices || [];\n        var newIndices = thisItem.seriesDataIndices || [];\n        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;\n        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n          var newIdxItem = newIndices[j];\n          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n        });\n      });\n    });\n    this._lastDataByCoordSys = dataByCoordSys;\n    return !!contentNotChanged;\n  },\n  _hide: function (dispatchAction) {\n    // Do not directly hideLater here, because this behavior may be prevented\n    // in dispatchAction when showTip is dispatched.\n    // FIXME\n    // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n    this._lastDataByCoordSys = null;\n    dispatchAction({\n      type: 'hideTip',\n      from: this.uid\n    });\n  },\n  dispose: function (ecModel, api) {\n    if (env.node || env.wxa) {\n      return;\n    }\n\n    this._tooltipContent.hide();\n\n    globalListener.unregister('itemTooltip', api);\n  }\n});\n/**\n * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n * From top to bottom. (the last one should be globalTooltipModel);\n */\n\n\nfunction buildTooltipModel(modelCascade) {\n  var resultModel = modelCascade.pop();\n\n  while (modelCascade.length) {\n    var tooltipOpt = modelCascade.pop();\n\n    if (tooltipOpt) {\n      if (Model.isInstance(tooltipOpt)) {\n        tooltipOpt = tooltipOpt.get('tooltip', true);\n      } // In each data item tooltip can be simply write:\n      // {\n      //  value: 10,\n      //  tooltip: 'Something you need to know'\n      // }\n\n\n      if (typeof tooltipOpt === 'string') {\n        tooltipOpt = {\n          formatter: tooltipOpt\n        };\n      }\n\n      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n    }\n  }\n\n  return resultModel;\n}\n\nfunction makeDispatchAction(payload, api) {\n  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n}\n\nfunction refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n\n  if (gapH != null) {\n    if (x + width + gapH > viewWidth) {\n      x -= width + gapH;\n    } else {\n      x += gapH;\n    }\n  }\n\n  if (gapV != null) {\n    if (y + height + gapV > viewHeight) {\n      y -= height + gapV;\n    } else {\n      y += gapV;\n    }\n  }\n\n  return [x, y];\n}\n\nfunction confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n  x = Math.min(x + width, viewWidth) - width;\n  y = Math.min(y + height, viewHeight) - height;\n  x = Math.max(x, 0);\n  y = Math.max(y, 0);\n  return [x, y];\n}\n\nfunction getOuterSize(el) {\n  var width = el.clientWidth;\n  var height = el.clientHeight; // Consider browser compatibility.\n  // IE8 does not support getComputedStyle.\n\n  if (document.defaultView && document.defaultView.getComputedStyle) {\n    var stl = document.defaultView.getComputedStyle(el);\n\n    if (stl) {\n      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nfunction calcTooltipPosition(position, rect, contentSize) {\n  var domWidth = contentSize[0];\n  var domHeight = contentSize[1];\n  var gap = 5;\n  var x = 0;\n  var y = 0;\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n\n  switch (position) {\n    case 'inside':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'top':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y - domHeight - gap;\n      break;\n\n    case 'bottom':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight + gap;\n      break;\n\n    case 'left':\n      x = rect.x - domWidth - gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'right':\n      x = rect.x + rectWidth + gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n  }\n\n  return [x, y];\n}\n\nfunction isCenterAlign(align) {\n  return align === 'center' || align === 'middle';\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipView.js\n// module id = 205\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar eventUtil = require(\"zrender/lib/core/event\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar formatUtil = require(\"../../util/format\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar toCamelCase = formatUtil.toCamelCase;\nvar vendors = ['', '-webkit-', '-moz-', '-o-'];\nvar gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n/**\n * @param {number} duration\n * @return {string}\n * @inner\n */\n\nfunction assembleTransition(duration) {\n  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;\n  return zrUtil.map(vendors, function (vendorPrefix) {\n    return vendorPrefix + 'transition:' + transitionText;\n  }).join(';');\n}\n/**\n * @param {Object} textStyle\n * @return {string}\n * @inner\n */\n\n\nfunction assembleFont(textStyleModel) {\n  var cssText = [];\n  var fontSize = textStyleModel.get('fontSize');\n  var color = textStyleModel.getTextColor();\n  color && cssText.push('color:' + color);\n  cssText.push('font:' + textStyleModel.getFont());\n  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n  each(['decoration', 'align'], function (name) {\n    var val = textStyleModel.get(name);\n    val && cssText.push('text-' + name + ':' + val);\n  });\n  return cssText.join(';');\n}\n/**\n * @param {Object} tooltipModel\n * @return {string}\n * @inner\n */\n\n\nfunction assembleCssText(tooltipModel) {\n  var cssText = [];\n  var transitionDuration = tooltipModel.get('transitionDuration');\n  var backgroundColor = tooltipModel.get('backgroundColor');\n  var textStyleModel = tooltipModel.getModel('textStyle');\n  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.\n\n  transitionDuration && cssText.push(assembleTransition(transitionDuration));\n\n  if (backgroundColor) {\n    if (env.canvasSupported) {\n      cssText.push('background-Color:' + backgroundColor);\n    } else {\n      // for ie\n      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));\n      cssText.push('filter:alpha(opacity=70)');\n    }\n  } // Border style\n\n\n  each(['width', 'color', 'radius'], function (name) {\n    var borderName = 'border-' + name;\n    var camelCase = toCamelCase(borderName);\n    var val = tooltipModel.get(camelCase);\n    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n  }); // Text style\n\n  cssText.push(assembleFont(textStyleModel)); // Padding\n\n  if (padding != null) {\n    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n  }\n\n  return cssText.join(';') + ';';\n}\n/**\n * @alias module:echarts/component/tooltip/TooltipContent\n * @constructor\n */\n\n\nfunction TooltipContent(container, api) {\n  if (env.wxa) {\n    return null;\n  }\n\n  var el = document.createElement('div');\n  var zr = this._zr = api.getZr();\n  this.el = el;\n  this._x = api.getWidth() / 2;\n  this._y = api.getHeight() / 2;\n  container.appendChild(el);\n  this._container = container;\n  this._show = false;\n  /**\n   * @private\n   */\n\n  this._hideTimeout;\n  var self = this;\n\n  el.onmouseenter = function () {\n    // clear the timeout in hideLater and keep showing tooltip\n    if (self._enterable) {\n      clearTimeout(self._hideTimeout);\n      self._show = true;\n    }\n\n    self._inContent = true;\n  };\n\n  el.onmousemove = function (e) {\n    e = e || window.event;\n\n    if (!self._enterable) {\n      // Try trigger zrender event to avoid mouse\n      // in and out shape too frequently\n      var handler = zr.handler;\n      eventUtil.normalizeEvent(container, e, true);\n      handler.dispatch('mousemove', e);\n    }\n  };\n\n  el.onmouseleave = function () {\n    if (self._enterable) {\n      if (self._show) {\n        self.hideLater(self._hideDelay);\n      }\n    }\n\n    self._inContent = false;\n  };\n}\n\nTooltipContent.prototype = {\n  constructor: TooltipContent,\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  _enterable: true,\n\n  /**\n   * Update when tooltip is rendered\n   */\n  update: function () {\n    // FIXME\n    // Move this logic to ec main?\n    var container = this._container;\n    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);\n    var domStyle = container.style;\n\n    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n      domStyle.position = 'relative';\n    } // Hide the tooltip\n    // PENDING\n    // this.hide();\n\n  },\n  show: function (tooltipModel) {\n    clearTimeout(this._hideTimeout);\n    var el = this.el;\n    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');\n    el.style.display = el.innerHTML ? 'block' : 'none';\n    this._show = true;\n  },\n  setContent: function (content) {\n    this.el.innerHTML = content == null ? '' : content;\n  },\n  setEnterable: function (enterable) {\n    this._enterable = enterable;\n  },\n  getSize: function () {\n    var el = this.el;\n    return [el.clientWidth, el.clientHeight];\n  },\n  moveTo: function (x, y) {\n    // xy should be based on canvas root. But tooltipContent is\n    // the sibling of canvas root. So padding of ec container\n    // should be considered here.\n    var zr = this._zr;\n    var viewportRootOffset;\n\n    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n      x += viewportRootOffset.offsetLeft;\n      y += viewportRootOffset.offsetTop;\n    }\n\n    var style = this.el.style;\n    style.left = x + 'px';\n    style.top = y + 'px';\n    this._x = x;\n    this._y = y;\n  },\n  hide: function () {\n    this.el.style.display = 'none';\n    this._show = false;\n  },\n  hideLater: function (time) {\n    if (this._show && !(this._inContent && this._enterable)) {\n      if (time) {\n        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times\n\n        this._show = false;\n        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n      } else {\n        this.hide();\n      }\n    }\n  },\n  isShow: function () {\n    return this._show;\n  }\n};\nvar _default = TooltipContent;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipContent.js\n// module id = 206\n// module chunks = 0 1 2 3 4 5","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataFilter.js\n// module id = 207\n// module chunks = 0 1 5 6","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n// module id = 208\n// module chunks = 0 1 3 4","var echarts = require(\"../echarts\");\n\nrequire(\"./legend/LegendModel\");\n\nrequire(\"./legend/legendAction\");\n\nrequire(\"./legend/LegendView\");\n\nvar legendFilter = require(\"./legend/legendFilter\");\n\nvar Component = require(\"../model/Component\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend.js\n// module id = 209\n// module chunks = 0 1 2 3 5","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _model = require(\"../../util/model\");\n\nvar isNameSpecified = _model.isNameSpecified;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // 一级层叠\n    zlevel: 0,\n    // 二级层叠\n    z: 4,\n    show: true,\n    // 布局方式，默认为水平布局，可选为：\n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // 水平对齐\n    // 'auto' | 'left' | 'right'\n    // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // 图例边框颜色\n    borderColor: '#ccc',\n    borderRadius: 0,\n    // 图例边框线宽，单位px，默认为0（无边框）\n    borderWidth: 0,\n    // 图例内边距，单位px，默认各方向内边距为5，\n    // 接受数组分别设定上右下左边距，同css\n    padding: 5,\n    // 各个item之间的间隔，单位px，默认为10，\n    // 横向布局时为水平间隔，纵向布局时为纵向间隔\n    itemGap: 10,\n    // 图例图形宽度\n    itemWidth: 25,\n    // 图例图形高度\n    itemHeight: 14,\n    // 图例关闭时候的颜色\n    inactiveColor: '#ccc',\n    textStyle: {\n      // 图例文字颜色\n      color: '#333'\n    },\n    // formatter: '',\n    // 选择模式，默认开启图例开关\n    selectedMode: true,\n    // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n    // selected: null,\n    // 图例内容（详见legend.data，数组中每一项代表一个item\n    // data: [],\n    // Tooltip 相关配置\n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendModel.js\n// module id = 210\n// module chunks = 0 1 2 3 5","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _listComponent = require(\"../helper/listComponent\");\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = require(\"../../util/layout\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    var excludeSeriesId = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);\n    });\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      } // Representitive series.\n\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api, excludeSeriesId));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode); // FIXME: consider different series has items with the same name.\n\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api, excludeSeriesId));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var symbolKeepAspect = legendModel.get('symbolKeepAspect');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend\n    symbolKeepAspect == null ? true : symbolKeepAspect)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend\n      symbolKeepAspect == null ? true : symbolKeepAspect));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendView.js\n// module id = 211\n// module chunks = 0 1 2 3 5","var _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/listComponent.js\n// module id = 212\n// module chunks = 0 1 2 3 5","var _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/dataColor.js\n// module id = 213\n// module chunks = 0 1 5 6","var _dataProvider = require(\"../../data/helper/dataProvider\");\n\nvar retrieveRawValue = _dataProvider.retrieveRawValue;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/data/List} data\n * @param {number} dataIndex\n * @return {string} label string. Not null/undefined\n */\nfunction getDefaultLabel(data, dataIndex) {\n  var labelDims = data.mapDimension('defaultedLabel', true);\n  var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)\n\n  if (len === 1) {\n    return retrieveRawValue(data, dataIndex, labelDims[0]);\n  } else if (len) {\n    var vals = [];\n\n    for (var i = 0; i < labelDims.length; i++) {\n      var val = retrieveRawValue(data, dataIndex, labelDims[i]);\n      vals.push(val);\n    }\n\n    return vals.join(' ');\n  }\n}\n\nexports.getDefaultLabel = getDefaultLabel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/labelHelper.js\n// module id = 214\n// module chunks = 0 1 3 4","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendAction.js\n// module id = 215\n// module chunks = 0 1 2 3 5","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendFilter.js\n// module id = 216\n// module chunks = 0 1 2 3 5","require(\"./gridSimple\");\n\nrequire(\"./axisPointer/CartesianAxisPointer\");\n\nrequire(\"./axisPointer\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/grid.js\n// module id = 217\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Cartesian = require(\"./Cartesian\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, reserved, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  clampData: function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));\n    return out;\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 218\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Cartesian.js\n// module id = 219\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * Implemented in <module:echarts/coord/cartesian/Grid>.\n   * @return {Array.<module:echarts/coord/cartesian/Axis2D>}\n   *         If not on zero of other axis, return null/undefined.\n   *         If no axes, return an empty array.\n   */\n  getAxesOnZeroOf: null,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Axis2D.js\n// module id = 220\n// module chunks = 0 1 2 3 4","require(\"./AxisModel\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/GridModel.js\n// module id = 221\n// module chunks = 0 1 2 3 4","require(\"../coord/cartesian/AxisModel\");\n\nrequire(\"./axis/CartesianAxisView\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis.js\n// module id = 222\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"../../coord/cartesian/cartesianAxisHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n  remove: function () {\n    this._splitAreaColors = null;\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitAreaModel,\n      clamp: true\n    });\n\n    if (!ticksCoords.length) {\n      return;\n    } // For Making appropriate splitArea animation, the color and anid\n    // should be corresponding to previous one if possible.\n\n\n    var areaColorsLen = areaColors.length;\n    var lastSplitAreaColors = this._splitAreaColors;\n    var newSplitAreaColors = zrUtil.createHashMap();\n    var colorIndex = 0;\n\n    if (lastSplitAreaColors) {\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n        if (cIndex != null) {\n          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n          break;\n        }\n      }\n    }\n\n    var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prev;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n        prev = x + width;\n      } else {\n        x = gridRect.x;\n        y = prev;\n        width = gridRect.width;\n        height = tickCoord - y;\n        prev = y + height;\n      }\n\n      var tickValue = ticksCoords[i - 1].tickValue;\n      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: tickValue != null ? 'area_' + tickValue : null,\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      colorIndex = (colorIndex + 1) % areaColorsLen;\n    }\n\n    this._splitAreaColors = newSplitAreaColors;\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/CartesianAxisView.js\n// module id = 223\n// module chunks = 0 1 2 3 4","var _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var dims = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  var stacked;\n  var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n  if (stacked |= isDimensionStacked(data, dims[0]\n  /*, dims[1]*/\n  )) {\n    // jshint ignore:line\n    dims[0] = stackResultDim;\n  }\n\n  if (stacked |= isDimensionStacked(data, dims[1]\n  /*, dims[0]*/\n  )) {\n    // jshint ignore:line\n    dims[1] = stackResultDim;\n  }\n\n  return {\n    dataDimsForPoint: dims,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: !!stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/helper.js\n// module id = 224\n// module chunks = 0 1 4","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/selectableMixin.js\n// module id = 226\n// module chunks = 0 1 5","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/action/createDataSelectAction.js\n// module id = 229\n// module chunks = 0 1 5","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/poly.js\n// module id = 230\n// module chunks = 0 1 4","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nrequire(\"./pie/PieSeries\");\n\nrequire(\"./pie/PieView\");\n\nvar createDataSelectAction = require(\"../action/createDataSelectAction\");\n\nvar dataColor = require(\"../visual/dataColor\");\n\nvar pieLayout = require(\"./pie/pieLayout\");\n\nvar dataFilter = require(\"../processor/dataFilter\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie.js\n// module id = 231\n// module chunks = 0 1 5","var echarts = require(\"../../echarts\");\n\nvar createListSimply = require(\"../helper/createListSimply\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _number = require(\"../../util/number\");\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = require(\"../../component/helper/selectableMixin\");\n\nvar _dataProvider = require(\"../../data/helper/dataProvider\");\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // 默认全局居中\n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // 默认顺时针\n    clockwise: true,\n    startAngle: 90,\n    // 最小角度改为0\n    minAngle: 0,\n    // 选中时扇区偏移量\n    selectedOffset: 10,\n    // 高亮扇区偏移量\n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // 选择模式，默认关闭，可选single，multiple\n    // selectedMode: false,\n    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n      // 默认使用全局文本样式，详见TEXTSTYLE\n      // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // 引导线两段中的第一段长度\n      length: 15,\n      // 引导线两段中的第二段长度\n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: 各异,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieSeries.js\n// module id = 232\n// module chunks = 0 1 5","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieView.js\n// module id = 233\n// module chunks = 0 1 5","var _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = require(\"./labelLayout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/pieLayout.js\n// module id = 234\n// module chunks = 0 1 5","var textContain = require(\"zrender/lib/contain/text\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // 压\n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // 弹\n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // 右侧\n    ? Number.MAX_VALUE // 下\n    : 0 // 上\n    : isDownList // 左侧\n    ? Number.MAX_VALUE // 下\n    : 0; // 上\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // 右下，左下\n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // 右上，左上\n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/labelLayout.js\n// module id = 235\n// module chunks = 0 1 5","var echarts = require(\"../echarts\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line.js\n// module id = 236\n// module chunks = 0 1 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    symbol: 'emptyCircle',\n    symbolSize: 4,\n    symbolRotate: null,\n    showSymbol: true,\n    // `false`: follow the label interval strategy.\n    // `true`: show all symbols.\n    // `'auto'`: If possible, show all symbols, otherwise\n    //           follow the label interval strategy.\n    showAllSymbol: 'auto',\n    // Whether to connect break point.\n    connectNulls: false,\n    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineSeries.js\n// module id = 237\n// module chunks = 0 1 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _number = require(\"../../util/number\");\n\nvar round = _number.round;\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, forSymbol, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y; // Avoid float number rounding error for symbol on the edge of axis extent.\n  // See #7913 and `test/dataZoom-clip.html`.\n\n  if (forSymbol) {\n    x -= 0.5;\n    width += 0.5;\n    y -= 0.5;\n    height += 0.5;\n  } else {\n    var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n    var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n    if (isHorizontal) {\n      y -= expandSize;\n      height += expandSize * 2;\n    } else {\n      x -= expandSize;\n      width += expandSize * 2;\n    }\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, forSymbol, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent().slice();\n  radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180; // Avoid float number rounding error for symbol on the edge of axis extent.\n\n  if (forSymbol) {\n    radiusExtent[0] -= 0.5;\n    radiusExtent[1] += 0.5;\n  }\n\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: round(polar.cx, 1),\n      cy: round(polar.cy, 1),\n      r0: round(radiusExtent[0], 1),\n      r: round(radiusExtent[1], 1),\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, forSymbol, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, forSymbol, seriesModel) : createGridClipShape(coordSys, hasAnimation, forSymbol, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nfunction getIsIgnoreFunc(seriesModel, data, coordSys) {\n  var showAllSymbol = seriesModel.get('showAllSymbol');\n  var isAuto = showAllSymbol === 'auto';\n\n  if (showAllSymbol && !isAuto) {\n    return;\n  }\n\n  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n  if (!categoryAxis) {\n    return;\n  } // Note that category label interval strategy might bring some weird effect\n  // in some scenario: users may wonder why some of the symbols are not\n  // displayed. So we show all symbols as possible as we can.\n\n\n  if (isAuto // Simplify the logic, do not determine label overlap here.\n  && canShowAllSymbolForCategory(categoryAxis, data)) {\n    return;\n  } // Otherwise follow the label interval strategy on category axis.\n\n\n  var categoryDataDim = data.mapDimension(categoryAxis.dim);\n  var labelMap = {};\n  zrUtil.each(categoryAxis.getViewLabels(), function (labelItem) {\n    labelMap[labelItem.tickValue] = 1;\n  });\n  return function (dataIndex) {\n    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));\n  };\n}\n\nfunction canShowAllSymbolForCategory(categoryAxis, data) {\n  // In mose cases, line is monotonous on category axis, and the label size\n  // is close with each other. So we check the symbol size and some of the\n  // label size alone with the category axis to estimate whether all symbol\n  // can be shown without overlap.\n  var axisExtent = categoryAxis.getExtent();\n  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();\n  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.\n  // Sampling some points, max 5.\n\n  var dataLen = data.count();\n  var step = Math.max(1, Math.round(dataLen / 5));\n\n  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {\n    if (SymbolClz.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.\n    )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number\n    * 1.5 > availSize) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, false, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      } // Update clipPath\n\n\n      lineGroup.setClipPath(createClipShape(coordSys, false, false, seriesModel)); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineView.js\n// module id = 238\n// module chunks = 0 1 4","var _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = 239\n// module chunks = 0 1 4","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(max) ? max : NaN;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(min) ? min : NaN;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    modifyOutputEnd: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            // Only support sample the first dim mapped from value axis.\n            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataSample.js\n// module id = 240\n// module chunks = 0 1 4","var SeriesModel = require(\"../../model/Series\");\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = SeriesModel.extend({\n  type: 'series.__base_bar__',\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  getMarkerPosition: function (value) {\n    var coordSys = this.coordinateSystem;\n\n    if (coordSys) {\n      // PENDING if clamp ?\n      var pt = coordSys.dataToPoint(coordSys.clampData(value));\n      var data = this.getData();\n      var offset = data.getLayout('offset');\n      var size = data.getLayout('size');\n      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n      pt[offsetIndex] += offset + size / 2;\n      return pt;\n    }\n\n    return [NaN, NaN];\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // 最小高度改为0\n    barMinHeight: 0,\n    // 最小角度为0，仅对极坐标系下的柱状图有效\n    barMinAngle: 0,\n    // cursor: null,\n    large: false,\n    largeThreshold: 400,\n    progressive: 5e3,\n    progressiveChunkMode: 'mod',\n    // barMaxWidth: null,\n    // 默认自适应\n    // barWidth: null,\n    // 柱间距离，默认为柱形宽度的30%，可设固定值\n    // barGap: '30%',\n    // 类目间柱形距离，默认为类目间距的20%，可设固定值\n    // barCategoryGap: '20%',\n    // label: {\n    //      show: false\n    // },\n    itemStyle: {},\n    emphasis: {}\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/BaseBarSeries.js\n// module id = 249\n// module chunks = 0 1","var graphic = require(\"../../util/graphic\");\n\nvar _labelHelper = require(\"../helper/labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label');\n  var hoverLabelModel = itemModel.getModel('emphasis.label');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nexports.setLabel = setLabel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/helper.js\n// module id = 250\n// module chunks = 0 1","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _barGrid = require(\"../layout/barGrid\");\n\nvar layout = _barGrid.layout;\nvar largeLayout = _barGrid.largeLayout;\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./bar/BarSeries\");\n\nrequire(\"./bar/BarView\");\n\nrequire(\"../component/gridSimple\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// In case developer forget to include grid component\necharts.registerLayout(zrUtil.curry(layout, 'bar')); // Should after normal bar layout, otherwise it is blocked by normal bar layout.\n\necharts.registerLayout(largeLayout);\necharts.registerVisual({\n  seriesType: 'bar',\n  reset: function (seriesModel) {\n    // Visual coding for legend\n    seriesModel.getData().setVisual('legendSymbol', 'roundRect');\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar.js\n// module id = 255\n// module chunks = 0 1","var BaseBarSeries = require(\"./BaseBarSeries\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = BaseBarSeries.extend({\n  type: 'series.bar',\n  dependencies: ['grid', 'polar'],\n  brushSelector: 'rect',\n\n  /**\n   * @override\n   */\n  getProgressive: function () {\n    // Do not support progressive in normal mode.\n    return this.get('large') ? this.get('progressive') : false;\n  },\n\n  /**\n   * @override\n   */\n  getProgressiveThreshold: function () {\n    // Do not support progressive in normal mode.\n    var progressiveThreshold = this.get('progressiveThreshold');\n    var largeThreshold = this.get('largeThreshold');\n\n    if (largeThreshold > progressiveThreshold) {\n      progressiveThreshold = largeThreshold;\n    }\n\n    return progressiveThreshold;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/BarSeries.js\n// module id = 256\n// module chunks = 0 1","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _helper = require(\"./helper\");\n\nvar setLabel = _helper.setLabel;\n\nvar Model = require(\"../../model/Model\");\n\nvar barItemStyle = require(\"./barItemStyle\");\n\nvar Path = require(\"zrender/lib/graphic/Path\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'barBorderWidth']; // FIXME\n// Just for compatible with ec2.\n\nzrUtil.extend(Model.prototype, barItemStyle);\n\nvar _default = echarts.extendChartView({\n  type: 'bar',\n  render: function (seriesModel, ecModel, api) {\n    this._updateDrawMode(seriesModel);\n\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api);\n    } else {}\n\n    return this.group;\n  },\n  incrementalPrepareRender: function (seriesModel, ecModel, api) {\n    this._clear();\n\n    this._updateDrawMode(seriesModel);\n  },\n  incrementalRender: function (params, seriesModel, ecModel, api) {\n    // Do not support progressive in normal mode.\n    this._incrementalRenderLarge(params, seriesModel);\n  },\n  _updateDrawMode: function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n\n    if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n\n      this._clear();\n    }\n  },\n  _renderNormal: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).update(function (newIndex, oldIndex) {\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (el) {\n        graphic.updateProps(el, {\n          shape: layout\n        }, animationModel, newIndex);\n      } else {\n        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);\n      }\n\n      data.setItemGraphicEl(newIndex, el); // Add back\n\n      group.add(el);\n      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n\n      if (coord.type === 'cartesian2d') {\n        el && removeRect(dataIndex, animationModel, el);\n      } else {\n        el && removeSector(dataIndex, animationModel, el);\n      }\n    }).execute();\n    this._data = data;\n  },\n  _renderLarge: function (seriesModel, ecModel, api) {\n    this._clear();\n\n    createLarge(seriesModel, this.group);\n  },\n  _incrementalRenderLarge: function (params, seriesModel) {\n    createLarge(seriesModel, this.group, true);\n  },\n  dispose: zrUtil.noop,\n  remove: function (ecModel) {\n    this._clear(ecModel);\n  },\n  _clear: function (ecModel) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel && ecModel.get('animation') && data && !this._isLargeDraw) {\n      data.eachItemGraphicEl(function (el) {\n        if (el.type === 'sector') {\n          removeSector(el.dataIndex, ecModel, el);\n        } else {\n          removeRect(el.dataIndex, ecModel, el);\n        }\n      });\n    } else {\n      group.removeAll();\n    }\n\n    this._data = null;\n  }\n});\n\nvar elementCreator = {\n  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var rect = new graphic.Rect({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      var animateTarget = {};\n      rectShape[animateProperty] = 0;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return rect;\n  },\n  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {\n    // Keep the same logic with bar in catesion: use end value to control\n    // direction. Notice that if clockwise is true (by default), the sector\n    // will always draw clockwisely, no matter whether endAngle is greater\n    // or less than startAngle.\n    var clockwise = layout.startAngle < layout.endAngle;\n    var sector = new graphic.Sector({\n      shape: zrUtil.defaults({\n        clockwise: clockwise\n      }, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return sector;\n  }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      width: 0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      r: el.shape.r0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nvar getLayout = {\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var color = data.getItemVisual(dataIndex, 'color');\n  var opacity = data.getItemVisual(dataIndex, 'opacity');\n  var itemStyleModel = itemModel.getModel('itemStyle');\n  var hoverStyle = itemModel.getModel('emphasis.itemStyle').getBarItemStyle();\n\n  if (!isPolar) {\n    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n  }\n\n  el.useStyle(zrUtil.defaults({\n    fill: color,\n    opacity: opacity\n  }, itemStyleModel.getBarItemStyle()));\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\n  if (!isPolar) {\n    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);\n  }\n\n  graphic.setHoverStyle(el, hoverStyle);\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nvar LargePath = Path.extend({\n  type: 'largeBar',\n  shape: {\n    points: []\n  },\n  buildPath: function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n    var startPoint = this.__startPoint;\n    var valueIdx = this.__valueIdx;\n\n    for (var i = 0; i < points.length; i += 2) {\n      startPoint[this.__valueIdx] = points[i + valueIdx];\n      ctx.moveTo(startPoint[0], startPoint[1]);\n      ctx.lineTo(points[i], points[i + 1]);\n    }\n  }\n});\n\nfunction createLarge(seriesModel, group, incremental) {\n  // TODO support polar\n  var data = seriesModel.getData();\n  var startPoint = [];\n  var valueIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;\n  startPoint[1 - valueIdx] = data.getLayout('valueAxisStart');\n  var el = new LargePath({\n    shape: {\n      points: data.getLayout('largePoints')\n    },\n    incremental: !!incremental,\n    __startPoint: startPoint,\n    __valueIdx: valueIdx\n  });\n  group.add(el);\n  setLargeStyle(el, seriesModel, data);\n}\n\nfunction setLargeStyle(el, seriesModel, data) {\n  var borderColor = data.getVisual('borderColor') || data.getVisual('color');\n  var itemStyle = seriesModel.getModel('itemStyle').getItemStyle(['color', 'borderColor']);\n  el.useStyle(itemStyle);\n  el.style.fill = null;\n  el.style.stroke = borderColor;\n  el.style.lineWidth = data.getLayout('barWidth');\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/BarView.js\n// module id = 257\n// module chunks = 0 1","var makeStyleMapper = require(\"../../model/mixin/makeStyleMapper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getBarItemStyle: function (excludes) {\n    var style = getBarItemStyle(this, excludes);\n\n    if (this.getBorderLineDash) {\n      var lineDash = this.getBorderLineDash();\n      lineDash && (style.lineDash = lineDash);\n    }\n\n    return style;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/bar/barItemStyle.js\n// module id = 258\n// module chunks = 0 1"],"sourceRoot":""}