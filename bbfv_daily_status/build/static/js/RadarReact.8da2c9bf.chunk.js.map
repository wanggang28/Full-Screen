{"version":3,"sources":["../static/js/RadarReact.8da2c9bf.chunk.js","EchartsDemo/RadarReact.js","../node_modules/echarts/lib/component/axis/AxisBuilder.js","../node_modules/echarts/lib/visual/symbol.js","../node_modules/echarts/lib/chart/helper/createListSimply.js","../node_modules/echarts/lib/coord/axisDefault.js","../node_modules/echarts/lib/processor/dataFilter.js","../node_modules/echarts/lib/visual/dataColor.js","../node_modules/echarts/lib/chart/radar.js","../node_modules/echarts/lib/component/radar.js","../node_modules/echarts/lib/coord/radar/Radar.js","../node_modules/echarts/lib/coord/radar/IndicatorAxis.js","../node_modules/echarts/lib/coord/radar/RadarModel.js","../node_modules/echarts/lib/component/radar/RadarView.js","../node_modules/echarts/lib/chart/radar/RadarSeries.js","../node_modules/echarts/lib/chart/radar/RadarView.js","../node_modules/echarts/lib/chart/radar/radarLayout.js","../node_modules/echarts/lib/chart/radar/backwardCompat.js"],"names":["webpackJsonp","179","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default","__WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_radar__","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","RadarReact","_React$Component","this","_this","getPrototypeOf","initPie","bind","_props$option","option","undefined","myChart","a","init","ID","setOption","window","onresize","resize","_this2","_props","_props$width","width","_props$height","height","createElement","ref","style","Component","182","exports","makeAxisEventDataBase","axisModel","eventData","componentType","mainType","componentIndex","endTextLayout","opt","textPosition","textRotate","extent","textAlign","textVerticalAlign","rotationDiff","remRadian","rotation","inverse","onLeft","isRadianAroundZero","PI","isSilent","tooltipOpt","get","show","fixMinMaxLabelShow","labelEls","tickEls","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","el","ignore","current","next","labelLayout","firstRect","getBoundingRect","clone","nextRect","mRotationBack","matrixUtil","identity","rotate","applyTransform","mul","getLocalTransform","intersect","isNameLocationCenter","nameLocation","buildAxisTick","axisBuilder","axis","scale","isBlank","tickModel","getModel","lineStyleModel","tickLen","ticksCoords","getTicksCoords","pt1","pt2","matrix","_transform","tickCoord","coord","tickDirection","v2ApplyTransform","tickEl","graphic","Line","subPixelOptimizeLine","anid","tickValue","shape","x1","y1","x2","y2","defaults","getLineStyle","stroke","z2","silent","group","add","push","buildAxisLabel","retrieve","axisLabelShow","labelModel","labelMargin","labels","getViewLabels","labelRotation","labelRotate","innerTextLayout","labelDirection","rawCategoryData","getCategories","triggerEvent","each","labelItem","index","formattedLabel","rawLabel","itemLabelModel","textStyle","Model","ecModel","textColor","getTextColor","dataToCoord","pos","labelOffset","textEl","Text","position","setTextStyle","text","getShallow","textFill","type","targetType","_dumbGroup","updateTransform","decomposeTransform","_util","extend","formatUtil","_number","_symbol","createSymbol","_vector","Math","AxisBuilder","nameDirection","Group","dumbGroup","slice","transform","hasBuilder","name","builders","getGroup","axisLine","getExtent","lineStyle","lineCap","strokeContainThreshold","arrows","arrowSize","arrowOffset","symbolWidth","symbolHeight","offset","r","sqrt","point","symbol","cos","sin","attr","axisTickLabel","axisName","textStyleModel","gap","gapSignal","nameRotation","axisNameAvailableWidth","abs","isFinite","textFont","getFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","truncatedText","truncateText","minChar","placeholder","formatterParams","$vars","__fullText","__truncatedText","tooltip","content","formatter","axisRotation","textRotation","direction","_default","191","seriesType","defaultSymbolType","legendSymbol","performRawSeries","reset","seriesModel","api","dataEach","data","idx","symbolSize","rawValue","getRawValue","params","getDataParams","setItemVisual","hasItemOption","itemModel","getItemModel","itemSymbolType","itemSymbolSize","itemSymbolKeepAspect","getData","symbolType","keepAspect","setVisual","symbolKeepAspect","isSeriesFiltered","hasCallback","192","nameList","isArray","coordDimensions","source","getSource","dimensionsInfo","createDimensions","list","List","initData","198","zrUtil","defaultOption","zlevel","z","nameRotate","nameTruncate","nameTextStyle","nameGap","axisPointer","onZero","onZeroAxisIndex","color","axisTick","inside","axisLabel","margin","fontSize","splitLine","splitArea","areaStyle","axisDefault","categoryAxis","merge","boundaryGap","deduplication","alignWithLabel","interval","valueAxis","splitNumber","timeAxis","min","max","logAxis","logBase","207","legendModels","findComponents","filterSelf","getName","isSelected","213","getTargetSeries","paletteScope","seiresModelMap","createHashMap","eachSeriesByType","__paletteScope","set","uid","dataAll","getRawData","idxMap","rawIdx","getRawIndex","filteredIdx","singleDataColor","getItemVisual","getColorFromPalette","count","265","echarts","dataColor","visualSymbol","radarLayout","dataFilter","backwardCompat","registerVisual","registerLayout","registerProcessor","registerPreprocessor","266","267","Radar","radarModel","_model","dimensions","_indicatorAxes","map","getIndicatorModels","indicatorModel","dim","indicatorAxis","IndicatorAxis","IntervalScale","model","cx","cy","startAngle","numberUtil","_axisHelper","getScaleExtent","niceScaleExtent","CoordinateSystem","getIndicatorAxes","dataToPoint","indicatorIndex","coordToPoint","angle","pointToData","pt","dx","dy","radius","closestAxis","radian","atan2","minRadianDiff","Infinity","closestAxisIdx","diff","coodToData","center","viewWidth","getWidth","viewHeight","getHeight","viewSize","parsePercent","setExtent","update","increaseInterval","exp10","pow","floor","log","LN10","f","indicatorAxes","radarSeries","getComponent","unionExtentFromData","mapDimension","rawExtent","fixedMin","getMin","fixedMax","getMax","getInterval","setInterval","nicedSplitNumber","getTicks","round","halfSplitNumber","radarList","eachComponent","radar","coordinateSystem","register","268","radiusExtent","Axis","inherits","269","defaultsShow","axisModelCommonMixin","valueAxisDefault","RadarModel","extendComponentModel","optionUpdated","showName","nameFormatter","indicatorModels","indicatorOpt","iNameTextStyle","indName","replace","indicator","270","_config","__DEV__","axisBuilderAttrs","extendComponentView","render","removeAll","_buildAxes","_buildSplitLineAndArea","axisBuilders","getColorIndex","areaOrLine","areaOrLineColorList","colorIndex","splitLineModel","splitAreaModel","areaStyleModel","showSplitLine","showSplitArea","splitLineColors","splitAreaColors","splitLines","splitAreas","ticksRadius","Circle","Ring","r0","realSplitNumber","axesTicksPoints","prevPoints","points","j","Polyline","Polygon","concat","reverse","getAreaStyle","mergePath","fill","271","SeriesModel","createListSimply","_format","encodeHTML","RadarSeries","dependencies","superApply","arguments","legendDataProvider","getInitialData","generateCoord","generateCoordCount","formatTooltip","dataIndex","coordSys","val","join","legendHoverLink","radarIndex","label","272","normalizeSymbolSize","symbolUtil","extendChartView","symbolPath","strokeNoScale","updateSymbols","oldPoints","newPoints","symbolGroup","isInit","__dimIdx","getInitialPoints","polar","oldData","_data","getItemLayout","polygon","polyline","initProps","itemGroup","setItemGraphicEl","newIdx","oldIdx","getItemGraphicEl","childAt","updateProps","remove","execute","eachItemGraphicEl","onEmphasis","hoverPolygonIgnore","onNormal","polygonIgnore","useStyle","hoverStyle","hoverAreaStyleModel","isEmpty","parentModel","opacity","itemStyle","getItemStyle","itemHoverStyle","labelHoverModel","eachChild","setStyle","setLabelStyle","labelFetcher","hostModel","labelDataIndex","labelDimIndex","defaultText","autoColor","isRectText","off","on","setHoverStyle","dispose","273","pointsConverter","axes","setItemLayout","274","polarOptArr","polarNotRadar","polarOpt","series","seriesOpt","polarIndex"],"mappings":"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","file":"static/js/RadarReact.8da2c9bf.chunk.js","sourcesContent":["webpackJsonp([6],{\n\n/***/ 179:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__ = __webpack_require__(76);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_radar__ = __webpack_require__(265);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_radar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_radar__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**\r\n * Created by yongyuehuang on 2017/8/5.\r\n *///必须\n//引入雷达图\nvar RadarReact=function(_React$Component){_inherits(RadarReact,_React$Component);function RadarReact(props){_classCallCheck(this,RadarReact);var _this=_possibleConstructorReturn(this,(RadarReact.__proto__||Object.getPrototypeOf(RadarReact)).call(this,props));_this.initPie=_this.initPie.bind(_this);return _this;}_createClass(RadarReact,[{key:'initPie',value:function initPie(){var _props$option=this.props.option,option=_props$option===undefined?{}:_props$option;//外部传入的data数据\nvar myChart=__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default.a.init(this.ID);//初始化echarts\n//设置options\nmyChart.setOption(option);window.onresize=function(){myChart.resize();};}},{key:'componentDidMount',value:function componentDidMount(){this.initPie();}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie();}},{key:'render',value:function render(){var _this2=this;var _props=this.props,_props$width=_props.width,width=_props$width===undefined?\"100%\":_props$width,_props$height=_props.height,height=_props$height===undefined?\"400px\":_props$height;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{ref:function ref(ID){return _this2.ID=ID;},style:{width:width,height:height}});}}]);return RadarReact;}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);/* harmony default export */ __webpack_exports__[\"default\"] = (RadarReact);\n\n/***/ }),\n\n/***/ 182:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(0);\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = __webpack_require__(9);\n\nvar graphic = __webpack_require__(11);\n\nvar Model = __webpack_require__(12);\n\nvar _number = __webpack_require__(5);\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = __webpack_require__(77);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = __webpack_require__(18);\n\nvar _vector = __webpack_require__(2);\n\nvar v2ApplyTransform = _vector.applyTransform;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n    var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;\n\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];\n          symbol.attr({\n            rotation: point.rotate,\n            position: pos,\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticksCoords[i].tickValue,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {\n      itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickValue);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickValue,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: formattedLabel,\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always use formatted label as\n      // input. But in interval scale the formatted label is like '223,445', which\n      // maked user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = rawLabel;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 191:\n/***/ (function(module, exports) {\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    // For legend.\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      var keepAspect = seriesModel.get('symbolKeepAspect');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize,\n        symbolKeepAspect: keepAspect\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n          var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n\n          if (itemSymbolKeepAspect != null) {\n            data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 192:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createDimensions = __webpack_require__(45);\n\nvar List = __webpack_require__(41);\n\nvar _util = __webpack_require__(0);\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 198:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // By degree. By defualt auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // The arrow at both ends the the axis.\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  // Only usefull in the case like: category is\n  // ['2012-01-01', '2012-01-02', ...], where the input\n  // data has been ensured not duplicate and is large data.\n  // null means \"auto\":\n  // if axis.data provided, do not deduplication,\n  // else do deduplication.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For value axis, [GAP, GAP], where\n  // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)\n  boundaryGap: [0, 0],\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  // Min value of the axis. can be:\n  // + a number\n  // + 'dataMin': use the min value in data.\n  // + null/undefined: auto decide min value (consider pretty look and boundaryGap).\n  // min: null,\n  // Max value of the axis. can be:\n  // + a number\n  // + 'dataMax': use the max value in data.\n  // + null/undefined: auto decide max value (consider pretty look and boundaryGap).\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // Optional value can be:\n  // + `false`: always include value 0.\n  // + `true`: the extent do not consider value 0.\n  // scale: false,\n  // AxisTick and axisLabel and splitLine are caculated based on splitNumber.\n  splitNumber: 5 // Interval specifies the span of the ticks is mandatorily.\n  // interval: null\n  // Specify min interval when auto calculate tick interval.\n  // minInterval: null\n  // Specify max interval when auto calculate tick interval.\n  // maxInterval: null\n\n}, defaultOption);\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 207:\n/***/ (function(module, exports) {\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 213:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(0);\n\nvar createHashMap = _util.createHashMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 265:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n__webpack_require__(266);\n\n__webpack_require__(271);\n\n__webpack_require__(272);\n\nvar dataColor = __webpack_require__(213);\n\nvar visualSymbol = __webpack_require__(191);\n\nvar radarLayout = __webpack_require__(273);\n\nvar dataFilter = __webpack_require__(207);\n\nvar backwardCompat = __webpack_require__(274);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Must use radar component\necharts.registerVisual(dataColor('radar'));\necharts.registerVisual(visualSymbol('radar', 'circle'));\necharts.registerLayout(radarLayout);\necharts.registerProcessor(dataFilter('radar'));\necharts.registerPreprocessor(backwardCompat);\n\n/***/ }),\n\n/***/ 266:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(267);\n\n__webpack_require__(269);\n\n__webpack_require__(270);\n\n/***/ }),\n\n/***/ 267:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar IndicatorAxis = __webpack_require__(268);\n\nvar IntervalScale = __webpack_require__(35);\n\nvar numberUtil = __webpack_require__(5);\n\nvar _axisHelper = __webpack_require__(30);\n\nvar getScaleExtent = _axisHelper.getScaleExtent;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\n\nvar CoordinateSystem = __webpack_require__(42);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// TODO clockwise\nfunction Radar(radarModel, ecModel, api) {\n  this._model = radarModel;\n  /**\n   * Radar dimensions\n   * @type {Array.<string>}\n   */\n\n  this.dimensions = [];\n  this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n    var dim = 'indicator_' + idx;\n    var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n    indicatorAxis.name = indicatorModel.get('name'); // Inject model and axis\n\n    indicatorAxis.model = indicatorModel;\n    indicatorModel.axis = indicatorAxis;\n    this.dimensions.push(dim);\n    return indicatorAxis;\n  }, this);\n  this.resize(radarModel, api);\n  /**\n   * @type {number}\n   * @readOnly\n   */\n\n  this.cx;\n  /**\n   * @type {number}\n   * @readOnly\n   */\n\n  this.cy;\n  /**\n   * @type {number}\n   * @readOnly\n   */\n\n  this.r;\n  /**\n   * @type {number}\n   * @readOnly\n   */\n\n  this.startAngle;\n}\n\nRadar.prototype.getIndicatorAxes = function () {\n  return this._indicatorAxes;\n};\n\nRadar.prototype.dataToPoint = function (value, indicatorIndex) {\n  var indicatorAxis = this._indicatorAxes[indicatorIndex];\n  return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n};\n\nRadar.prototype.coordToPoint = function (coord, indicatorIndex) {\n  var indicatorAxis = this._indicatorAxes[indicatorIndex];\n  var angle = indicatorAxis.angle;\n  var x = this.cx + coord * Math.cos(angle);\n  var y = this.cy - coord * Math.sin(angle);\n  return [x, y];\n};\n\nRadar.prototype.pointToData = function (pt) {\n  var dx = pt[0] - this.cx;\n  var dy = pt[1] - this.cy;\n  var radius = Math.sqrt(dx * dx + dy * dy);\n  dx /= radius;\n  dy /= radius;\n  var radian = Math.atan2(-dy, dx); // Find the closest angle\n  // FIXME index can calculated directly\n\n  var minRadianDiff = Infinity;\n  var closestAxis;\n  var closestAxisIdx = -1;\n\n  for (var i = 0; i < this._indicatorAxes.length; i++) {\n    var indicatorAxis = this._indicatorAxes[i];\n    var diff = Math.abs(radian - indicatorAxis.angle);\n\n    if (diff < minRadianDiff) {\n      closestAxis = indicatorAxis;\n      closestAxisIdx = i;\n      minRadianDiff = diff;\n    }\n  }\n\n  return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];\n};\n\nRadar.prototype.resize = function (radarModel, api) {\n  var center = radarModel.get('center');\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  var viewSize = Math.min(viewWidth, viewHeight) / 2;\n  this.cx = numberUtil.parsePercent(center[0], viewWidth);\n  this.cy = numberUtil.parsePercent(center[1], viewHeight);\n  this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n  this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);\n  zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n    indicatorAxis.setExtent(0, this.r);\n    var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length; // Normalize to [-PI, PI]\n\n    angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n    indicatorAxis.angle = angle;\n  }, this);\n};\n\nRadar.prototype.update = function (ecModel, api) {\n  var indicatorAxes = this._indicatorAxes;\n  var radarModel = this._model;\n  zrUtil.each(indicatorAxes, function (indicatorAxis) {\n    indicatorAxis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n    if (radarSeries.get('coordinateSystem') !== 'radar' || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {\n      return;\n    }\n\n    var data = radarSeries.getData();\n    zrUtil.each(indicatorAxes, function (indicatorAxis) {\n      indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));\n    });\n  }, this);\n  var splitNumber = radarModel.get('splitNumber');\n\n  function increaseInterval(interval) {\n    var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10)); // Increase interval\n\n    var f = interval / exp10;\n\n    if (f === 2) {\n      f = 5;\n    } else {\n      // f is 2 or 5\n      f *= 2;\n    }\n\n    return f * exp10;\n  } // Force all the axis fixing the maxSplitNumber.\n\n\n  zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n    var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n    niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n    var axisModel = indicatorAxis.model;\n    var scale = indicatorAxis.scale;\n    var fixedMin = axisModel.getMin();\n    var fixedMax = axisModel.getMax();\n    var interval = scale.getInterval();\n\n    if (fixedMin != null && fixedMax != null) {\n      // User set min, max, divide to get new interval\n      scale.setExtent(+fixedMin, +fixedMax);\n      scale.setInterval((fixedMax - fixedMin) / splitNumber);\n    } else if (fixedMin != null) {\n      var max; // User set min, expand extent on the other side\n\n      do {\n        max = fixedMin + interval * splitNumber;\n        scale.setExtent(+fixedMin, max); // Interval must been set after extent\n        // FIXME\n\n        scale.setInterval(interval);\n        interval = increaseInterval(interval);\n      } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n    } else if (fixedMax != null) {\n      var min; // User set min, expand extent on the other side\n\n      do {\n        min = fixedMax - interval * splitNumber;\n        scale.setExtent(min, +fixedMax);\n        scale.setInterval(interval);\n        interval = increaseInterval(interval);\n      } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n    } else {\n      var nicedSplitNumber = scale.getTicks().length - 1;\n\n      if (nicedSplitNumber > splitNumber) {\n        interval = increaseInterval(interval);\n      } // PENDING\n\n\n      var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;\n      var halfSplitNumber = Math.round(splitNumber / 2);\n      scale.setExtent(numberUtil.round(center - halfSplitNumber * interval), numberUtil.round(center + (splitNumber - halfSplitNumber) * interval));\n      scale.setInterval(interval);\n    }\n  });\n};\n/**\n * Radar dimensions is based on the data\n * @type {Array}\n */\n\n\nRadar.dimensions = [];\n\nRadar.create = function (ecModel, api) {\n  var radarList = [];\n  ecModel.eachComponent('radar', function (radarModel) {\n    var radar = new Radar(radarModel, ecModel, api);\n    radarList.push(radar);\n    radarModel.coordinateSystem = radar;\n  });\n  ecModel.eachSeriesByType('radar', function (radarSeries) {\n    if (radarSeries.get('coordinateSystem') === 'radar') {\n      // Inject coordinate system\n      radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n    }\n  });\n  return radarList;\n};\n\nCoordinateSystem.register('radar', Radar);\nvar _default = Radar;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 268:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Axis = __webpack_require__(81);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction IndicatorAxis(dim, scale, radiusExtent) {\n  Axis.call(this, dim, scale, radiusExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = 'value';\n  this.angle = 0;\n  /**\n   * Indicator name\n   * @type {string}\n   */\n\n  this.name = '';\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.model;\n}\n\nzrUtil.inherits(IndicatorAxis, Axis);\nvar _default = IndicatorAxis;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 269:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar axisDefault = __webpack_require__(198);\n\nvar Model = __webpack_require__(12);\n\nvar axisModelCommonMixin = __webpack_require__(82);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar valueAxisDefault = axisDefault.valueAxis;\n\nfunction defaultsShow(opt, show) {\n  return zrUtil.defaults({\n    show: show\n  }, opt);\n}\n\nvar RadarModel = echarts.extendComponentModel({\n  type: 'radar',\n  optionUpdated: function () {\n    var boundaryGap = this.get('boundaryGap');\n    var splitNumber = this.get('splitNumber');\n    var scale = this.get('scale');\n    var axisLine = this.get('axisLine');\n    var axisTick = this.get('axisTick');\n    var axisLabel = this.get('axisLabel');\n    var nameTextStyle = this.get('name');\n    var showName = this.get('name.show');\n    var nameFormatter = this.get('name.formatter');\n    var nameGap = this.get('nameGap');\n    var triggerEvent = this.get('triggerEvent');\n    var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {\n      // PENDING\n      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n        indicatorOpt.min = 0;\n      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n        indicatorOpt.max = 0;\n      }\n\n      var iNameTextStyle = nameTextStyle;\n\n      if (indicatorOpt.color != null) {\n        iNameTextStyle = zrUtil.defaults({\n          color: indicatorOpt.color\n        }, nameTextStyle);\n      } // Use same configuration\n\n\n      indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {\n        boundaryGap: boundaryGap,\n        splitNumber: splitNumber,\n        scale: scale,\n        axisLine: axisLine,\n        axisTick: axisTick,\n        axisLabel: axisLabel,\n        // Competitable with 2 and use text\n        name: indicatorOpt.text,\n        nameLocation: 'end',\n        nameGap: nameGap,\n        // min: 0,\n        nameTextStyle: iNameTextStyle,\n        triggerEvent: triggerEvent\n      }, false);\n\n      if (!showName) {\n        indicatorOpt.name = '';\n      }\n\n      if (typeof nameFormatter === 'string') {\n        var indName = indicatorOpt.name;\n        indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n      } else if (typeof nameFormatter === 'function') {\n        indicatorOpt.name = nameFormatter(indicatorOpt.name, indicatorOpt);\n      }\n\n      var model = zrUtil.extend(new Model(indicatorOpt, null, this.ecModel), axisModelCommonMixin); // For triggerEvent.\n\n      model.mainType = 'radar';\n      model.componentIndex = this.componentIndex;\n      return model;\n    }, this);\n\n    this.getIndicatorModels = function () {\n      return indicatorModels;\n    };\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 0,\n    center: ['50%', '50%'],\n    radius: '75%',\n    startAngle: 90,\n    name: {\n      show: true // formatter: null\n      // textStyle: {}\n\n    },\n    boundaryGap: [0, 0],\n    splitNumber: 5,\n    nameGap: 15,\n    scale: false,\n    // Polygon or circle\n    shape: 'polygon',\n    axisLine: zrUtil.merge({\n      lineStyle: {\n        color: '#bbb'\n      }\n    }, valueAxisDefault.axisLine),\n    axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n    axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n    splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n    splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n    // {text, min, max}\n    indicator: []\n  }\n});\nvar _default = RadarModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 270:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar AxisBuilder = __webpack_require__(182);\n\nvar graphic = __webpack_require__(11);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\n\nvar _default = echarts.extendComponentView({\n  type: 'radar',\n  render: function (radarModel, ecModel, api) {\n    var group = this.group;\n    group.removeAll();\n\n    this._buildAxes(radarModel);\n\n    this._buildSplitLineAndArea(radarModel);\n  },\n  _buildAxes: function (radarModel) {\n    var radar = radarModel.coordinateSystem;\n    var indicatorAxes = radar.getIndicatorAxes();\n    var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {\n      var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n        position: [radar.cx, radar.cy],\n        rotation: indicatorAxis.angle,\n        labelDirection: -1,\n        tickDirection: -1,\n        nameDirection: 1\n      });\n      return axisBuilder;\n    });\n    zrUtil.each(axisBuilders, function (axisBuilder) {\n      zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n      this.group.add(axisBuilder.getGroup());\n    }, this);\n  },\n  _buildSplitLineAndArea: function (radarModel) {\n    var radar = radarModel.coordinateSystem;\n    var indicatorAxes = radar.getIndicatorAxes();\n\n    if (!indicatorAxes.length) {\n      return;\n    }\n\n    var shape = radarModel.get('shape');\n    var splitLineModel = radarModel.getModel('splitLine');\n    var splitAreaModel = radarModel.getModel('splitArea');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var showSplitLine = splitLineModel.get('show');\n    var showSplitArea = splitAreaModel.get('show');\n    var splitLineColors = lineStyleModel.get('color');\n    var splitAreaColors = areaStyleModel.get('color');\n    splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n    splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n    var splitLines = [];\n    var splitAreas = [];\n\n    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n      var colorIndex = idx % areaOrLineColorList.length;\n      areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n      return colorIndex;\n    }\n\n    if (shape === 'circle') {\n      var ticksRadius = indicatorAxes[0].getTicksCoords();\n      var cx = radar.cx;\n      var cy = radar.cy;\n\n      for (var i = 0; i < ticksRadius.length; i++) {\n        if (showSplitLine) {\n          var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n          splitLines[colorIndex].push(new graphic.Circle({\n            shape: {\n              cx: cx,\n              cy: cy,\n              r: ticksRadius[i].coord\n            }\n          }));\n        }\n\n        if (showSplitArea && i < ticksRadius.length - 1) {\n          var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);\n          splitAreas[colorIndex].push(new graphic.Ring({\n            shape: {\n              cx: cx,\n              cy: cy,\n              r0: ticksRadius[i].coord,\n              r: ticksRadius[i + 1].coord\n            }\n          }));\n        }\n      }\n    } // Polyyon\n    else {\n        var realSplitNumber;\n        var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {\n          var ticksCoords = indicatorAxis.getTicksCoords();\n          realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber);\n          return zrUtil.map(ticksCoords, function (tickCoord) {\n            return radar.coordToPoint(tickCoord.coord, idx);\n          });\n        });\n        var prevPoints = [];\n\n        for (var i = 0; i <= realSplitNumber; i++) {\n          var points = [];\n\n          for (var j = 0; j < indicatorAxes.length; j++) {\n            points.push(axesTicksPoints[j][i]);\n          } // Close\n\n\n          if (points[0]) {\n            points.push(points[0].slice());\n          } else {}\n\n          if (showSplitLine) {\n            var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n            splitLines[colorIndex].push(new graphic.Polyline({\n              shape: {\n                points: points\n              }\n            }));\n          }\n\n          if (showSplitArea && prevPoints) {\n            var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);\n            splitAreas[colorIndex].push(new graphic.Polygon({\n              shape: {\n                points: points.concat(prevPoints)\n              }\n            }));\n          }\n\n          prevPoints = points.slice().reverse();\n        }\n      }\n\n    var lineStyle = lineStyleModel.getLineStyle();\n    var areaStyle = areaStyleModel.getAreaStyle(); // Add splitArea before splitLine\n\n    zrUtil.each(splitAreas, function (splitAreas, idx) {\n      this.group.add(graphic.mergePath(splitAreas, {\n        style: zrUtil.defaults({\n          stroke: 'none',\n          fill: splitAreaColors[idx % splitAreaColors.length]\n        }, areaStyle),\n        silent: true\n      }));\n    }, this);\n    zrUtil.each(splitLines, function (splitLines, idx) {\n      this.group.add(graphic.mergePath(splitLines, {\n        style: zrUtil.defaults({\n          fill: 'none',\n          stroke: splitLineColors[idx % splitLineColors.length]\n        }, lineStyle),\n        silent: true\n      }));\n    }, this);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 271:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SeriesModel = __webpack_require__(78);\n\nvar createListSimply = __webpack_require__(192);\n\nvar zrUtil = __webpack_require__(0);\n\nvar _format = __webpack_require__(9);\n\nvar encodeHTML = _format.encodeHTML;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar RadarSeries = SeriesModel.extend({\n  type: 'series.radar',\n  dependencies: ['radar'],\n  // Overwrite\n  init: function (option) {\n    RadarSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, {\n      generateCoord: 'indicator_',\n      generateCoordCount: Infinity\n    });\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var coordSys = this.coordinateSystem;\n    var indicatorAxes = coordSys.getIndicatorAxes();\n    var name = this.getData().getName(dataIndex);\n    return encodeHTML(name === '' ? this.name : name) + '<br/>' + zrUtil.map(indicatorAxes, function (axis, idx) {\n      var val = data.get(data.mapDimension(axis.dim), dataIndex);\n      return encodeHTML(axis.name + ' : ' + val);\n    }).join('<br />');\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'radar',\n    legendHoverLink: true,\n    radarIndex: 0,\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    label: {\n      position: 'top'\n    },\n    // areaStyle: {\n    // },\n    // itemStyle: {}\n    symbol: 'emptyCircle',\n    symbolSize: 4 // symbolRotate: null\n\n  }\n});\nvar _default = RadarSeries;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 272:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar graphic = __webpack_require__(11);\n\nvar zrUtil = __webpack_require__(0);\n\nvar symbolUtil = __webpack_require__(77);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction normalizeSymbolSize(symbolSize) {\n  if (!zrUtil.isArray(symbolSize)) {\n    symbolSize = [+symbolSize, +symbolSize];\n  }\n\n  return symbolSize;\n}\n\nvar _default = echarts.extendChartView({\n  type: 'radar',\n  render: function (seriesModel, ecModel, api) {\n    var polar = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n\n    function createSymbol(data, idx) {\n      var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n      var color = data.getItemVisual(idx, 'color');\n\n      if (symbolType === 'none') {\n        return;\n      }\n\n      var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n      var symbolPath = symbolUtil.createSymbol(symbolType, -1, -1, 2, 2, color);\n      symbolPath.attr({\n        style: {\n          strokeNoScale: true\n        },\n        z2: 100,\n        scale: [symbolSize[0] / 2, symbolSize[1] / 2]\n      });\n      return symbolPath;\n    }\n\n    function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n      // Simply rerender all\n      symbolGroup.removeAll();\n\n      for (var i = 0; i < newPoints.length - 1; i++) {\n        var symbolPath = createSymbol(data, idx);\n\n        if (symbolPath) {\n          symbolPath.__dimIdx = i;\n\n          if (oldPoints[i]) {\n            symbolPath.attr('position', oldPoints[i]);\n            graphic[isInit ? 'initProps' : 'updateProps'](symbolPath, {\n              position: newPoints[i]\n            }, seriesModel, idx);\n          } else {\n            symbolPath.attr('position', newPoints[i]);\n          }\n\n          symbolGroup.add(symbolPath);\n        }\n      }\n    }\n\n    function getInitialPoints(points) {\n      return zrUtil.map(points, function (pt) {\n        return [polar.cx, polar.cy];\n      });\n    }\n\n    data.diff(oldData).add(function (idx) {\n      var points = data.getItemLayout(idx);\n\n      if (!points) {\n        return;\n      }\n\n      var polygon = new graphic.Polygon();\n      var polyline = new graphic.Polyline();\n      var target = {\n        shape: {\n          points: points\n        }\n      };\n      polygon.shape.points = getInitialPoints(points);\n      polyline.shape.points = getInitialPoints(points);\n      graphic.initProps(polygon, target, seriesModel, idx);\n      graphic.initProps(polyline, target, seriesModel, idx);\n      var itemGroup = new graphic.Group();\n      var symbolGroup = new graphic.Group();\n      itemGroup.add(polyline);\n      itemGroup.add(polygon);\n      itemGroup.add(symbolGroup);\n      updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);\n      data.setItemGraphicEl(idx, itemGroup);\n    }).update(function (newIdx, oldIdx) {\n      var itemGroup = oldData.getItemGraphicEl(oldIdx);\n      var polyline = itemGroup.childAt(0);\n      var polygon = itemGroup.childAt(1);\n      var symbolGroup = itemGroup.childAt(2);\n      var target = {\n        shape: {\n          points: data.getItemLayout(newIdx)\n        }\n      };\n\n      if (!target.shape.points) {\n        return;\n      }\n\n      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);\n      graphic.updateProps(polyline, target, seriesModel);\n      graphic.updateProps(polygon, target, seriesModel);\n      data.setItemGraphicEl(newIdx, itemGroup);\n    }).remove(function (idx) {\n      group.remove(oldData.getItemGraphicEl(idx));\n    }).execute();\n    data.eachItemGraphicEl(function (itemGroup, idx) {\n      var itemModel = data.getItemModel(idx);\n      var polyline = itemGroup.childAt(0);\n      var polygon = itemGroup.childAt(1);\n      var symbolGroup = itemGroup.childAt(2);\n      var color = data.getItemVisual(idx, 'color');\n      group.add(itemGroup);\n      polyline.useStyle(zrUtil.defaults(itemModel.getModel('lineStyle').getLineStyle(), {\n        fill: 'none',\n        stroke: color\n      }));\n      polyline.hoverStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();\n      var areaStyleModel = itemModel.getModel('areaStyle');\n      var hoverAreaStyleModel = itemModel.getModel('emphasis.areaStyle');\n      var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n      var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();\n      hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;\n      polygon.ignore = polygonIgnore;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: color,\n        opacity: 0.7\n      }));\n      polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();\n      var itemStyle = itemModel.getModel('itemStyle').getItemStyle(['color']);\n      var itemHoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n      var labelModel = itemModel.getModel('label');\n      var labelHoverModel = itemModel.getModel('emphasis.label');\n      symbolGroup.eachChild(function (symbolPath) {\n        symbolPath.setStyle(itemStyle);\n        symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);\n        graphic.setLabelStyle(symbolPath.style, symbolPath.hoverStyle, labelModel, labelHoverModel, {\n          labelFetcher: data.hostModel,\n          labelDataIndex: idx,\n          labelDimIndex: symbolPath.__dimIdx,\n          defaultText: data.get(data.dimensions[symbolPath.__dimIdx], idx),\n          autoColor: color,\n          isRectText: true\n        });\n      });\n\n      function onEmphasis() {\n        polygon.attr('ignore', hoverPolygonIgnore);\n      }\n\n      function onNormal() {\n        polygon.attr('ignore', polygonIgnore);\n      }\n\n      itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');\n      itemGroup.on('emphasis', onEmphasis).on('mouseover', onEmphasis).on('normal', onNormal).on('mouseout', onNormal);\n      graphic.setHoverStyle(itemGroup);\n    });\n    this._data = data;\n  },\n  remove: function () {\n    this.group.removeAll();\n    this._data = null;\n  },\n  dispose: function () {}\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 273:\n/***/ (function(module, exports) {\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(ecModel) {\n  ecModel.eachSeriesByType('radar', function (seriesModel) {\n    var data = seriesModel.getData();\n    var points = [];\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (!coordSys) {\n      return;\n    }\n\n    function pointsConverter(val, idx) {\n      points[idx] = points[idx] || [];\n      points[idx][i] = coordSys.dataToPoint(val, i);\n    }\n\n    var axes = coordSys.getIndicatorAxes();\n\n    for (var i = 0; i < axes.length; i++) {\n      data.each(data.mapDimension(axes[i].dim), pointsConverter);\n    }\n\n    data.each(function (idx) {\n      // Close polygon\n      points[idx][0] && points[idx].push(points[idx][0].slice());\n      data.setItemLayout(idx, points[idx]);\n    });\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 274:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Backward compat for radar chart in 2\nfunction _default(option) {\n  var polarOptArr = option.polar;\n\n  if (polarOptArr) {\n    if (!zrUtil.isArray(polarOptArr)) {\n      polarOptArr = [polarOptArr];\n    }\n\n    var polarNotRadar = [];\n    zrUtil.each(polarOptArr, function (polarOpt, idx) {\n      if (polarOpt.indicator) {\n        if (polarOpt.type && !polarOpt.shape) {\n          polarOpt.shape = polarOpt.type;\n        }\n\n        option.radar = option.radar || [];\n\n        if (!zrUtil.isArray(option.radar)) {\n          option.radar = [option.radar];\n        }\n\n        option.radar.push(polarOpt);\n      } else {\n        polarNotRadar.push(polarOpt);\n      }\n    });\n    option.polar = polarNotRadar;\n  }\n\n  zrUtil.each(option.series, function (seriesOpt) {\n    if (seriesOpt && seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n      seriesOpt.radarIndex = seriesOpt.polarIndex;\n    }\n  });\n}\n\nmodule.exports = _default;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/RadarReact.8da2c9bf.chunk.js","/**\r\n * Created by yongyuehuang on 2017/8/5.\r\n */\r\nimport React from 'react'\r\nimport echarts from 'echarts/lib/echarts' //必须\r\nimport 'echarts/lib/chart/radar' //引入雷达图\r\n\r\nexport default class RadarReact extends React.Component {\r\n  \r\n  constructor(props) {\r\n    super(props)\r\n    this.initPie = this.initPie.bind(this)\r\n  }\r\n  \r\n  initPie() {\r\n    const { option={} } = this.props //外部传入的data数据\r\n    let myChart = echarts.init(this.ID) //初始化echarts\r\n    \r\n    //设置options\r\n    myChart.setOption(option)\r\n    window.onresize = function() {\r\n      myChart.resize()\r\n    }\r\n  }\r\n  \r\n  componentDidMount() {\r\n    this.initPie()\r\n  }\r\n  \r\n  componentDidUpdate() {\r\n    this.initPie()\r\n  }\r\n  \r\n  render() {\r\n    const { width=\"100%\", height=\"400px\" } = this.props\r\n    return <div ref={ID => this.ID = ID} style={{width, height}}></div>\r\n  }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/EchartsDemo/RadarReact.js","var _util = require(\"zrender/lib/core/util\");\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _number = require(\"../../util/number\");\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar _vector = require(\"zrender/lib/core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n    var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;\n\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];\n          symbol.attr({\n            rotation: point.rotate,\n            position: pos,\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticksCoords[i].tickValue,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {\n      itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickValue);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickValue,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: formattedLabel,\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always use formatted label as\n      // input. But in interval scale the formatted label is like '223,445', which\n      // maked user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = rawLabel;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/AxisBuilder.js\n// module id = 182\n// module chunks = 0 1 2 3 4 5 6","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    // For legend.\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      var keepAspect = seriesModel.get('symbolKeepAspect');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize,\n        symbolKeepAspect: keepAspect\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n          var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n\n          if (itemSymbolKeepAspect != null) {\n            data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/symbol.js\n// module id = 191\n// module chunks = 0 1 3 4 6","var createDimensions = require(\"../../data/helper/createDimensions\");\n\nvar List = require(\"../../data/List\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListSimply.js\n// module id = 192\n// module chunks = 0 1 2 5 6","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // By degree. By defualt auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // The arrow at both ends the the axis.\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  // Only usefull in the case like: category is\n  // ['2012-01-01', '2012-01-02', ...], where the input\n  // data has been ensured not duplicate and is large data.\n  // null means \"auto\":\n  // if axis.data provided, do not deduplication,\n  // else do deduplication.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For value axis, [GAP, GAP], where\n  // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)\n  boundaryGap: [0, 0],\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  // Min value of the axis. can be:\n  // + a number\n  // + 'dataMin': use the min value in data.\n  // + null/undefined: auto decide min value (consider pretty look and boundaryGap).\n  // min: null,\n  // Max value of the axis. can be:\n  // + a number\n  // + 'dataMax': use the max value in data.\n  // + null/undefined: auto decide max value (consider pretty look and boundaryGap).\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // Optional value can be:\n  // + `false`: always include value 0.\n  // + `true`: the extent do not consider value 0.\n  // scale: false,\n  // AxisTick and axisLabel and splitLine are caculated based on splitNumber.\n  splitNumber: 5 // Interval specifies the span of the ticks is mandatorily.\n  // interval: null\n  // Specify min interval when auto calculate tick interval.\n  // minInterval: null\n  // Specify max interval when auto calculate tick interval.\n  // maxInterval: null\n\n}, defaultOption);\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/axisDefault.js\n// module id = 198\n// module chunks = 0 1 2 3 4 6","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataFilter.js\n// module id = 207\n// module chunks = 0 1 5 6","var _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/dataColor.js\n// module id = 213\n// module chunks = 0 1 5 6","var echarts = require(\"../echarts\");\n\nrequire(\"../component/radar\");\n\nrequire(\"./radar/RadarSeries\");\n\nrequire(\"./radar/RadarView\");\n\nvar dataColor = require(\"../visual/dataColor\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar radarLayout = require(\"./radar/radarLayout\");\n\nvar dataFilter = require(\"../processor/dataFilter\");\n\nvar backwardCompat = require(\"./radar/backwardCompat\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Must use radar component\necharts.registerVisual(dataColor('radar'));\necharts.registerVisual(visualSymbol('radar', 'circle'));\necharts.registerLayout(radarLayout);\necharts.registerProcessor(dataFilter('radar'));\necharts.registerPreprocessor(backwardCompat);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/radar.js\n// module id = 265\n// module chunks = 0 6","require(\"../coord/radar/Radar\");\n\nrequire(\"../coord/radar/RadarModel\");\n\nrequire(\"./radar/RadarView\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/radar.js\n// module id = 266\n// module chunks = 0 6","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar IndicatorAxis = require(\"./IndicatorAxis\");\n\nvar IntervalScale = require(\"../../scale/Interval\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar _axisHelper = require(\"../axisHelper\");\n\nvar getScaleExtent = _axisHelper.getScaleExtent;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// TODO clockwise\nfunction Radar(radarModel, ecModel, api) {\n  this._model = radarModel;\n  /**\n   * Radar dimensions\n   * @type {Array.<string>}\n   */\n\n  this.dimensions = [];\n  this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n    var dim = 'indicator_' + idx;\n    var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n    indicatorAxis.name = indicatorModel.get('name'); // Inject model and axis\n\n    indicatorAxis.model = indicatorModel;\n    indicatorModel.axis = indicatorAxis;\n    this.dimensions.push(dim);\n    return indicatorAxis;\n  }, this);\n  this.resize(radarModel, api);\n  /**\n   * @type {number}\n   * @readOnly\n   */\n\n  this.cx;\n  /**\n   * @type {number}\n   * @readOnly\n   */\n\n  this.cy;\n  /**\n   * @type {number}\n   * @readOnly\n   */\n\n  this.r;\n  /**\n   * @type {number}\n   * @readOnly\n   */\n\n  this.startAngle;\n}\n\nRadar.prototype.getIndicatorAxes = function () {\n  return this._indicatorAxes;\n};\n\nRadar.prototype.dataToPoint = function (value, indicatorIndex) {\n  var indicatorAxis = this._indicatorAxes[indicatorIndex];\n  return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n};\n\nRadar.prototype.coordToPoint = function (coord, indicatorIndex) {\n  var indicatorAxis = this._indicatorAxes[indicatorIndex];\n  var angle = indicatorAxis.angle;\n  var x = this.cx + coord * Math.cos(angle);\n  var y = this.cy - coord * Math.sin(angle);\n  return [x, y];\n};\n\nRadar.prototype.pointToData = function (pt) {\n  var dx = pt[0] - this.cx;\n  var dy = pt[1] - this.cy;\n  var radius = Math.sqrt(dx * dx + dy * dy);\n  dx /= radius;\n  dy /= radius;\n  var radian = Math.atan2(-dy, dx); // Find the closest angle\n  // FIXME index can calculated directly\n\n  var minRadianDiff = Infinity;\n  var closestAxis;\n  var closestAxisIdx = -1;\n\n  for (var i = 0; i < this._indicatorAxes.length; i++) {\n    var indicatorAxis = this._indicatorAxes[i];\n    var diff = Math.abs(radian - indicatorAxis.angle);\n\n    if (diff < minRadianDiff) {\n      closestAxis = indicatorAxis;\n      closestAxisIdx = i;\n      minRadianDiff = diff;\n    }\n  }\n\n  return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];\n};\n\nRadar.prototype.resize = function (radarModel, api) {\n  var center = radarModel.get('center');\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  var viewSize = Math.min(viewWidth, viewHeight) / 2;\n  this.cx = numberUtil.parsePercent(center[0], viewWidth);\n  this.cy = numberUtil.parsePercent(center[1], viewHeight);\n  this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n  this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);\n  zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n    indicatorAxis.setExtent(0, this.r);\n    var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length; // Normalize to [-PI, PI]\n\n    angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n    indicatorAxis.angle = angle;\n  }, this);\n};\n\nRadar.prototype.update = function (ecModel, api) {\n  var indicatorAxes = this._indicatorAxes;\n  var radarModel = this._model;\n  zrUtil.each(indicatorAxes, function (indicatorAxis) {\n    indicatorAxis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n    if (radarSeries.get('coordinateSystem') !== 'radar' || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {\n      return;\n    }\n\n    var data = radarSeries.getData();\n    zrUtil.each(indicatorAxes, function (indicatorAxis) {\n      indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));\n    });\n  }, this);\n  var splitNumber = radarModel.get('splitNumber');\n\n  function increaseInterval(interval) {\n    var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10)); // Increase interval\n\n    var f = interval / exp10;\n\n    if (f === 2) {\n      f = 5;\n    } else {\n      // f is 2 or 5\n      f *= 2;\n    }\n\n    return f * exp10;\n  } // Force all the axis fixing the maxSplitNumber.\n\n\n  zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n    var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n    niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n    var axisModel = indicatorAxis.model;\n    var scale = indicatorAxis.scale;\n    var fixedMin = axisModel.getMin();\n    var fixedMax = axisModel.getMax();\n    var interval = scale.getInterval();\n\n    if (fixedMin != null && fixedMax != null) {\n      // User set min, max, divide to get new interval\n      scale.setExtent(+fixedMin, +fixedMax);\n      scale.setInterval((fixedMax - fixedMin) / splitNumber);\n    } else if (fixedMin != null) {\n      var max; // User set min, expand extent on the other side\n\n      do {\n        max = fixedMin + interval * splitNumber;\n        scale.setExtent(+fixedMin, max); // Interval must been set after extent\n        // FIXME\n\n        scale.setInterval(interval);\n        interval = increaseInterval(interval);\n      } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n    } else if (fixedMax != null) {\n      var min; // User set min, expand extent on the other side\n\n      do {\n        min = fixedMax - interval * splitNumber;\n        scale.setExtent(min, +fixedMax);\n        scale.setInterval(interval);\n        interval = increaseInterval(interval);\n      } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n    } else {\n      var nicedSplitNumber = scale.getTicks().length - 1;\n\n      if (nicedSplitNumber > splitNumber) {\n        interval = increaseInterval(interval);\n      } // PENDING\n\n\n      var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;\n      var halfSplitNumber = Math.round(splitNumber / 2);\n      scale.setExtent(numberUtil.round(center - halfSplitNumber * interval), numberUtil.round(center + (splitNumber - halfSplitNumber) * interval));\n      scale.setInterval(interval);\n    }\n  });\n};\n/**\n * Radar dimensions is based on the data\n * @type {Array}\n */\n\n\nRadar.dimensions = [];\n\nRadar.create = function (ecModel, api) {\n  var radarList = [];\n  ecModel.eachComponent('radar', function (radarModel) {\n    var radar = new Radar(radarModel, ecModel, api);\n    radarList.push(radar);\n    radarModel.coordinateSystem = radar;\n  });\n  ecModel.eachSeriesByType('radar', function (radarSeries) {\n    if (radarSeries.get('coordinateSystem') === 'radar') {\n      // Inject coordinate system\n      radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n    }\n  });\n  return radarList;\n};\n\nCoordinateSystem.register('radar', Radar);\nvar _default = Radar;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/radar/Radar.js\n// module id = 267\n// module chunks = 0 6","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction IndicatorAxis(dim, scale, radiusExtent) {\n  Axis.call(this, dim, scale, radiusExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = 'value';\n  this.angle = 0;\n  /**\n   * Indicator name\n   * @type {string}\n   */\n\n  this.name = '';\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.model;\n}\n\nzrUtil.inherits(IndicatorAxis, Axis);\nvar _default = IndicatorAxis;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/radar/IndicatorAxis.js\n// module id = 268\n// module chunks = 0 6","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisDefault = require(\"../axisDefault\");\n\nvar Model = require(\"../../model/Model\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar valueAxisDefault = axisDefault.valueAxis;\n\nfunction defaultsShow(opt, show) {\n  return zrUtil.defaults({\n    show: show\n  }, opt);\n}\n\nvar RadarModel = echarts.extendComponentModel({\n  type: 'radar',\n  optionUpdated: function () {\n    var boundaryGap = this.get('boundaryGap');\n    var splitNumber = this.get('splitNumber');\n    var scale = this.get('scale');\n    var axisLine = this.get('axisLine');\n    var axisTick = this.get('axisTick');\n    var axisLabel = this.get('axisLabel');\n    var nameTextStyle = this.get('name');\n    var showName = this.get('name.show');\n    var nameFormatter = this.get('name.formatter');\n    var nameGap = this.get('nameGap');\n    var triggerEvent = this.get('triggerEvent');\n    var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {\n      // PENDING\n      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n        indicatorOpt.min = 0;\n      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n        indicatorOpt.max = 0;\n      }\n\n      var iNameTextStyle = nameTextStyle;\n\n      if (indicatorOpt.color != null) {\n        iNameTextStyle = zrUtil.defaults({\n          color: indicatorOpt.color\n        }, nameTextStyle);\n      } // Use same configuration\n\n\n      indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {\n        boundaryGap: boundaryGap,\n        splitNumber: splitNumber,\n        scale: scale,\n        axisLine: axisLine,\n        axisTick: axisTick,\n        axisLabel: axisLabel,\n        // Competitable with 2 and use text\n        name: indicatorOpt.text,\n        nameLocation: 'end',\n        nameGap: nameGap,\n        // min: 0,\n        nameTextStyle: iNameTextStyle,\n        triggerEvent: triggerEvent\n      }, false);\n\n      if (!showName) {\n        indicatorOpt.name = '';\n      }\n\n      if (typeof nameFormatter === 'string') {\n        var indName = indicatorOpt.name;\n        indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n      } else if (typeof nameFormatter === 'function') {\n        indicatorOpt.name = nameFormatter(indicatorOpt.name, indicatorOpt);\n      }\n\n      var model = zrUtil.extend(new Model(indicatorOpt, null, this.ecModel), axisModelCommonMixin); // For triggerEvent.\n\n      model.mainType = 'radar';\n      model.componentIndex = this.componentIndex;\n      return model;\n    }, this);\n\n    this.getIndicatorModels = function () {\n      return indicatorModels;\n    };\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 0,\n    center: ['50%', '50%'],\n    radius: '75%',\n    startAngle: 90,\n    name: {\n      show: true // formatter: null\n      // textStyle: {}\n\n    },\n    boundaryGap: [0, 0],\n    splitNumber: 5,\n    nameGap: 15,\n    scale: false,\n    // Polygon or circle\n    shape: 'polygon',\n    axisLine: zrUtil.merge({\n      lineStyle: {\n        color: '#bbb'\n      }\n    }, valueAxisDefault.axisLine),\n    axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n    axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n    splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n    splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n    // {text, min, max}\n    indicator: []\n  }\n});\nvar _default = RadarModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/radar/RadarModel.js\n// module id = 269\n// module chunks = 0 6","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar AxisBuilder = require(\"../axis/AxisBuilder\");\n\nvar graphic = require(\"../../util/graphic\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\n\nvar _default = echarts.extendComponentView({\n  type: 'radar',\n  render: function (radarModel, ecModel, api) {\n    var group = this.group;\n    group.removeAll();\n\n    this._buildAxes(radarModel);\n\n    this._buildSplitLineAndArea(radarModel);\n  },\n  _buildAxes: function (radarModel) {\n    var radar = radarModel.coordinateSystem;\n    var indicatorAxes = radar.getIndicatorAxes();\n    var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {\n      var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n        position: [radar.cx, radar.cy],\n        rotation: indicatorAxis.angle,\n        labelDirection: -1,\n        tickDirection: -1,\n        nameDirection: 1\n      });\n      return axisBuilder;\n    });\n    zrUtil.each(axisBuilders, function (axisBuilder) {\n      zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n      this.group.add(axisBuilder.getGroup());\n    }, this);\n  },\n  _buildSplitLineAndArea: function (radarModel) {\n    var radar = radarModel.coordinateSystem;\n    var indicatorAxes = radar.getIndicatorAxes();\n\n    if (!indicatorAxes.length) {\n      return;\n    }\n\n    var shape = radarModel.get('shape');\n    var splitLineModel = radarModel.getModel('splitLine');\n    var splitAreaModel = radarModel.getModel('splitArea');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var showSplitLine = splitLineModel.get('show');\n    var showSplitArea = splitAreaModel.get('show');\n    var splitLineColors = lineStyleModel.get('color');\n    var splitAreaColors = areaStyleModel.get('color');\n    splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n    splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n    var splitLines = [];\n    var splitAreas = [];\n\n    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n      var colorIndex = idx % areaOrLineColorList.length;\n      areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n      return colorIndex;\n    }\n\n    if (shape === 'circle') {\n      var ticksRadius = indicatorAxes[0].getTicksCoords();\n      var cx = radar.cx;\n      var cy = radar.cy;\n\n      for (var i = 0; i < ticksRadius.length; i++) {\n        if (showSplitLine) {\n          var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n          splitLines[colorIndex].push(new graphic.Circle({\n            shape: {\n              cx: cx,\n              cy: cy,\n              r: ticksRadius[i].coord\n            }\n          }));\n        }\n\n        if (showSplitArea && i < ticksRadius.length - 1) {\n          var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);\n          splitAreas[colorIndex].push(new graphic.Ring({\n            shape: {\n              cx: cx,\n              cy: cy,\n              r0: ticksRadius[i].coord,\n              r: ticksRadius[i + 1].coord\n            }\n          }));\n        }\n      }\n    } // Polyyon\n    else {\n        var realSplitNumber;\n        var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {\n          var ticksCoords = indicatorAxis.getTicksCoords();\n          realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber);\n          return zrUtil.map(ticksCoords, function (tickCoord) {\n            return radar.coordToPoint(tickCoord.coord, idx);\n          });\n        });\n        var prevPoints = [];\n\n        for (var i = 0; i <= realSplitNumber; i++) {\n          var points = [];\n\n          for (var j = 0; j < indicatorAxes.length; j++) {\n            points.push(axesTicksPoints[j][i]);\n          } // Close\n\n\n          if (points[0]) {\n            points.push(points[0].slice());\n          } else {}\n\n          if (showSplitLine) {\n            var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n            splitLines[colorIndex].push(new graphic.Polyline({\n              shape: {\n                points: points\n              }\n            }));\n          }\n\n          if (showSplitArea && prevPoints) {\n            var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);\n            splitAreas[colorIndex].push(new graphic.Polygon({\n              shape: {\n                points: points.concat(prevPoints)\n              }\n            }));\n          }\n\n          prevPoints = points.slice().reverse();\n        }\n      }\n\n    var lineStyle = lineStyleModel.getLineStyle();\n    var areaStyle = areaStyleModel.getAreaStyle(); // Add splitArea before splitLine\n\n    zrUtil.each(splitAreas, function (splitAreas, idx) {\n      this.group.add(graphic.mergePath(splitAreas, {\n        style: zrUtil.defaults({\n          stroke: 'none',\n          fill: splitAreaColors[idx % splitAreaColors.length]\n        }, areaStyle),\n        silent: true\n      }));\n    }, this);\n    zrUtil.each(splitLines, function (splitLines, idx) {\n      this.group.add(graphic.mergePath(splitLines, {\n        style: zrUtil.defaults({\n          fill: 'none',\n          stroke: splitLineColors[idx % splitLineColors.length]\n        }, lineStyle),\n        silent: true\n      }));\n    }, this);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/radar/RadarView.js\n// module id = 270\n// module chunks = 0 6","var SeriesModel = require(\"../../model/Series\");\n\nvar createListSimply = require(\"../helper/createListSimply\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _format = require(\"../../util/format\");\n\nvar encodeHTML = _format.encodeHTML;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar RadarSeries = SeriesModel.extend({\n  type: 'series.radar',\n  dependencies: ['radar'],\n  // Overwrite\n  init: function (option) {\n    RadarSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, {\n      generateCoord: 'indicator_',\n      generateCoordCount: Infinity\n    });\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var coordSys = this.coordinateSystem;\n    var indicatorAxes = coordSys.getIndicatorAxes();\n    var name = this.getData().getName(dataIndex);\n    return encodeHTML(name === '' ? this.name : name) + '<br/>' + zrUtil.map(indicatorAxes, function (axis, idx) {\n      var val = data.get(data.mapDimension(axis.dim), dataIndex);\n      return encodeHTML(axis.name + ' : ' + val);\n    }).join('<br />');\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'radar',\n    legendHoverLink: true,\n    radarIndex: 0,\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    label: {\n      position: 'top'\n    },\n    // areaStyle: {\n    // },\n    // itemStyle: {}\n    symbol: 'emptyCircle',\n    symbolSize: 4 // symbolRotate: null\n\n  }\n});\nvar _default = RadarSeries;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/radar/RadarSeries.js\n// module id = 271\n// module chunks = 0 6","var echarts = require(\"../../echarts\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar symbolUtil = require(\"../../util/symbol\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction normalizeSymbolSize(symbolSize) {\n  if (!zrUtil.isArray(symbolSize)) {\n    symbolSize = [+symbolSize, +symbolSize];\n  }\n\n  return symbolSize;\n}\n\nvar _default = echarts.extendChartView({\n  type: 'radar',\n  render: function (seriesModel, ecModel, api) {\n    var polar = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n\n    function createSymbol(data, idx) {\n      var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n      var color = data.getItemVisual(idx, 'color');\n\n      if (symbolType === 'none') {\n        return;\n      }\n\n      var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n      var symbolPath = symbolUtil.createSymbol(symbolType, -1, -1, 2, 2, color);\n      symbolPath.attr({\n        style: {\n          strokeNoScale: true\n        },\n        z2: 100,\n        scale: [symbolSize[0] / 2, symbolSize[1] / 2]\n      });\n      return symbolPath;\n    }\n\n    function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n      // Simply rerender all\n      symbolGroup.removeAll();\n\n      for (var i = 0; i < newPoints.length - 1; i++) {\n        var symbolPath = createSymbol(data, idx);\n\n        if (symbolPath) {\n          symbolPath.__dimIdx = i;\n\n          if (oldPoints[i]) {\n            symbolPath.attr('position', oldPoints[i]);\n            graphic[isInit ? 'initProps' : 'updateProps'](symbolPath, {\n              position: newPoints[i]\n            }, seriesModel, idx);\n          } else {\n            symbolPath.attr('position', newPoints[i]);\n          }\n\n          symbolGroup.add(symbolPath);\n        }\n      }\n    }\n\n    function getInitialPoints(points) {\n      return zrUtil.map(points, function (pt) {\n        return [polar.cx, polar.cy];\n      });\n    }\n\n    data.diff(oldData).add(function (idx) {\n      var points = data.getItemLayout(idx);\n\n      if (!points) {\n        return;\n      }\n\n      var polygon = new graphic.Polygon();\n      var polyline = new graphic.Polyline();\n      var target = {\n        shape: {\n          points: points\n        }\n      };\n      polygon.shape.points = getInitialPoints(points);\n      polyline.shape.points = getInitialPoints(points);\n      graphic.initProps(polygon, target, seriesModel, idx);\n      graphic.initProps(polyline, target, seriesModel, idx);\n      var itemGroup = new graphic.Group();\n      var symbolGroup = new graphic.Group();\n      itemGroup.add(polyline);\n      itemGroup.add(polygon);\n      itemGroup.add(symbolGroup);\n      updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);\n      data.setItemGraphicEl(idx, itemGroup);\n    }).update(function (newIdx, oldIdx) {\n      var itemGroup = oldData.getItemGraphicEl(oldIdx);\n      var polyline = itemGroup.childAt(0);\n      var polygon = itemGroup.childAt(1);\n      var symbolGroup = itemGroup.childAt(2);\n      var target = {\n        shape: {\n          points: data.getItemLayout(newIdx)\n        }\n      };\n\n      if (!target.shape.points) {\n        return;\n      }\n\n      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);\n      graphic.updateProps(polyline, target, seriesModel);\n      graphic.updateProps(polygon, target, seriesModel);\n      data.setItemGraphicEl(newIdx, itemGroup);\n    }).remove(function (idx) {\n      group.remove(oldData.getItemGraphicEl(idx));\n    }).execute();\n    data.eachItemGraphicEl(function (itemGroup, idx) {\n      var itemModel = data.getItemModel(idx);\n      var polyline = itemGroup.childAt(0);\n      var polygon = itemGroup.childAt(1);\n      var symbolGroup = itemGroup.childAt(2);\n      var color = data.getItemVisual(idx, 'color');\n      group.add(itemGroup);\n      polyline.useStyle(zrUtil.defaults(itemModel.getModel('lineStyle').getLineStyle(), {\n        fill: 'none',\n        stroke: color\n      }));\n      polyline.hoverStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();\n      var areaStyleModel = itemModel.getModel('areaStyle');\n      var hoverAreaStyleModel = itemModel.getModel('emphasis.areaStyle');\n      var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n      var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();\n      hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;\n      polygon.ignore = polygonIgnore;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: color,\n        opacity: 0.7\n      }));\n      polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();\n      var itemStyle = itemModel.getModel('itemStyle').getItemStyle(['color']);\n      var itemHoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n      var labelModel = itemModel.getModel('label');\n      var labelHoverModel = itemModel.getModel('emphasis.label');\n      symbolGroup.eachChild(function (symbolPath) {\n        symbolPath.setStyle(itemStyle);\n        symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);\n        graphic.setLabelStyle(symbolPath.style, symbolPath.hoverStyle, labelModel, labelHoverModel, {\n          labelFetcher: data.hostModel,\n          labelDataIndex: idx,\n          labelDimIndex: symbolPath.__dimIdx,\n          defaultText: data.get(data.dimensions[symbolPath.__dimIdx], idx),\n          autoColor: color,\n          isRectText: true\n        });\n      });\n\n      function onEmphasis() {\n        polygon.attr('ignore', hoverPolygonIgnore);\n      }\n\n      function onNormal() {\n        polygon.attr('ignore', polygonIgnore);\n      }\n\n      itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');\n      itemGroup.on('emphasis', onEmphasis).on('mouseover', onEmphasis).on('normal', onNormal).on('mouseout', onNormal);\n      graphic.setHoverStyle(itemGroup);\n    });\n    this._data = data;\n  },\n  remove: function () {\n    this.group.removeAll();\n    this._data = null;\n  },\n  dispose: function () {}\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/radar/RadarView.js\n// module id = 272\n// module chunks = 0 6","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(ecModel) {\n  ecModel.eachSeriesByType('radar', function (seriesModel) {\n    var data = seriesModel.getData();\n    var points = [];\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (!coordSys) {\n      return;\n    }\n\n    function pointsConverter(val, idx) {\n      points[idx] = points[idx] || [];\n      points[idx][i] = coordSys.dataToPoint(val, i);\n    }\n\n    var axes = coordSys.getIndicatorAxes();\n\n    for (var i = 0; i < axes.length; i++) {\n      data.each(data.mapDimension(axes[i].dim), pointsConverter);\n    }\n\n    data.each(function (idx) {\n      // Close polygon\n      points[idx][0] && points[idx].push(points[idx][0].slice());\n      data.setItemLayout(idx, points[idx]);\n    });\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/radar/radarLayout.js\n// module id = 273\n// module chunks = 0 6","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Backward compat for radar chart in 2\nfunction _default(option) {\n  var polarOptArr = option.polar;\n\n  if (polarOptArr) {\n    if (!zrUtil.isArray(polarOptArr)) {\n      polarOptArr = [polarOptArr];\n    }\n\n    var polarNotRadar = [];\n    zrUtil.each(polarOptArr, function (polarOpt, idx) {\n      if (polarOpt.indicator) {\n        if (polarOpt.type && !polarOpt.shape) {\n          polarOpt.shape = polarOpt.type;\n        }\n\n        option.radar = option.radar || [];\n\n        if (!zrUtil.isArray(option.radar)) {\n          option.radar = [option.radar];\n        }\n\n        option.radar.push(polarOpt);\n      } else {\n        polarNotRadar.push(polarOpt);\n      }\n    });\n    option.polar = polarNotRadar;\n  }\n\n  zrUtil.each(option.series, function (seriesOpt) {\n    if (seriesOpt && seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n      seriesOpt.radarIndex = seriesOpt.polarIndex;\n    }\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/radar/backwardCompat.js\n// module id = 274\n// module chunks = 0 6"],"sourceRoot":""}