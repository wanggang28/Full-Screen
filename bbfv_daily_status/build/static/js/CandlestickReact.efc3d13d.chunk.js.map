{"version":3,"sources":["../static/js/CandlestickReact.efc3d13d.chunk.js","EchartsDemo/CandlestickReact.js","../node_modules/echarts/lib/component/axisPointer/modelHelper.js","../node_modules/echarts/lib/component/axis/AxisBuilder.js","../node_modules/echarts/lib/component/axis/AxisView.js","../node_modules/echarts/lib/component/axisPointer.js","../node_modules/echarts/lib/component/axisPointer/viewHelper.js","../node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js","../node_modules/echarts/lib/component/axisPointer/globalListener.js","../node_modules/echarts/lib/component/gridSimple.js","../node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js","../node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js","../node_modules/echarts/lib/chart/helper/createListSimply.js","../node_modules/echarts/lib/coord/cartesian/AxisModel.js","../node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js","../node_modules/echarts/lib/component/tooltip.js","../node_modules/echarts/lib/coord/cartesian/Grid.js","../node_modules/echarts/lib/coord/axisModelCreator.js","../node_modules/echarts/lib/coord/axisDefault.js","../node_modules/echarts/lib/component/axisPointer/axisTrigger.js","../node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js","../node_modules/echarts/lib/component/axisPointer/AxisPointerView.js","../node_modules/echarts/lib/component/tooltip/TooltipModel.js","../node_modules/echarts/lib/component/tooltip/TooltipView.js","../node_modules/echarts/lib/component/tooltip/TooltipContent.js","../node_modules/echarts/lib/component/legend.js","../node_modules/echarts/lib/component/legend/LegendModel.js","../node_modules/echarts/lib/component/legend/LegendView.js","../node_modules/echarts/lib/component/helper/listComponent.js","../node_modules/echarts/lib/component/legend/legendAction.js","../node_modules/echarts/lib/component/legend/legendFilter.js","../node_modules/echarts/lib/component/grid.js","../node_modules/echarts/lib/coord/cartesian/Cartesian2D.js","../node_modules/echarts/lib/coord/cartesian/Cartesian.js","../node_modules/echarts/lib/coord/cartesian/Axis2D.js","../node_modules/echarts/lib/coord/cartesian/GridModel.js","../node_modules/echarts/lib/component/axis.js","../node_modules/echarts/lib/component/axis/CartesianAxisView.js","../node_modules/echarts/lib/chart/helper/LineDraw.js","../node_modules/echarts/lib/chart/helper/Line.js","../node_modules/echarts/lib/component/marker/MarkerModel.js","../node_modules/echarts/lib/component/marker/markerHelper.js","../node_modules/echarts/lib/component/marker/MarkerView.js","../node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js","../node_modules/echarts/lib/chart/helper/LinePath.js","../node_modules/echarts/lib/chart/candlestick.js","../node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js","../node_modules/echarts/lib/chart/candlestick/CandlestickView.js","../node_modules/echarts/lib/chart/candlestick/preprocessor.js","../node_modules/echarts/lib/chart/candlestick/candlestickVisual.js","../node_modules/echarts/lib/chart/candlestick/candlestickLayout.js","../node_modules/echarts/lib/component/markLine.js","../node_modules/echarts/lib/component/marker/MarkLineModel.js","../node_modules/echarts/lib/component/marker/MarkLineView.js"],"names":["webpackJsonp","180","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default","__WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_candlestick__","__WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_tooltip__","__WEBPACK_IMPORTED_MODULE_4_echarts_lib_component_legend__","__WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_grid__","__WEBPACK_IMPORTED_MODULE_6_echarts_lib_component_markLine__","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","CandlestickReact","_React$Component","this","_this","getPrototypeOf","initPie","bind","_props$option","option","undefined","myChart","a","init","ID","setOption","window","onresize","resize","_this2","_props","_props$width","width","_props$height","height","createElement","ref","style","Component","181","exports","collect","ecModel","api","result","axesInfo","seriesInvolved","coordSysAxesInfo","coordSysMap","collectAxesInfo","collectSeriesInfo","globalTooltipModel","getComponent","globalAxisPointerModel","linksOption","get","linkGroups","each","getCoordinateSystems","coordSys","saveTooltipAxisInfo","fromTooltip","triggerTooltip","axis","axisPointerModel","model","getModel","axisPointerShow","isHandleTrigger","makeAxisPointerModel","baseTooltipModel","snap","makeKey","involveSeries","type","axisInfo","useHandle","seriesModels","axesInfoInCoordSys","groupIndex","getLinkGroupIndex","linkGroup","mapper","axisPointerEnabled","coordSysKey","coordSysModel","getAxes","curry","getTooltipAxes","triggerAxis","cross","tooltipAxes","baseAxes","otherAxes","tooltipAxisPointerModel","volatileOption","field","zrUtil","clone","labelOption","label","show","tooltipAxisPointerLabelShow","crossStyle","lineStyle","defaults","textStyle","Model","eachSeries","seriesModel","coordinateSystem","seriesTooltipTrigger","seriesTooltipShow","getAxis","dim","push","seriesDataCount","getData","count","axisModel","linkOption","checkPropInLink","id","componentIndex","name","linkPropValue","axisPropValue","isArray","indexOf","fixValue","getAxisInfo","scale","status","parse","extent","getExtent","slice","reverse","isBlank","getAxisPointerModel","182","makeAxisEventDataBase","eventData","componentType","mainType","endTextLayout","opt","textPosition","textRotate","textAlign","textVerticalAlign","rotationDiff","remRadian","rotation","inverse","onLeft","isRadianAroundZero","PI","isSilent","tooltipOpt","fixMinMaxLabelShow","labelEls","tickEls","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","el","ignore","current","next","labelLayout","firstRect","getBoundingRect","nextRect","mRotationBack","matrixUtil","identity","rotate","applyTransform","mul","getLocalTransform","intersect","isNameLocationCenter","nameLocation","buildAxisTick","axisBuilder","tickModel","lineStyleModel","tickLen","ticksCoords","getTicksCoords","pt1","pt2","matrix","_transform","tickCoord","coord","tickDirection","v2ApplyTransform","tickEl","graphic","Line","subPixelOptimizeLine","anid","tickValue","shape","x1","y1","x2","y2","getLineStyle","stroke","z2","silent","group","add","buildAxisLabel","retrieve","axisLabelShow","labelModel","labelMargin","labels","getViewLabels","labelRotation","labelRotate","innerTextLayout","labelDirection","rawCategoryData","getCategories","triggerEvent","labelItem","index","formattedLabel","rawLabel","itemLabelModel","textColor","getTextColor","dataToCoord","pos","labelOffset","textEl","Text","position","setTextStyle","text","getShallow","textFill","targetType","_dumbGroup","updateTransform","decomposeTransform","_util","extend","formatUtil","_number","_symbol","createSymbol","_vector","Math","AxisBuilder","nameDirection","Group","dumbGroup","transform","hasBuilder","builders","getGroup","axisLine","lineCap","strokeContainThreshold","arrows","arrowSize","arrowOffset","symbolWidth","symbolHeight","offset","r","sqrt","point","symbol","cos","sin","attr","axisTickLabel","axisName","textStyleModel","gap","gapSignal","nameRotation","axisNameAvailableWidth","abs","isFinite","textFont","getFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","truncatedText","truncateText","minChar","placeholder","formatterParams","$vars","__fullText","__truncatedText","tooltip","content","formatter","axisRotation","textRotation","direction","_default","183","updateAxisPointer","axisView","payload","forceRender","Clazz","AxisView","getAxisPointerClass","axisPointerClass","axisPointerModelHelper","_axisPointer","render","disposeAxisPointer","axisPointer","dispose","_config","echarts","__DEV__","extendComponentView","superApply","arguments","force","remove","axisPointerClazz","registerAxisPointerClass","clazz","184","axisTrigger","registerPreprocessor","link","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","registerAction","event","update","185","buildElStyle","axisPointerType","styleModel","fill","getAreaStyle","buildLabelElOption","elOption","labelPos","getValueLabel","precision","paddings","normalizeCssArray","font","textRect","textContain","align","verticalAlign","confineInContainer","bgColor","x","y","lineWidth","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","viewWidth","getWidth","viewHeight","getHeight","min","max","seriesDataIndices","getLabel","params","axisHelper","getAxisRawValue","seriesData","idxItem","series","getSeriesByIndex","seriesIndex","dataIndex","dataIndexInside","dataParams","getDataParams","isString","replace","isFunction","getTransformedPosition","layoutInfo","translate","buildCartesianSingleLabelElOption","textLayout","makeLineShape","p1","p2","xDimIndex","makeRectShape","xy","wh","makeSectorShape","cx","cy","r0","startAngle","endAngle","clockwise","186","finder","data","modelUtil","queryDataIndex","getItemGraphicEl","getTooltipPosition","dataToPoint","getValues","map","dimensions","mapDimension","rect","187","register","handler","env","node","zr","getZr","inner","records","initGlobalListeners","useHandler","eventType","cb","on","e","dis","makeDispatchAction","record","dispatchAction","dispatchTooltipFinally","pendings","initialized","doEnter","onLeave","actuallyPayload","showLen","showTip","hideLen","hideTip","currTrigger","pendingList","unregister","_model","makeInner","188","gridModel","removeAll","Rect","getRect","getItemStyle","xAxis","yAxis","grid","189","getCartesian","getAxisDimIndex","BaseAxisPointer","viewHelper","cartesianAxisHelper","CartesianAxisPointer","makeElOption","otherExtent","getOtherAxis","getGlobalExtent","pixelValue","toGlobalCoord","elStyle","pointerOption","pointerShapeBuilder","graphicKey","pointer","layout","getHandleTransform","labelInside","updateHandleTransform","delta","axisExtent","dimIndex","currPosition","cursorOtherValue","cursorPoint","tooltipOptions","tooltipOption","line","targetShape","shadow","bandWidth","getBandWidth","span","190","otherAxisOnZeroOf","getAxesOnZeroOf","rawAxisPosition","axisPosition","axisDim","rectBound","idx","left","right","top","bottom","onZero","axisOffset","posBound","onZeroCoord","dirMap","192","nameList","coordDimensions","source","getSource","dimensionsInfo","createDimensions","list","List","initData","193","getAxisType","ComponentModel","axisModelCreator","axisModelCommonMixin","AxisModel","resetRange","mergeOption","restoreData","getCoordSysModel","queryComponents","gridIndex","gridId","merge","extraOption","194","updateProps","animationModel","moveAnimation","propsEqual","lastProp","stopAnimation","lastProps","newProps","isObject","equals","item","updateLabelShowHide","labelEl","getHandleTransProps","trans","updateMandatoryProps","z","zlevel","traverse","clazzUtil","eventTool","throttleUtil","_group","_lastGraphicKey","_handle","_dragging","_lastValue","_lastStatus","_payloadInfo","animationThreshold","_axisModel","_axisPointerModel","_api","handle","hide","clear","_moveAnimation","determineAnimation","doUpdateProps","updatePointerEl","updateLabelEl","createPointerEl","createLabelEl","_renderHandle","animation","isCategoryAxis","useSnap","pointerEl","setStyle","handleModel","isInit","createIcon","cursor","draggable","onmousemove","stop","onmousedown","_onHandleDragMove","drift","ondragend","_onHandleDragEnd","includeStyles","handleSize","createOrUpdate","_moveHandleToValue","dx","dy","_doDispatchAxisPointer","payloadInfo","axisIndex","doClear","buildLabel","enableClassExtend","195","196","isAxisUsedInTheGrid","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","fixAxisOnZero","axesMap","otherAxisDim","otherAxis","onZeroAxisIndex","canOnZeroToAxis","hasOwnProperty","ifAxisCrossZero","updateAxisTransform","coordBase","axisExtentSum","toLocalCoord","findAxesModels","axesTypes","axisType","getReferringComponents","isCartesian2D","_layout","getLayoutRect","_axisHelper","createScaleByModel","niceScaleExtent","estimateLabelUnionRect","Cartesian2D","Axis2D","CoordinateSystem","_dataStackHelper","getStackedDimension","gridProto","_rect","_updateScale","ignoreContainLabel","adjustAxes","axesList","isHorizontal","gridRect","setExtent","getBoxLayoutParams","labelUnionRect","margin","axesMapOnDim","xAxisIndex","yAxisIndex","coordList","getCartesians","convertToPixel","_findConvertTarget","cartesian","convertFromPixel","pointToData","coordToData","xAxisModel","yAxisModel","coordsList","containPoint","createAxisCreator","axisPositionUsed","isCategory","onBand","axesCount","eachComponent","addAxis","unionExtent","unionExtentFromData","Infinity","axesModels","baseAxis","getBaseAxis","grids","197","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","AXIS_TYPES","mergeDefaultAndTheme","layoutMode","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","optionUpdated","__ordinalMeta","OrdinalMeta","createByAxisModel","rawData","categories","getOrdinalMeta","defaultOption","mergeAll","axisDefault","registerSubTypeDefaulter","198","nameRotate","nameTruncate","nameTextStyle","nameGap","color","symbolSize","axisTick","inside","axisLabel","fontSize","splitLine","splitArea","areaStyle","categoryAxis","boundaryGap","deduplication","alignWithLabel","interval","valueAxis","splitNumber","timeAxis","logAxis","logBase","201","illegalPoint","findPointFromSeries","isIllegalPoint","inputAxesInfo","shouldHide","outputFinder","showValueMap","dataByCoordSys","updaters","showPointer","showTooltip","coordSysContainsPoint","inputAxisInfo","findInputAxisInfo","val","processOnAxis","linkTriggers","tarAxisInfo","tarKey","srcAxisInfo","srcKey","srcValItem","makeMapperParam","updateModelActually","dispatchTooltipActually","dispatchHighDownActually","newValue","dontSnap","containData","buildPayloadsBySeries","payloadBatch","snapToValue","minDist","Number","MAX_VALUE","minDiff","seriesNestestValue","dataIndices","dataDim","getAxisTooltipData","nestestValue","indicesOfNearest","diff","dist","getRawIndex","modelHelper","coordSysItem","coordSysId","coordSysIndex","coordSysType","coordSysMainType","dataByAxis","axisId","valueLabelOpt","outputAxesInfo","valItem","sampleItem","escapeConnect","lastHighlights","newHighlights","batchItem","toHighlight","toDownplay","batch","isNaN","202","AxisPointerModel","extendComponentModel","triggerOn","animationDurationUpdate","shadowStyle","padding","backgroundColor","borderColor","borderWidth","icon","size","throttle","203","globalListener","AxisPointerView","offsetX","offsetY","204","dependencies","showContent","trigger","alwaysShowContent","displayMode","confine","showDelay","hideDelay","transitionDuration","enterable","borderRadius","extraCssText","animationEasingUpdate","205","buildTooltipModel","modelCascade","resultModel","pop","isInstance","refixTooltipPosition","gapH","gapV","getOuterSize","confineTooltipPosition","clientWidth","clientHeight","document","defaultView","getComputedStyle","stl","parseInt","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","calcTooltipPosition","contentSize","domWidth","domHeight","rectWidth","rectHeight","isCenterAlign","TooltipContent","numberUtil","layoutUtil","axisPointerViewHelper","parsePercent","proxyRect","tooltipContent","getDom","_tooltipContent","tooltipModel","wxa","_tooltipModel","_ecModel","_lastDataByCoordSys","_alwaysShowContent","setEnterable","_initGlobalListener","_keepShow","_tryShow","_hide","_lastX","_lastY","clearTimeout","_refreshUpdateTimeout","setTimeout","manuallyShowTip","from","uid","_ticket","_manuallyAxisShowTip","pointInfo","findHover","manuallyHideTip","hideLater","getItemModel","_showAxisTooltip","_showSeriesItemTooltip","_showComponentItemTooltip","_showOrMove","delay","_showTimout","singleDefaultHTML","singleParamsList","singleTooltipModel","itemCoordSys","axisValue","seriesDefaultHTML","valueLabel","axisValueLabel","formatTooltip","firstLine","encodeHTML","join","positionExpr","_updateContentNotChangedOnAxis","_updatePosition","_showTooltipContent","random","dataModel","dataType","tooltipTrigger","defaultHtml","asyncTicket","subTooltipModel","html","formatTpl","callback","cbTicket","setContent","getSize","vAlign","viewSize","layoutRect","moveTo","lastCoordSys","contentNotChanged","lastItemCoordSys","indexCoordSys","lastDataByAxis","thisItemCoordSys","thisDataByAxis","lastItem","indexAxis","thisItem","lastIndices","newIndices","lastIdxItem","j","newIdxItem","206","assembleTransition","duration","transitionText","vendors","vendorPrefix","assembleFont","cssText","round","assembleCssText","canvasSupported","zrColor","toHex","borderName","camelCase","toCamelCase","container","_zr","_x","_y","appendChild","_container","_show","_hideTimeout","onmouseenter","_enterable","_inContent","eventUtil","normalizeEvent","dispatch","onmouseleave","_hideDelay","currentStyle","domStyle","display","innerHTML","viewportRootOffset","painter","getViewportRootOffset","offsetLeft","offsetTop","time","isShow","209","legendFilter","210","isNameSpecified","LegendModel","ignoreSize","parentModel","selected","superCall","_updateData","legendData","_data","hasSelected","isSelected","select","potentialData","availableNames","eachRawSeries","seriesName","isPotential","legendDataProvider","names","mapArray","getName","isSeriesFiltered","concat","_availableNames","dataItem","unSelect","toggleSelected","orient","itemGap","itemWidth","itemHeight","inactiveColor","selectedMode","211","dispatchSelectAction","dispatchHighlightAction","dataName","excludeSeriesId","storage","getDisplayList","useHoverLayer","dispatchDownplayAction","_listComponent","makeBackground","newlineDisabled","_contentGroup","_backgroundEl","getContentGroup","legendModel","resetInner","itemAlign","renderInner","positionInfo","viewportSize","maxSize","mainRect","layoutInner","contentGroup","legendDrawnMap","createHashMap","selectMode","itemModel","newline","getSeriesByName","getVisual","legendSymbolType","symbolType","itemGroup","_createItem","set","indexOfName","getItemVisual","symbolKeepAspect","itemIcon","legendGlobalTooltipModel","textX","hitRect","invisible","legendIndex","eachChild","child","setHoverStyle","__legendDataIndex","box","contentRect","212","componentModel","boxLayoutParams","layoutBox","positionElement","215","legendSelectActionHandler","methodName","selectedMap","isToggleSelect","isItemSelected","216","legendModels","findComponents","filterSeries","217","218","Cartesian","getAxesByScale","axisX","axisY","contain","reserved","out","clampData","xScale","yScale","xAxisExtent","yAxisExtent","inherits","219","dimAxisMapper","_axes","_dimList","scaleType","toLowerCase","filter","_dataCoordConvert","input","method","dimList","output","Array","220","Axis","coordExtent","asc","ret","clamp","221","containLabel","222","223","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","oldAxisGroup","_axisGroup","groupTransition","_splitAreaColors","_splitLine","splitLineModel","lineColors","lineCount","colorIndex","_splitArea","splitAreaModel","areaStyleModel","areaColors","areaColorsLen","lastSplitAreaColors","newSplitAreaColors","cIndex","prev","241","LineDraw","ctor","_ctor","LineGroup","doAdd","lineDraw","lineData","seriesScope","lineNeedsDraw","getItemLayout","setItemGraphicEl","doUpdate","oldLineData","newLineData","oldIdx","newIdx","itemEl","updateData","makeSeriesScope","hostModel","hoverLineStyle","hoverLabelModel","isPointNaN","pt","pts","lineDrawProto","isPersistent","_lineData","execute","updateLayout","eachItemGraphicEl","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","incremental","start","end","_clearIncremental","_incremental","clearDisplaybles","242","makeSymbolTypeKey","symbolCategory","symbolPath","symbolUtil","createLine","points","LinePath","setLinePoints","cp1","percent","cpx1","cpy1","NaN","updateSymbolAndLabelBeforeLineUpdate","lineGroup","symbolFrom","childOfName","symbolTo","invScale","parentNode","parent","__dirty","fromPos","pointAt","toPos","d","vector","sub","normalize","tangent","tangentAt","atan2","distance","__position","halfPercent","cp","__verticalAlign","__textAlign","_createLine","SYMBOL_CATEGORIES","lineProto","beforeUpdate","linePoints","initProps","_updateCommonStl","hasItemOption","visualColor","visualOpacity","retrieve3","opacity","useStyle","strokeNoScale","hoverStyle","setColor","defaultLabelColor","baseText","showLabel","hoverShowLabel","getFormattedLabel","rawVal","getRawValue","normalText","emphasisText","retrieve2","labelStyle","autoColor","fontStyle","fontWeight","fontFamily","highlight","downplay","linePath","dirty","246","fillLabel","defaultEmphasis","dataFormatMixin","addCommas","MarkerModel","extraOpt","createdBySelf","isAnimationEnabled","hostSeries","__hostSeries","newOpt","modelPropName","markerOpt","markerModel","formattedValue","setData","mixin","247","hasXOrY","parseFloat","hasXAndY","markerTypeCalculatorWithExtent","mlType","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","stacked","isDimensionStacked","calcDataDim","getCalculationInfo","numCalculate","getPrecision","toFixed","dataTransform","dims","markerTypeCalculator","baseDataDim","valueDataDim","radiusAxis","angleAxis","valueIndex","valueDim","getDimension","dataDimToCoordDim","dimItem","getDimensionInfo","coordDim","dataFilter","dimValueGetter","dimName","sum","getMedian","getDataExtent","average","248","markerGroupMap","__keep","markerModelKey","renderSeries","253","createListSimply","_dimensionHelper","getDimensionTypeByAxis","seriesModelMixin","_baseAxisDim","getInitialData","ordinalMeta","addOrdinal","xAxisType","yAxisType","coordDims","baseAxisDimIndex","baseAxisDim","axisModels","baseAxisType","otherAxisType","newOptionData","newItem","unshift","defaultValueDimensions","otherDims","itemName","dimsDef","dimensionsCount","264","isLine","vec2","straightLineProto","bezierCurveProto","BezierCurve","extendShape","buildPath","ctx","t","p","277","preprocessor","candlestickVisual","candlestickLayout","registerVisual","registerLayout","278","SeriesModel","_whiskerBoxCommon","CandlestickSeries","defaultTooltip","legendHoverLink","hoverAnimation","itemStyle","color0","borderColor0","emphasis","barMaxWidth","barMinWidth","barWidth","large","largeThreshold","progressive","progressiveThreshold","progressiveChunkMode","animationUpdate","animationEasing","animationDuration","getShadowDim","brushSelector","selectors","itemLayout","brushRect","279","createNormalBox","ends","NormalBoxPath","transInit","setBoxCommon","isSimpleBox","normalItemStyleModel","NORMAL_ITEM_STYLE_PATH","SKIP_PROPS","__simpleBox","EMPHASIS_ITEM_STYLE_PATH","initBaseline","createLarge","largePoints","getLayout","elP","LargeBoxPath","__sign","elN","setLargeStyle","sign","suffix","ChartView","Path","CandlestickView","_updateDrawMode","_isLargeDraw","_renderLarge","_renderNormal","incrementalPrepareRender","_clear","incrementalRender","_incrementalRenderLarge","_incrementalRenderNormal","isLargeDraw","pipelineContext","oldData","hasValue","noop","lineTo","closePath","280","seriesItem","281","createRenderPlanner","positiveBorderColorQuery","negativeBorderColorQuery","positiveColorQuery","negativeColorQuery","seriesType","plan","performRawSeries","reset","progress","setItemVisual","getColor","getBorderColor","isLargeRender","setVisual","legendSymbol","colorP","colorN","borderColorP","borderColorN","282","getSign","openVal","closeVal","closeDim","calculateCandleWidth","_graphic","subPixelOptimize","LargeArr","Float32Array","normalProgress","getPoint","axisDimVal","cDimIdx","vDimIdx","addBodyEnd","point1","point2","candleWidth","subPixelOptimizePoint","cDim","openDim","lowestVal","lowestDim","highestVal","highestDim","ocLow","ocHigh","ocLowPoint","ocHighPoint","lowestPoint","highestPoint","setItemLayout","pmin","pmax","largeProgress","tmpIn","tmpOut","setLayout","vDims","285","markLine","286","287","isInifinity","ifMarkLineHasOnlyDim","fromCoord","toCoord","otherDimIndex","markLineFilter","markerHelper","updateSingleMarkerEndLayout","isFrom","xPx","yPx","getMarkerPosition","createList","mlModel","coordDimsInfos","info","fromData","toData","optData","markLineTransform","to","MarkerView","baseIndex","mlFrom","mlTo","markLineModel","mlData","__from","__to","updateDataVisualAndLayout","seriesId","lineDrawMap","lineColor","fromSymbolSize","fromSymbol","toSymbolSize","toSymbol"],"mappings":"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","file":"static/js/CandlestickReact.efc3d13d.chunk.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 180:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__ = __webpack_require__(76);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_candlestick__ = __webpack_require__(277);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_candlestick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_echarts_lib_chart_candlestick__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_tooltip__ = __webpack_require__(195);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_tooltip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_tooltip__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_echarts_lib_component_legend__ = __webpack_require__(209);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_echarts_lib_component_legend___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_echarts_lib_component_legend__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_grid__ = __webpack_require__(217);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_grid___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_grid__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_echarts_lib_component_markLine__ = __webpack_require__(285);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_echarts_lib_component_markLine___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_echarts_lib_component_markLine__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**\r\n * Created by yongyuehuang on 2017/8/5.\r\n *///\n//\nvar CandlestickReact=function(_React$Component){_inherits(CandlestickReact,_React$Component);function CandlestickReact(props){_classCallCheck(this,CandlestickReact);var _this=_possibleConstructorReturn(this,(CandlestickReact.__proto__||Object.getPrototypeOf(CandlestickReact)).call(this,props));_this.initPie=_this.initPie.bind(_this);return _this;}_createClass(CandlestickReact,[{key:'initPie',value:function initPie(){var _props$option=this.props.option,option=_props$option===undefined?{}:_props$option;//data\nvar myChart=__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default.a.init(this.ID);//echarts\n//options\nmyChart.setOption(option);window.onresize=function(){myChart.resize();};}},{key:'componentDidMount',value:function componentDidMount(){this.initPie();}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie();}},{key:'render',value:function render(){var _this2=this;var _props=this.props,_props$width=_props.width,width=_props$width===undefined?\"100%\":_props$width,_props$height=_props.height,height=_props$height===undefined?\"400px\":_props$height;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{ref:function ref(ID){return _this2.ID=ID;},style:{width:width,height:height}});}}]);return CandlestickReact;}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);/* harmony default export */ __webpack_exports__[\"default\"] = (CandlestickReact);\n\n/***/ }),\n\n/***/ 181:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Model = __webpack_require__(12);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n// allAxesInfo should be updated when setOption performed.\n\nfunction collect(ecModel, api) {\n  var result = {\n    /**\n     * key: makeKey(axis.model)\n     * value: {\n     *      axis,\n     *      coordSys,\n     *      axisPointerModel,\n     *      triggerTooltip,\n     *      involveSeries,\n     *      snap,\n     *      seriesModels,\n     *      seriesDataCount\n     * }\n     */\n    axesInfo: {},\n    seriesInvolved: false,\n\n    /**\n     * key: makeKey(coordSys.model)\n     * value: Object: key makeKey(axis.model), value: axisInfo\n     */\n    coordSysAxesInfo: {},\n    coordSysMap: {}\n  };\n  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.\n\n  result.seriesInvolved && collectSeriesInfo(result, ecModel);\n  return result;\n}\n\nfunction collectAxesInfo(result, ecModel, api) {\n  var globalTooltipModel = ecModel.getComponent('tooltip');\n  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.\n\n  var linksOption = globalAxisPointerModel.get('link', true) || [];\n  var linkGroups = []; // Collect axes info.\n\n  each(api.getCoordinateSystems(), function (coordSys) {\n    // Some coordinate system do not support axes, like geo.\n    if (!coordSys.axisPointerEnabled) {\n      return;\n    }\n\n    var coordSysKey = makeKey(coordSys.model);\n    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer\n    // for user. So we enable seting tooltip on coordSys model.\n\n    var coordSysModel = coordSys.model;\n    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.\n    // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n\n    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not\n    // show but axisPointer will show as normal.\n    && baseTooltipModel.get('show')) {\n      // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n      // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n\n      if (triggerAxis || cross) {\n        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));\n      }\n\n      if (cross) {\n        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n      }\n    } // fromTooltip: true | false | 'cross'\n    // triggerTooltip: true | false | null\n\n\n    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n      var axisPointerShow = axisPointerModel.get('show');\n\n      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {\n        return;\n      }\n\n      if (triggerTooltip == null) {\n        triggerTooltip = axisPointerModel.get('triggerTooltip');\n      }\n\n      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;\n      var snap = axisPointerModel.get('snap');\n      var key = makeKey(axis.model);\n      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n\n      var axisInfo = result.axesInfo[key] = {\n        key: key,\n        axis: axis,\n        coordSys: coordSys,\n        axisPointerModel: axisPointerModel,\n        triggerTooltip: triggerTooltip,\n        involveSeries: involveSeries,\n        snap: snap,\n        useHandle: isHandleTrigger(axisPointerModel),\n        seriesModels: []\n      };\n      axesInfoInCoordSys[key] = axisInfo;\n      result.seriesInvolved |= involveSeries;\n      var groupIndex = getLinkGroupIndex(linksOption, axis);\n\n      if (groupIndex != null) {\n        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {\n          axesInfo: {}\n        });\n        linkGroup.axesInfo[key] = axisInfo;\n        linkGroup.mapper = linksOption[groupIndex].mapper;\n        axisInfo.linkGroup = linkGroup;\n      }\n    }\n  });\n}\n\nfunction makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {\n  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n  var volatileOption = {};\n  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {\n    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n  }); // category axis do not auto snap, otherwise some tick that do not\n  // has value can not be hovered. value/time/log axis default snap if\n  // triggered from tooltip and trigger tooltip.\n\n  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.\n  // Only these properties can be overrided from tooltip to axisPointer.\n\n  if (tooltipAxisPointerModel.get('type') === 'cross') {\n    volatileOption.type = 'line';\n  }\n\n  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.\n\n  labelOption.show == null && (labelOption.show = false);\n\n  if (fromTooltip === 'cross') {\n    // When 'cross', both axes show labels.\n    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get('label.show');\n    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style\n    // (cross style is dashed by default)\n\n    if (!triggerTooltip) {\n      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);\n    }\n  }\n\n  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));\n}\n\nfunction collectSeriesInfo(result, ecModel) {\n  // Prepare data for axis trigger\n  ecModel.eachSeries(function (seriesModel) {\n    // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n    var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n\n    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {\n      return;\n    }\n\n    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n      var axis = axisInfo.axis;\n\n      if (coordSys.getAxis(axis.dim) === axis) {\n        axisInfo.seriesModels.push(seriesModel);\n        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n        axisInfo.seriesDataCount += seriesModel.getData().count();\n      }\n    });\n  }, this);\n}\n/**\n * For example:\n * {\n *     axisPointer: {\n *         links: [{\n *             xAxisIndex: [2, 4],\n *             yAxisIndex: 'all'\n *         }, {\n *             xAxisId: ['a5', 'a7'],\n *             xAxisName: 'xxx'\n *         }]\n *     }\n * }\n */\n\n\nfunction getLinkGroupIndex(linksOption, axis) {\n  var axisModel = axis.model;\n  var dim = axis.dim;\n\n  for (var i = 0; i < linksOption.length; i++) {\n    var linkOption = linksOption[i] || {};\n\n    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {\n      return i;\n    }\n  }\n}\n\nfunction checkPropInLink(linkPropValue, axisPropValue) {\n  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;\n}\n\nfunction fixValue(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n\n  if (!axisInfo) {\n    return;\n  }\n\n  var axisPointerModel = axisInfo.axisPointerModel;\n  var scale = axisInfo.axis.scale;\n  var option = axisPointerModel.option;\n  var status = axisPointerModel.get('status');\n  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.\n\n  if (value != null) {\n    value = scale.parse(value);\n  }\n\n  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value\n  // and status should be initialized.\n\n  if (status == null) {\n    option.status = useHandle ? 'show' : 'hide';\n  }\n\n  var extent = scale.getExtent().slice();\n  extent[0] > extent[1] && extent.reverse();\n\n  if ( // Pick a value on axis when initializing.\n  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n  // where we should re-pick a value to keep `handle` displaying normally.\n  || value > extent[1]) {\n    // Make handle displayed on the end of the axis when init, which looks better.\n    value = extent[1];\n  }\n\n  if (value < extent[0]) {\n    value = extent[0];\n  }\n\n  option.value = value;\n\n  if (useHandle) {\n    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n  }\n}\n\nfunction getAxisInfo(axisModel) {\n  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n}\n\nfunction getAxisPointerModel(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n  return axisInfo && axisInfo.axisPointerModel;\n}\n\nfunction isHandleTrigger(axisPointerModel) {\n  return !!axisPointerModel.get('handle.show');\n}\n/**\n * @param {module:echarts/model/Model} model\n * @return {string} unique key\n */\n\n\nfunction makeKey(model) {\n  return model.type + '||' + model.id;\n}\n\nexports.collect = collect;\nexports.fixValue = fixValue;\nexports.getAxisInfo = getAxisInfo;\nexports.getAxisPointerModel = getAxisPointerModel;\nexports.makeKey = makeKey;\n\n/***/ }),\n\n/***/ 182:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(0);\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = __webpack_require__(9);\n\nvar graphic = __webpack_require__(11);\n\nvar Model = __webpack_require__(12);\n\nvar _number = __webpack_require__(5);\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = __webpack_require__(77);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = __webpack_require__(18);\n\nvar _vector = __webpack_require__(2);\n\nvar v2ApplyTransform = _vector.applyTransform;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n    var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;\n\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];\n          symbol.attr({\n            rotation: point.rotate,\n            position: pos,\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticksCoords[i].tickValue,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {\n      itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickValue);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickValue,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: formattedLabel,\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always use formatted label as\n      // input. But in interval scale the formatted label is like '223,445', which\n      // maked user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = rawLabel;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 183:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(76);\n\nvar axisPointerModelHelper = __webpack_require__(181);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Base class of AxisView.\n */\nvar AxisView = echarts.extendComponentView({\n  type: 'axis',\n\n  /**\n   * @private\n   */\n  _axisPointer: null,\n\n  /**\n   * @protected\n   * @type {string}\n   */\n  axisPointerClass: null,\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    // FIXME\n    // This process should proformed after coordinate systems updated\n    // (axis scale updated), and should be performed each time update.\n    // So put it here temporarily, although it is not appropriate to\n    // put a model-writing procedure in `view`.\n    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n    AxisView.superApply(this, 'render', arguments);\n    updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n  },\n\n  /**\n   * Action handler.\n   * @public\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/model/Global} ecModel\n   * @param {module:echarts/ExtensionAPI} api\n   * @param {Object} payload\n   */\n  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n    updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    var axisPointer = this._axisPointer;\n    axisPointer && axisPointer.remove(api);\n    AxisView.superApply(this, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    disposeAxisPointer(this, api);\n    AxisView.superApply(this, 'dispose', arguments);\n  }\n});\n\nfunction updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n\n  if (!Clazz) {\n    return;\n  }\n\n  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);\n}\n\nfunction disposeAxisPointer(axisView, ecModel, api) {\n  var axisPointer = axisView._axisPointer;\n  axisPointer && axisPointer.dispose(ecModel, api);\n  axisView._axisPointer = null;\n}\n\nvar axisPointerClazz = [];\n\nAxisView.registerAxisPointerClass = function (type, clazz) {\n  axisPointerClazz[type] = clazz;\n};\n\nAxisView.getAxisPointerClass = function (type) {\n  return type && axisPointerClazz[type];\n};\n\nvar _default = AxisView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 184:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar axisPointerModelHelper = __webpack_require__(181);\n\nvar axisTrigger = __webpack_require__(201);\n\n__webpack_require__(202);\n\n__webpack_require__(203);\n\n__webpack_require__(189);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// CartesianAxisPointer is not supposed to be required here. But consider\n// echarts.simple.js and online build tooltip, which only require gridSimple,\n// CartesianAxisPointer should be able to required somewhere.\necharts.registerPreprocessor(function (option) {\n  // Always has a global axisPointerModel for default setting.\n  if (option) {\n    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});\n    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link\n    // is not set, remain null/undefined, otherwise it will\n    // override existent link setting.\n\n    if (link && !zrUtil.isArray(link)) {\n      option.axisPointer.link = [link];\n    }\n  }\n}); // This process should proformed after coordinate systems created\n// and series data processed. So put it on statistic processing stage.\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n  // allAxesInfo should be updated when setOption performed.\n  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);\n}); // Broadcast to all views.\n\necharts.registerAction({\n  type: 'updateAxisPointer',\n  event: 'updateAxisPointer',\n  update: ':updateAxisPointer'\n}, axisTrigger);\n\n/***/ }),\n\n/***/ 185:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(11);\n\nvar textContain = __webpack_require__(14);\n\nvar formatUtil = __webpack_require__(9);\n\nvar matrix = __webpack_require__(18);\n\nvar axisHelper = __webpack_require__(30);\n\nvar AxisBuilder = __webpack_require__(182);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\n\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get('label.precision'),\n    formatter: axisPointerModel.get('label.formatter')\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get('axisLine.lineStyle.color');\n  }\n\n  elOption.label = {\n    shape: {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      r: labelModel.get('borderRadius')\n    },\n    position: position.slice(),\n    // TODO: rich\n    style: {\n      text: text,\n      textFont: font,\n      textFill: labelModel.getTextColor(),\n      textPosition: 'inside',\n      fill: bgColor,\n      stroke: labelModel.get('borderColor') || 'transparent',\n      lineWidth: labelModel.get('borderWidth') || 0,\n      shadowBlur: labelModel.get('shadowBlur'),\n      shadowColor: labelModel.get('shadowColor'),\n      shadowOffsetX: labelModel.get('shadowOffsetX'),\n      shadowOffsetY: labelModel.get('shadowOffsetY')\n    },\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\n\n\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  value = axis.scale.parse(value);\n  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which\n  // helps to debounce when when moving label.\n  value, {\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params = {\n      value: axisHelper.getAxisRawValue(axis, value),\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params);\n    }\n  }\n\n  return text;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\n\n\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\n\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\n\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}\n\nexports.buildElStyle = buildElStyle;\nexports.buildLabelElOption = buildLabelElOption;\nexports.getValueLabel = getValueLabel;\nexports.getTransformedPosition = getTransformedPosition;\nexports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;\nexports.makeLineShape = makeLineShape;\nexports.makeRectShape = makeRectShape;\nexports.makeSectorShape = makeSectorShape;\n\n/***/ }),\n\n/***/ 186:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar modelUtil = __webpack_require__(1);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} {point: [x, y], el: ...} point Will not be null.\n */\nfunction _default(finder, ecModel) {\n  var point = [];\n  var seriesIndex = finder.seriesIndex;\n  var seriesModel;\n\n  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {\n    return {\n      point: []\n    };\n  }\n\n  var data = seriesModel.getData();\n  var dataIndex = modelUtil.queryDataIndex(data, finder);\n\n  if (dataIndex == null || dataIndex < 0 || zrUtil.isArray(dataIndex)) {\n    return {\n      point: []\n    };\n  }\n\n  var el = data.getItemGraphicEl(dataIndex);\n  var coordSys = seriesModel.coordinateSystem;\n\n  if (seriesModel.getTooltipPosition) {\n    point = seriesModel.getTooltipPosition(dataIndex) || [];\n  } else if (coordSys && coordSys.dataToPoint) {\n    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {\n      return data.mapDimension(dim);\n    }), dataIndex, true)) || [];\n  } else if (el) {\n    // Use graphic bounding rect\n    var rect = el.getBoundingRect().clone();\n    rect.applyTransform(el.transform);\n    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n\n  return {\n    point: point,\n    el: el\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 187:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar env = __webpack_require__(7);\n\nvar _model = __webpack_require__(1);\n\nvar makeInner = _model.makeInner;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\nvar each = zrUtil.each;\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n * @param {Function} handler\n *      param: {string} currTrigger\n *      param: {Array.<number>} point\n */\n\nfunction register(key, api, handler) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  inner(zr).records || (inner(zr).records = {});\n  initGlobalListeners(zr, api);\n  var record = inner(zr).records[key] || (inner(zr).records[key] = {});\n  record.handler = handler;\n}\n\nfunction initGlobalListeners(zr, api) {\n  if (inner(zr).initialized) {\n    return;\n  }\n\n  inner(zr).initialized = true;\n  useHandler('click', zrUtil.curry(doEnter, 'click'));\n  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);\n\n  useHandler('globalout', onLeave);\n\n  function useHandler(eventType, cb) {\n    zr.on(eventType, function (e) {\n      var dis = makeDispatchAction(api);\n      each(inner(zr).records, function (record) {\n        record && cb(record, e, dis.dispatchAction);\n      });\n      dispatchTooltipFinally(dis.pendings, api);\n    });\n  }\n}\n\nfunction dispatchTooltipFinally(pendings, api) {\n  var showLen = pendings.showTip.length;\n  var hideLen = pendings.hideTip.length;\n  var actuallyPayload;\n\n  if (showLen) {\n    actuallyPayload = pendings.showTip[showLen - 1];\n  } else if (hideLen) {\n    actuallyPayload = pendings.hideTip[hideLen - 1];\n  }\n\n  if (actuallyPayload) {\n    actuallyPayload.dispatchAction = null;\n    api.dispatchAction(actuallyPayload);\n  }\n}\n\nfunction onLeave(record, e, dispatchAction) {\n  record.handler('leave', null, dispatchAction);\n}\n\nfunction doEnter(currTrigger, record, e, dispatchAction) {\n  record.handler(currTrigger, e, dispatchAction);\n}\n\nfunction makeDispatchAction(api) {\n  var pendings = {\n    showTip: [],\n    hideTip: []\n  }; // FIXME\n  // better approach?\n  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n  // So we have to add \"final stage\" to merge those dispatched actions.\n\n  var dispatchAction = function (payload) {\n    var pendingList = pendings[payload.type];\n\n    if (pendingList) {\n      pendingList.push(payload);\n    } else {\n      payload.dispatchAction = dispatchAction;\n      api.dispatchAction(payload);\n    }\n  };\n\n  return {\n    dispatchAction: dispatchAction,\n    pendings: pendings\n  };\n}\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction unregister(key, api) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  var record = (inner(zr).records || {})[key];\n\n  if (record) {\n    inner(zr).records[key] = null;\n  }\n}\n\nexports.register = register;\nexports.unregister = unregister;\n\n/***/ }),\n\n/***/ 188:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(11);\n\n__webpack_require__(196);\n\n__webpack_require__(222);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n/***/ }),\n\n/***/ 189:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(11);\n\nvar BaseAxisPointer = __webpack_require__(194);\n\nvar viewHelper = __webpack_require__(185);\n\nvar cartesianAxisHelper = __webpack_require__(190);\n\nvar AxisView = __webpack_require__(183);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar CartesianAxisPointer = BaseAxisPointer.extend({\n  /**\n   * @override\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisPointerType = axisPointerModel.get('type');\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = viewHelper.buildElStyle(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n\n    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n  },\n\n  /**\n   * @override\n   */\n  getHandleTransform: function (value, axisModel, axisPointerModel) {\n    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n      labelInside: false\n    });\n    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n    return {\n      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n    };\n  },\n\n  /**\n   * @override\n   */\n  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisExtent = axis.getGlobalExtent(true);\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var dimIndex = axis.dim === 'x' ? 0 : 1;\n    var currPosition = transform.position;\n    currPosition[dimIndex] += delta[dimIndex];\n    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n    var cursorPoint = [cursorOtherValue, cursorOtherValue];\n    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.\n\n    var tooltipOptions = [{\n      verticalAlign: 'middle'\n    }, {\n      align: 'center'\n    }];\n    return {\n      position: currPosition,\n      rotation: transform.rotation,\n      cursorPoint: cursorPoint,\n      tooltipOption: tooltipOptions[dimIndex]\n    };\n  }\n});\n\nfunction getCartesian(grid, axis) {\n  var opt = {};\n  opt[axis.dim + 'AxisIndex'] = axis.index;\n  return grid.getCartesian(opt);\n}\n\nvar pointerShapeBuilder = {\n  line: function (axis, pixelValue, otherExtent, elStyle) {\n    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));\n    graphic.subPixelOptimizeLine({\n      shape: targetShape,\n      style: elStyle\n    });\n    return {\n      type: 'Line',\n      shape: targetShape\n    };\n  },\n  shadow: function (axis, pixelValue, otherExtent, elStyle) {\n    var bandWidth = Math.max(1, axis.getBandWidth());\n    var span = otherExtent[1] - otherExtent[0];\n    return {\n      type: 'Rect',\n      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))\n    };\n  }\n};\n\nfunction getAxisDimIndex(axis) {\n  return axis.dim === 'x' ? 0 : 1;\n}\n\nAxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\nvar _default = CartesianAxisPointer;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 190:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Can only be called after coordinate system creation stage.\n * (Can be called before coordinate system update stage).\n *\n * @param {Object} opt {labelInside}\n * @return {Object} {\n *  position, rotation, labelDirection, labelOffset,\n *  tickDirection, labelRotate, z2\n * }\n */\nfunction layout(gridModel, axisModel, opt) {\n  opt = opt || {};\n  var grid = gridModel.coordinateSystem;\n  var axis = axisModel.axis;\n  var layout = {};\n  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];\n  var rawAxisPosition = axis.position;\n  var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;\n  var axisDim = axis.dim;\n  var rect = grid.getRect();\n  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n  var idx = {\n    left: 0,\n    right: 1,\n    top: 0,\n    bottom: 1,\n    onZero: 2\n  };\n  var axisOffset = axisModel.get('offset') || 0;\n  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n  if (otherAxisOnZeroOf) {\n    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));\n    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n  } // Axis position\n\n\n  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation\n\n  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim\n\n  var dirMap = {\n    top: -1,\n    bottom: 1,\n    left: -1,\n    right: 1\n  };\n  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n  layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n  if (axisModel.get('axisTick.inside')) {\n    layout.tickDirection = -layout.tickDirection;\n  }\n\n  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n    layout.labelDirection = -layout.labelDirection;\n  } // Special label rotation\n\n\n  var labelRotate = axisModel.get('axisLabel.rotate');\n  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea\n\n  layout.z2 = 1;\n  return layout;\n}\n\nexports.layout = layout;\n\n/***/ }),\n\n/***/ 192:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createDimensions = __webpack_require__(45);\n\nvar List = __webpack_require__(41);\n\nvar _util = __webpack_require__(0);\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 193:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar ComponentModel = __webpack_require__(13);\n\nvar axisModelCreator = __webpack_require__(197);\n\nvar axisModelCommonMixin = __webpack_require__(82);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 194:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar clazzUtil = __webpack_require__(8);\n\nvar graphic = __webpack_require__(11);\n\nvar axisPointerModelHelper = __webpack_require__(181);\n\nvar eventTool = __webpack_require__(31);\n\nvar throttleUtil = __webpack_require__(43);\n\nvar _model = __webpack_require__(1);\n\nvar makeInner = _model.makeInner;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\nvar clone = zrUtil.clone;\nvar bind = zrUtil.bind;\n/**\n * Base axis pointer class in 2D.\n * Implemenents {module:echarts/component/axis/IAxisPointer}.\n */\n\nfunction BaseAxisPointer() {}\n\nBaseAxisPointer.prototype = {\n  /**\n   * @private\n   */\n  _group: null,\n\n  /**\n   * @private\n   */\n  _lastGraphicKey: null,\n\n  /**\n   * @private\n   */\n  _handle: null,\n\n  /**\n   * @private\n   */\n  _dragging: false,\n\n  /**\n   * @private\n   */\n  _lastValue: null,\n\n  /**\n   * @private\n   */\n  _lastStatus: null,\n\n  /**\n   * @private\n   */\n  _payloadInfo: null,\n\n  /**\n   * In px, arbitrary value. Do not set too small,\n   * no animation is ok for most cases.\n   * @protected\n   */\n  animationThreshold: 15,\n\n  /**\n   * @implement\n   */\n  render: function (axisModel, axisPointerModel, api, forceRender) {\n    var value = axisPointerModel.get('value');\n    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not\n    // be replaced when user calling setOption in not merge mode.\n\n    this._axisModel = axisModel;\n    this._axisPointerModel = axisPointerModel;\n    this._api = api; // Optimize: `render` will be called repeatly during mouse move.\n    // So it is power consuming if performing `render` each time,\n    // especially on mobile device.\n\n    if (!forceRender && this._lastValue === value && this._lastStatus === status) {\n      return;\n    }\n\n    this._lastValue = value;\n    this._lastStatus = status;\n    var group = this._group;\n    var handle = this._handle;\n\n    if (!status || status === 'hide') {\n      // Do not clear here, for animation better.\n      group && group.hide();\n      handle && handle.hide();\n      return;\n    }\n\n    group && group.show();\n    handle && handle.show(); // Otherwise status is 'show'\n\n    var elOption = {};\n    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.\n\n    var graphicKey = elOption.graphicKey;\n\n    if (graphicKey !== this._lastGraphicKey) {\n      this.clear(api);\n    }\n\n    this._lastGraphicKey = graphicKey;\n    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);\n\n    if (!group) {\n      group = this._group = new graphic.Group();\n      this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n      this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n      api.getZr().add(group);\n    } else {\n      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n    }\n\n    updateMandatoryProps(group, axisPointerModel, true);\n\n    this._renderHandle(value);\n  },\n\n  /**\n   * @implement\n   */\n  remove: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @implement\n   */\n  dispose: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @protected\n   */\n  determineAnimation: function (axisModel, axisPointerModel) {\n    var animation = axisPointerModel.get('animation');\n    var axis = axisModel.axis;\n    var isCategoryAxis = axis.type === 'category';\n    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.\n\n    if (!useSnap && !isCategoryAxis) {\n      return false;\n    }\n\n    if (animation === 'auto' || animation == null) {\n      var animationThreshold = this.animationThreshold;\n\n      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n        return true;\n      } // It is important to auto animation when snap used. Consider if there is\n      // a dataZoom, animation will be disabled when too many points exist, while\n      // it will be enabled for better visual effect when little points exist.\n\n\n      if (useSnap) {\n        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n        var axisExtent = axis.getExtent(); // Approximate band width\n\n        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n      }\n\n      return false;\n    }\n\n    return animation === true;\n  },\n\n  /**\n   * add {pointer, label, graphicKey} to elOption\n   * @protected\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.\n  },\n\n  /**\n   * @protected\n   */\n  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n    var pointerOption = elOption.pointer;\n\n    if (pointerOption) {\n      var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));\n      group.add(pointerEl);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n    if (elOption.label) {\n      var labelEl = inner(group).labelEl = new graphic.Rect(clone(elOption.label));\n      group.add(labelEl);\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updatePointerEl: function (group, elOption, updateProps) {\n    var pointerEl = inner(group).pointerEl;\n\n    if (pointerEl) {\n      pointerEl.setStyle(elOption.pointer.style);\n      updateProps(pointerEl, {\n        shape: elOption.pointer.shape\n      });\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n    var labelEl = inner(group).labelEl;\n\n    if (labelEl) {\n      labelEl.setStyle(elOption.label.style);\n      updateProps(labelEl, {\n        // Consider text length change in vertical axis, animation should\n        // be used on shape, otherwise the effect will be weird.\n        shape: elOption.label.shape,\n        position: elOption.label.position\n      });\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _renderHandle: function (value) {\n    if (this._dragging || !this.updateHandleTransform) {\n      return;\n    }\n\n    var axisPointerModel = this._axisPointerModel;\n\n    var zr = this._api.getZr();\n\n    var handle = this._handle;\n    var handleModel = axisPointerModel.getModel('handle');\n    var status = axisPointerModel.get('status');\n\n    if (!handleModel.get('show') || !status || status === 'hide') {\n      handle && zr.remove(handle);\n      this._handle = null;\n      return;\n    }\n\n    var isInit;\n\n    if (!this._handle) {\n      isInit = true;\n      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {\n        cursor: 'move',\n        draggable: true,\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n        drift: bind(this._onHandleDragMove, this),\n        ondragend: bind(this._onHandleDragEnd, this)\n      });\n      zr.add(handle);\n    }\n\n    updateMandatoryProps(handle, axisPointerModel, false); // update style\n\n    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position\n\n    var handleSize = handleModel.get('size');\n\n    if (!zrUtil.isArray(handleSize)) {\n      handleSize = [handleSize, handleSize];\n    }\n\n    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');\n\n    this._moveHandleToValue(value, isInit);\n  },\n\n  /**\n   * @private\n   */\n  _moveHandleToValue: function (value, isInit) {\n    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragMove: function (dx, dy) {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    this._dragging = true; // Persistent for throttle.\n\n    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);\n    this._payloadInfo = trans;\n    handle.stopAnimation();\n    handle.attr(getHandleTransProps(trans));\n    inner(handle).lastProp = null;\n\n    this._doDispatchAxisPointer();\n  },\n\n  /**\n   * Throttled method.\n   * @private\n   */\n  _doDispatchAxisPointer: function () {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var payloadInfo = this._payloadInfo;\n    var axisModel = this._axisModel;\n\n    this._api.dispatchAction({\n      type: 'updateAxisPointer',\n      x: payloadInfo.cursorPoint[0],\n      y: payloadInfo.cursorPoint[1],\n      tooltipOption: payloadInfo.tooltipOption,\n      axesInfo: [{\n        axisDim: axisModel.axis.dim,\n        axisIndex: axisModel.componentIndex\n      }]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragEnd: function (moveAnimation) {\n    this._dragging = false;\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with\n    // axisPointer. So move handle to align the exact value position when\n    // drag ended.\n\n\n    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle\n    // button, and will be hidden after finger left handle button.\n\n\n    this._api.dispatchAction({\n      type: 'hideTip'\n    });\n  },\n\n  /**\n   * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {number} value\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0}\n   */\n  getHandleTransform: null,\n\n  /**\n   * * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {Object} transform {position, rotation}\n   * @param {Array.<number>} delta [dx, dy]\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n   */\n  updateHandleTransform: null,\n\n  /**\n   * @private\n   */\n  clear: function (api) {\n    this._lastValue = null;\n    this._lastStatus = null;\n    var zr = api.getZr();\n    var group = this._group;\n    var handle = this._handle;\n\n    if (zr && group) {\n      this._lastGraphicKey = null;\n      group && zr.remove(group);\n      handle && zr.remove(handle);\n      this._group = null;\n      this._handle = null;\n      this._payloadInfo = null;\n    }\n  },\n\n  /**\n   * @protected\n   */\n  doClear: function () {// Implemented by sub-class if necessary.\n  },\n\n  /**\n   * @protected\n   * @param {Array.<number>} xy\n   * @param {Array.<number>} wh\n   * @param {number} [xDimIndex=0] or 1\n   */\n  buildLabel: function (xy, wh, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n      x: xy[xDimIndex],\n      y: xy[1 - xDimIndex],\n      width: wh[xDimIndex],\n      height: wh[1 - xDimIndex]\n    };\n  }\n};\nBaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\nfunction updateProps(animationModel, moveAnimation, el, props) {\n  // Animation optimize.\n  if (!propsEqual(inner(el).lastProp, props)) {\n    inner(el).lastProp = props;\n    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));\n  }\n}\n\nfunction propsEqual(lastProps, newProps) {\n  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n    var equals = true;\n    zrUtil.each(newProps, function (item, key) {\n      equals = equals && propsEqual(lastProps[key], item);\n    });\n    return !!equals;\n  } else {\n    return lastProps === newProps;\n  }\n}\n\nfunction updateLabelShowHide(labelEl, axisPointerModel) {\n  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n}\n\nfunction getHandleTransProps(trans) {\n  return {\n    position: trans.position.slice(),\n    rotation: trans.rotation || 0\n  };\n}\n\nfunction updateMandatoryProps(group, axisPointerModel, silent) {\n  var z = axisPointerModel.get('z');\n  var zlevel = axisPointerModel.get('zlevel');\n  group && group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n      el.silent = silent;\n    }\n  });\n}\n\nclazzUtil.enableClassExtend(BaseAxisPointer);\nvar _default = BaseAxisPointer;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 195:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n__webpack_require__(184);\n\n__webpack_require__(204);\n\n__webpack_require__(205);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME Better way to pack data in graphic element\n\n/**\n * @action\n * @property {string} type\n * @property {number} seriesIndex\n * @property {number} dataIndex\n * @property {number} [x]\n * @property {number} [y]\n */\necharts.registerAction({\n  type: 'showTip',\n  event: 'showTip',\n  update: 'tooltip:manuallyShowTip'\n}, // noop\nfunction () {});\necharts.registerAction({\n  type: 'hideTip',\n  event: 'hideTip',\n  update: 'tooltip:manuallyHideTip'\n}, // noop\nfunction () {});\n\n/***/ }),\n\n/***/ 196:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = __webpack_require__(0);\n\nvar isObject = _util.isObject;\nvar each = _util.each;\nvar map = _util.map;\nvar indexOf = _util.indexOf;\nvar retrieve = _util.retrieve;\n\nvar _layout = __webpack_require__(29);\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar _axisHelper = __webpack_require__(30);\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar ifAxisCrossZero = _axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\nvar estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;\n\nvar Cartesian2D = __webpack_require__(218);\n\nvar Axis2D = __webpack_require__(220);\n\nvar CoordinateSystem = __webpack_require__(42);\n\nvar _dataStackHelper = __webpack_require__(32);\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\n__webpack_require__(221);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxis ? [otherAxis] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxis;\n  var axisModel = axis.model;\n  var onZero = axisModel.get('axisLine.onZero');\n  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxis = otherAxes[onZeroAxisIndex];\n    }\n\n    return;\n  } // Find the first available other axis.\n\n\n  for (var idx in otherAxes) {\n    if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])) {\n      otherAxis = otherAxes[idx];\n      break;\n    }\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = estimateLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(data.mapDimension(axis.dim, true), function (dim) {\n      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension\n      // is [0.1, 0.5], the extent of the `stackResultDimension`\n      // is [7, 9], the final extent should not include [0.1, 0.5].\n      data, getStackedDimension(data, dim));\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 197:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar axisDefault = __webpack_require__(198);\n\nvar ComponentModel = __webpack_require__(13);\n\nvar _layout = __webpack_require__(29);\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n\nvar OrdinalMeta = __webpack_require__(85);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      /**\n       * @readOnly\n       */\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n\n      /**\n       * @override\n       */\n      optionUpdated: function () {\n        var thisOption = this.option;\n\n        if (thisOption.type === 'category') {\n          this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);\n        }\n      },\n\n      /**\n       * Should not be called before all of 'getInitailData' finished.\n       * Because categories are collected during initializing data.\n       */\n      getCategories: function (rawData) {\n        var option = this.option; // FIXME\n        // warning if called before all of 'getInitailData' finished.\n\n        if (option.type === 'category') {\n          if (rawData) {\n            return option.data;\n          }\n\n          return this.__ordinalMeta.categories;\n        }\n      },\n      getOrdinalMeta: function () {\n        return this.__ordinalMeta;\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 198:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // By degree. By defualt auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // The arrow at both ends the the axis.\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  // Only usefull in the case like: category is\n  // ['2012-01-01', '2012-01-02', ...], where the input\n  // data has been ensured not duplicate and is large data.\n  // null means \"auto\":\n  // if axis.data provided, do not deduplication,\n  // else do deduplication.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For value axis, [GAP, GAP], where\n  // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)\n  boundaryGap: [0, 0],\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  // Min value of the axis. can be:\n  // + a number\n  // + 'dataMin': use the min value in data.\n  // + null/undefined: auto decide min value (consider pretty look and boundaryGap).\n  // min: null,\n  // Max value of the axis. can be:\n  // + a number\n  // + 'dataMax': use the max value in data.\n  // + null/undefined: auto decide max value (consider pretty look and boundaryGap).\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // Optional value can be:\n  // + `false`: always include value 0.\n  // + `true`: the extent do not consider value 0.\n  // scale: false,\n  // AxisTick and axisLabel and splitLine are caculated based on splitNumber.\n  splitNumber: 5 // Interval specifies the span of the ticks is mandatorily.\n  // interval: null\n  // Specify min interval when auto calculate tick interval.\n  // minInterval: null\n  // Specify max interval when auto calculate tick interval.\n  // maxInterval: null\n\n}, defaultOption);\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 201:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar _model = __webpack_require__(1);\n\nvar makeInner = _model.makeInner;\n\nvar modelHelper = __webpack_require__(181);\n\nvar findPointFromSeries = __webpack_require__(186);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar curry = zrUtil.curry;\nvar inner = makeInner();\n/**\n * Basic logic: check all axis, if they do not demand show/highlight,\n * then hide/downplay them.\n *\n * @param {Object} coordSysAxesInfo\n * @param {Object} payload\n * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n * @param {Object} [payload.dataIndex] finder, restrict target axes.\n * @param {Object} [payload.axesInfo] finder, restrict target axes.\n *        [{\n *          axisDim: 'x'|'y'|'angle'|...,\n *          axisIndex: ...,\n *          value: ...\n *        }, ...]\n * @param {Function} [payload.dispatchAction]\n * @param {Object} [payload.tooltipOption]\n * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n *        which can be specified in dispatchAction\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n * @return {Object} content of event obj for echarts.connect.\n */\n\nfunction _default(payload, ecModel, api) {\n  var currTrigger = payload.currTrigger;\n  var point = [payload.x, payload.y];\n  var finder = payload;\n  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending\n  // See #6121. But we are not able to reproduce it yet.\n\n  if (!coordSysAxesInfo) {\n    return;\n  }\n\n  if (illegalPoint(point)) {\n    // Used in the default behavior of `connection`: use the sample seriesIndex\n    // and dataIndex. And also used in the tooltipView trigger.\n    point = findPointFromSeries({\n      seriesIndex: finder.seriesIndex,\n      // Do not use dataIndexInside from other ec instance.\n      // FIXME: auto detect it?\n      dataIndex: finder.dataIndex\n    }, ecModel).point;\n  }\n\n  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n  // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n  // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n  // and dataIndex.\n\n  var inputAxesInfo = finder.axesInfo;\n  var axesInfo = coordSysAxesInfo.axesInfo;\n  var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n  var outputFinder = {};\n  var showValueMap = {};\n  var dataByCoordSys = {\n    list: [],\n    map: {}\n  };\n  var updaters = {\n    showPointer: curry(showPointer, showValueMap),\n    showTooltip: curry(showTooltip, dataByCoordSys)\n  }; // Process for triggered axes.\n\n  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n    // If a point given, it must be contained by the coordinate system.\n    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n      var axis = axisInfo.axis;\n      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.\n\n      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n        var val = inputAxisInfo && inputAxisInfo.value;\n\n        if (val == null && !isIllegalPoint) {\n          val = axis.pointToData(point);\n        }\n\n        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n      }\n    });\n  }); // Process for linked axes.\n\n  var linkTriggers = {};\n  each(axesInfo, function (tarAxisInfo, tarKey) {\n    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.\n\n    if (linkGroup && !showValueMap[tarKey]) {\n      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.\n\n        if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n          var val = srcValItem.value;\n          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));\n          linkTriggers[tarAxisInfo.key] = val;\n        }\n      });\n    }\n  });\n  each(linkTriggers, function (val, tarKey) {\n    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n  });\n  updateModelActually(showValueMap, axesInfo, outputFinder);\n  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n  dispatchHighDownActually(axesInfo, dispatchAction, api);\n  return outputFinder;\n}\n\nfunction processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n  var axis = axisInfo.axis;\n\n  if (axis.scale.isBlank() || !axis.containData(newValue)) {\n    return;\n  }\n\n  if (!axisInfo.involveSeries) {\n    updaters.showPointer(axisInfo, newValue);\n    return;\n  } // Heavy calculation. So put it after axis.containData checking.\n\n\n  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n  var payloadBatch = payloadInfo.payloadBatch;\n  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.\n  // By defualt use the first involved series data as a sample to connect.\n\n  if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n    zrUtil.extend(outputFinder, payloadBatch[0]);\n  } // If no linkSource input, this process is for collecting link\n  // target, where snap should not be accepted.\n\n\n  if (!dontSnap && axisInfo.snap) {\n    if (axis.containData(snapToValue) && snapToValue != null) {\n      newValue = snapToValue;\n    }\n  }\n\n  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be\n  // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n\n  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n}\n\nfunction buildPayloadsBySeries(value, axisInfo) {\n  var axis = axisInfo.axis;\n  var dim = axis.dim;\n  var snapToValue = value;\n  var payloadBatch = [];\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n  each(axisInfo.seriesModels, function (series, idx) {\n    var dataDim = series.getData().mapDimension(dim, true);\n    var seriesNestestValue;\n    var dataIndices;\n\n    if (series.getAxisTooltipData) {\n      var result = series.getAxisTooltipData(dataDim, value, axis);\n      dataIndices = result.dataIndices;\n      seriesNestestValue = result.nestestValue;\n    } else {\n      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex\n      // when data length is not same.\n      // false,\n      axis.type === 'category' ? 0.5 : null);\n\n      if (!dataIndices.length) {\n        return;\n      }\n\n      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n    }\n\n    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n      return;\n    }\n\n    var diff = value - seriesNestestValue;\n    var dist = Math.abs(diff); // Consider category case\n\n    if (dist <= minDist) {\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        snapToValue = seriesNestestValue;\n        payloadBatch.length = 0;\n      }\n\n      each(dataIndices, function (dataIndex) {\n        payloadBatch.push({\n          seriesIndex: series.seriesIndex,\n          dataIndexInside: dataIndex,\n          dataIndex: series.getData().getRawIndex(dataIndex)\n        });\n      });\n    }\n  });\n  return {\n    payloadBatch: payloadBatch,\n    snapToValue: snapToValue\n  };\n}\n\nfunction showPointer(showValueMap, axisInfo, value, payloadBatch) {\n  showValueMap[axisInfo.key] = {\n    value: value,\n    payloadBatch: payloadBatch\n  };\n}\n\nfunction showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n  var payloadBatch = payloadInfo.payloadBatch;\n  var axis = axisInfo.axis;\n  var axisModel = axis.model;\n  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,\n  // whose length will be used to judge whether dispatch action.\n\n  if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n    return;\n  }\n\n  var coordSysModel = axisInfo.coordSys.model;\n  var coordSysKey = modelHelper.makeKey(coordSysModel);\n  var coordSysItem = dataByCoordSys.map[coordSysKey];\n\n  if (!coordSysItem) {\n    coordSysItem = dataByCoordSys.map[coordSysKey] = {\n      coordSysId: coordSysModel.id,\n      coordSysIndex: coordSysModel.componentIndex,\n      coordSysType: coordSysModel.type,\n      coordSysMainType: coordSysModel.mainType,\n      dataByAxis: []\n    };\n    dataByCoordSys.list.push(coordSysItem);\n  }\n\n  coordSysItem.dataByAxis.push({\n    axisDim: axis.dim,\n    axisIndex: axisModel.componentIndex,\n    axisType: axisModel.type,\n    axisId: axisModel.id,\n    value: value,\n    // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n    // depends that all models have been updated. So it should not be performed\n    // here. Considering axisPointerModel used here is volatile, which is hard\n    // to be retrieve in TooltipView, we prepare parameters here.\n    valueLabelOpt: {\n      precision: axisPointerModel.get('label.precision'),\n      formatter: axisPointerModel.get('label.formatter')\n    },\n    seriesDataIndices: payloadBatch.slice()\n  });\n}\n\nfunction updateModelActually(showValueMap, axesInfo, outputFinder) {\n  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    var valItem = showValueMap[key];\n\n    if (valItem) {\n      !axisInfo.useHandle && (option.status = 'show');\n      option.value = valItem.value; // For label formatter param and highlight.\n\n      option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n    } // When always show (e.g., handle used), remain\n    // original value and status.\n    else {\n        // If hide, value still need to be set, consider\n        // click legend to toggle axis blank.\n        !axisInfo.useHandle && (option.status = 'hide');\n      } // If status is 'hide', should be no info in payload.\n\n\n    option.status === 'show' && outputAxesInfo.push({\n      axisDim: axisInfo.axis.dim,\n      axisIndex: axisInfo.axis.model.componentIndex,\n      value: option.value\n    });\n  });\n}\n\nfunction dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n  // Basic logic: If no showTip required, hideTip will be dispatched.\n  if (illegalPoint(point) || !dataByCoordSys.list.length) {\n    dispatchAction({\n      type: 'hideTip'\n    });\n    return;\n  } // In most case only one axis (or event one series is used). It is\n  // convinient to fetch payload.seriesIndex and payload.dataIndex\n  // dirtectly. So put the first seriesIndex and dataIndex of the first\n  // axis on the payload.\n\n\n  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n  dispatchAction({\n    type: 'showTip',\n    escapeConnect: true,\n    x: point[0],\n    y: point[1],\n    tooltipOption: payload.tooltipOption,\n    position: payload.position,\n    dataIndexInside: sampleItem.dataIndexInside,\n    dataIndex: sampleItem.dataIndex,\n    seriesIndex: sampleItem.seriesIndex,\n    dataByCoordSys: dataByCoordSys.list\n  });\n}\n\nfunction dispatchHighDownActually(axesInfo, dispatchAction, api) {\n  // FIXME\n  // highlight status modification shoule be a stage of main process?\n  // (Consider confilct (e.g., legend and axisPointer) and setOption)\n  var zr = api.getZr();\n  var highDownKey = 'axisPointerLastHighlights';\n  var lastHighlights = inner(zr)[highDownKey] || {};\n  var newHighlights = inner(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.\n  // Build hash map and remove duplicate incidentally.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n      newHighlights[key] = batchItem;\n    });\n  }); // Diff.\n\n  var toHighlight = [];\n  var toDownplay = [];\n  zrUtil.each(lastHighlights, function (batchItem, key) {\n    !newHighlights[key] && toDownplay.push(batchItem);\n  });\n  zrUtil.each(newHighlights, function (batchItem, key) {\n    !lastHighlights[key] && toHighlight.push(batchItem);\n  });\n  toDownplay.length && api.dispatchAction({\n    type: 'downplay',\n    escapeConnect: true,\n    batch: toDownplay\n  });\n  toHighlight.length && api.dispatchAction({\n    type: 'highlight',\n    escapeConnect: true,\n    batch: toHighlight\n  });\n}\n\nfunction findInputAxisInfo(inputAxesInfo, axisInfo) {\n  for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n    var inputAxisInfo = inputAxesInfo[i];\n\n    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {\n      return inputAxisInfo;\n    }\n  }\n}\n\nfunction makeMapperParam(axisInfo) {\n  var axisModel = axisInfo.axis.model;\n  var item = {};\n  var dim = item.axisDim = axisInfo.axis.dim;\n  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n  item.axisName = item[dim + 'AxisName'] = axisModel.name;\n  item.axisId = item[dim + 'AxisId'] = axisModel.id;\n  return item;\n}\n\nfunction illegalPoint(point) {\n  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 202:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisPointerModel = echarts.extendComponentModel({\n  type: 'axisPointer',\n  coordSysAxesInfo: null,\n  defaultOption: {\n    // 'auto' means that show when triggered by tooltip or handle.\n    show: 'auto',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: null,\n    // set default in AxisPonterView.js\n    zlevel: 0,\n    z: 50,\n    type: 'line',\n    // axispointer triggered by tootip determine snap automatically,\n    // see `modelHelper`.\n    snap: false,\n    triggerTooltip: true,\n    value: null,\n    status: null,\n    // Init value depends on whether handle is used.\n    // [group0, group1, ...]\n    // Each group can be: {\n    //      mapper: function () {},\n    //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n    //      xAxisId: ...,\n    //      yAxisName: ...,\n    //      angleAxisIndex: ...\n    // }\n    // mapper: can be ignored.\n    //      input: {axisInfo, value}\n    //      output: {axisInfo, value}\n    link: [],\n    // Do not set 'auto' here, otherwise global animation: false\n    // will not effect at this axispointer.\n    animation: null,\n    animationDurationUpdate: 200,\n    lineStyle: {\n      color: '#aaa',\n      width: 1,\n      type: 'solid'\n    },\n    shadowStyle: {\n      color: 'rgba(150,150,150,0.3)'\n    },\n    label: {\n      show: true,\n      formatter: null,\n      // string | Function\n      precision: 'auto',\n      // Or a number like 0, 1, 2 ...\n      margin: 3,\n      color: '#fff',\n      padding: [5, 7, 5, 7],\n      backgroundColor: 'auto',\n      // default: axis line color\n      borderColor: null,\n      borderWidth: 0,\n      shadowBlur: 3,\n      shadowColor: '#aaa' // Considering applicability, common style should\n      // better not have shadowOffset.\n      // shadowOffsetX: 0,\n      // shadowOffsetY: 2\n\n    },\n    handle: {\n      show: false,\n      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',\n      // jshint ignore:line\n      size: 45,\n      // handle margin is from symbol center to axis, which is stable when circular move.\n      margin: 50,\n      // color: '#1b8bbd'\n      // color: '#2f4554'\n      color: '#333',\n      shadowBlur: 3,\n      shadowColor: '#aaa',\n      shadowOffsetX: 0,\n      shadowOffsetY: 2,\n      // For mobile performance\n      throttle: 40\n    }\n  }\n});\nvar _default = AxisPointerModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 203:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar globalListener = __webpack_require__(187);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisPointerView = echarts.extendComponentView({\n  type: 'axisPointer',\n  render: function (globalAxisPointerModel, ecModel, api) {\n    var globalTooltipModel = ecModel.getComponent('tooltip');\n    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable\n    // AxisPointerView to be independent to Tooltip.\n\n    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {\n        dispatchAction({\n          type: 'updateAxisPointer',\n          currTrigger: currTrigger,\n          x: e && e.offsetX,\n          y: e && e.offsetY\n        });\n      }\n    });\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    globalListener.unregister(api.getZr(), 'axisPointer');\n    AxisPointerView.superApply(this._model, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    globalListener.unregister('axisPointer', api);\n    AxisPointerView.superApply(this._model, 'dispose', arguments);\n  }\n});\nvar _default = AxisPointerView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 204:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = echarts.extendComponentModel({\n  type: 'tooltip',\n  dependencies: ['axisPointer'],\n  defaultOption: {\n    zlevel: 0,\n    z: 8,\n    show: true,\n    // tooltip\n    showContent: true,\n    // 'trigger' only works on coordinate system.\n    // 'item' | 'axis' | 'none'\n    trigger: 'item',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: 'mousemove|click',\n    alwaysShowContent: false,\n    displayMode: 'single',\n    // 'single' | 'multipleByCoordSys'\n    //  {Array} | {Function}\n    // position: null\n    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n    // align: null,\n    // verticalAlign: null,\n    //  content  viewRect  false \n    confine: false,\n    // {string}Template  {Function}\n    // formatter: null\n    showDelay: 0,\n    // ms\n    hideDelay: 100,\n    // s\n    transitionDuration: 0.4,\n    enterable: false,\n    // 0.7\n    backgroundColor: 'rgba(50,50,50,0.7)',\n    // \n    borderColor: '#333',\n    // px4\n    borderRadius: 4,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // Extra css text\n    extraCssText: '',\n    // \n    axisPointer: {\n      // \n      // 'line' | 'shadow' | 'cross'\n      type: 'line',\n      // type  line  tooltip line \n      //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n      //  'auto' category  x \n      //  angle \n      axis: 'auto',\n      animation: 'auto',\n      animationDurationUpdate: 200,\n      animationEasingUpdate: 'exponentialOut',\n      crossStyle: {\n        color: '#999',\n        width: 1,\n        type: 'dashed',\n        // TODO formatter\n        textStyle: {} // lineStyle and shadowStyle should not be specified here,\n        // otherwise it will always override those styles on option.axisPointer.\n\n      }\n    },\n    textStyle: {\n      color: '#fff',\n      fontSize: 14\n    }\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 205:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar env = __webpack_require__(7);\n\nvar TooltipContent = __webpack_require__(206);\n\nvar formatUtil = __webpack_require__(9);\n\nvar numberUtil = __webpack_require__(5);\n\nvar graphic = __webpack_require__(11);\n\nvar findPointFromSeries = __webpack_require__(186);\n\nvar layoutUtil = __webpack_require__(29);\n\nvar Model = __webpack_require__(12);\n\nvar globalListener = __webpack_require__(187);\n\nvar axisHelper = __webpack_require__(30);\n\nvar axisPointerViewHelper = __webpack_require__(185);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar bind = zrUtil.bind;\nvar each = zrUtil.each;\nvar parsePercent = numberUtil.parsePercent;\nvar proxyRect = new graphic.Rect({\n  shape: {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  }\n});\n\nvar _default = echarts.extendComponentView({\n  type: 'tooltip',\n  init: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    var tooltipContent = new TooltipContent(api.getDom(), api);\n    this._tooltipContent = tooltipContent;\n  },\n  render: function (tooltipModel, ecModel, api) {\n    if (env.node || env.wxa) {\n      return;\n    } // Reset\n\n\n    this.group.removeAll();\n    /**\n     * @private\n     * @type {module:echarts/component/tooltip/TooltipModel}\n     */\n\n    this._tooltipModel = tooltipModel;\n    /**\n     * @private\n     * @type {module:echarts/model/Global}\n     */\n\n    this._ecModel = ecModel;\n    /**\n     * @private\n     * @type {module:echarts/ExtensionAPI}\n     */\n\n    this._api = api;\n    /**\n     * Should be cleaned when render.\n     * @private\n     * @type {Array.<Array.<Object>>}\n     */\n\n    this._lastDataByCoordSys = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n    var tooltipContent = this._tooltipContent;\n    tooltipContent.update();\n    tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n    this._initGlobalListener();\n\n    this._keepShow();\n  },\n  _initGlobalListener: function () {\n    var tooltipModel = this._tooltipModel;\n    var triggerOn = tooltipModel.get('triggerOn');\n    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none') {\n        if (triggerOn.indexOf(currTrigger) >= 0) {\n          this._tryShow(e, dispatchAction);\n        } else if (currTrigger === 'leave') {\n          this._hide(dispatchAction);\n        }\n      }\n    }, this));\n  },\n  _keepShow: function () {\n    var tooltipModel = this._tooltipModel;\n    var ecModel = this._ecModel;\n    var api = this._api; // Try to keep the tooltip show when refreshing\n\n    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,\n    // self.manuallyShowTip({x, y}) might cause tooltip hide,\n    // which is not expected.\n    && tooltipModel.get('triggerOn') !== 'none') {\n      var self = this;\n      clearTimeout(this._refreshUpdateTimeout);\n      this._refreshUpdateTimeout = setTimeout(function () {\n        // Show tip next tick after other charts are rendered\n        // In case highlight action has wrong result\n        // FIXME\n        self.manuallyShowTip(tooltipModel, ecModel, api, {\n          x: self._lastX,\n          y: self._lastY\n        });\n      });\n    }\n  },\n\n  /**\n   * Show tip manually by\n   * dispatchAction({\n   *     type: 'showTip',\n   *     x: 10,\n   *     y: 10\n   * });\n   * Or\n   * dispatchAction({\n   *      type: 'showTip',\n   *      seriesIndex: 0,\n   *      dataIndex or dataIndexInside or name\n   * });\n   *\n   *  TODO Batch\n   */\n  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n    if (payload.from === this.uid || env.node) {\n      return;\n    }\n\n    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket\n\n    this._ticket = ''; // When triggered from axisPointer.\n\n    var dataByCoordSys = payload.dataByCoordSys;\n\n    if (payload.tooltip && payload.x != null && payload.y != null) {\n      var el = proxyRect;\n      el.position = [payload.x, payload.y];\n      el.update();\n      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        target: el\n      }, dispatchAction);\n    } else if (dataByCoordSys) {\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        event: {},\n        dataByCoordSys: payload.dataByCoordSys,\n        tooltipOption: payload.tooltipOption\n      }, dispatchAction);\n    } else if (payload.seriesIndex != null) {\n      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n        return;\n      }\n\n      var pointInfo = findPointFromSeries(payload, ecModel);\n      var cx = pointInfo.point[0];\n      var cy = pointInfo.point[1];\n\n      if (cx != null && cy != null) {\n        this._tryShow({\n          offsetX: cx,\n          offsetY: cy,\n          position: payload.position,\n          target: pointInfo.el,\n          event: {}\n        }, dispatchAction);\n      }\n    } else if (payload.x != null && payload.y != null) {\n      // FIXME\n      // should wrap dispatchAction like `axisPointer/globalListener` ?\n      api.dispatchAction({\n        type: 'updateAxisPointer',\n        x: payload.x,\n        y: payload.y\n      });\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        target: api.getZr().findHover(payload.x, payload.y).target,\n        event: {}\n      }, dispatchAction);\n    }\n  },\n  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n    var tooltipContent = this._tooltipContent;\n\n    if (!this._alwaysShowContent && this._tooltipModel) {\n      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n    }\n\n    this._lastX = this._lastY = null;\n\n    if (payload.from !== this.uid) {\n      this._hide(makeDispatchAction(payload, api));\n    }\n  },\n  // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n  // and tooltip.\n  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n    var seriesIndex = payload.seriesIndex;\n    var dataIndex = payload.dataIndex;\n    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n      return;\n    }\n\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n    if (!seriesModel) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);\n\n    if (tooltipModel.get('trigger') !== 'axis') {\n      return;\n    }\n\n    api.dispatchAction({\n      type: 'updateAxisPointer',\n      seriesIndex: seriesIndex,\n      dataIndex: dataIndex,\n      position: payload.position\n    });\n    return true;\n  },\n  _tryShow: function (e, dispatchAction) {\n    var el = e.target;\n    var tooltipModel = this._tooltipModel;\n\n    if (!tooltipModel) {\n      return;\n    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\n\n    this._lastX = e.offsetX;\n    this._lastY = e.offsetY;\n    var dataByCoordSys = e.dataByCoordSys;\n\n    if (dataByCoordSys && dataByCoordSys.length) {\n      this._showAxisTooltip(dataByCoordSys, e);\n    } // Always show item tooltip if mouse is on the element with dataIndex\n    else if (el && el.dataIndex != null) {\n        this._lastDataByCoordSys = null;\n\n        this._showSeriesItemTooltip(e, el, dispatchAction);\n      } // Tooltip provided directly. Like legend.\n      else if (el && el.tooltip) {\n          this._lastDataByCoordSys = null;\n\n          this._showComponentItemTooltip(e, el, dispatchAction);\n        } else {\n          this._lastDataByCoordSys = null;\n\n          this._hide(dispatchAction);\n        }\n  },\n  _showOrMove: function (tooltipModel, cb) {\n    // showDelay is used in this case: tooltip.enterable is set\n    // as true. User intent to move mouse into tooltip and click\n    // something. `showDelay` makes it easyer to enter the content\n    // but tooltip do not move immediately.\n    var delay = tooltipModel.get('showDelay');\n    cb = zrUtil.bind(cb, this);\n    clearTimeout(this._showTimout);\n    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();\n  },\n  _showAxisTooltip: function (dataByCoordSys, e) {\n    var ecModel = this._ecModel;\n    var globalTooltipModel = this._tooltipModel;\n    var point = [e.offsetX, e.offsetY];\n    var singleDefaultHTML = [];\n    var singleParamsList = [];\n    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);\n    each(dataByCoordSys, function (itemCoordSys) {\n      // var coordParamList = [];\n      // var coordDefaultHTML = [];\n      // var coordTooltipModel = buildTooltipModel([\n      //     e.tooltipOption,\n      //     itemCoordSys.tooltipOption,\n      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n      //     globalTooltipModel\n      // ]);\n      // var displayMode = coordTooltipModel.get('displayMode');\n      // var paramsList = displayMode === 'single' ? singleParamsList : [];\n      each(itemCoordSys.dataByAxis, function (item) {\n        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n        var axisValue = item.value;\n        var seriesDefaultHTML = [];\n\n        if (!axisModel || axisValue == null) {\n          return;\n        }\n\n        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);\n        zrUtil.each(item.seriesDataIndices, function (idxItem) {\n          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n          var dataIndex = idxItem.dataIndexInside;\n          var dataParams = series && series.getDataParams(dataIndex);\n          dataParams.axisDim = item.axisDim;\n          dataParams.axisIndex = item.axisIndex;\n          dataParams.axisType = item.axisType;\n          dataParams.axisId = item.axisId;\n          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n          dataParams.axisValueLabel = valueLabel;\n\n          if (dataParams) {\n            singleParamsList.push(dataParams);\n            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n          }\n        }); // Default tooltip content\n        // FIXME\n        // (1) shold be the first data which has name?\n        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\n        var firstLine = valueLabel;\n        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));\n      });\n    }, this); // In most case, the second axis is shown upper than the first one.\n\n    singleDefaultHTML.reverse();\n    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n    var positionExpr = e.position;\n\n    this._showOrMove(singleTooltipModel, function () {\n      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);\n      } else {\n        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);\n      }\n    }); // Do not trigger events here, because this branch only be entered\n    // from dispatchAction.\n\n  },\n  _showSeriesItemTooltip: function (e, el, dispatchAction) {\n    var ecModel = this._ecModel; // Use dataModel in element if possible\n    // Used when mouseover on a element like markPoint or edge\n    // In which case, the data is not main data in series.\n\n    var seriesIndex = el.seriesIndex;\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.\n\n    var dataModel = el.dataModel || seriesModel;\n    var dataIndex = el.dataIndex;\n    var dataType = el.dataType;\n    var data = dataModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);\n    var tooltipTrigger = tooltipModel.get('trigger');\n\n    if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n      return;\n    }\n\n    var params = dataModel.getDataParams(dataIndex, dataType);\n    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n    this._showOrMove(tooltipModel, function () {\n      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);\n    }); // FIXME\n    // duplicated showtip if manuallyShowTip is called from dispatchAction.\n\n\n    dispatchAction({\n      type: 'showTip',\n      dataIndexInside: dataIndex,\n      dataIndex: data.getRawIndex(dataIndex),\n      seriesIndex: seriesIndex,\n      from: this.uid\n    });\n  },\n  _showComponentItemTooltip: function (e, el, dispatchAction) {\n    var tooltipOpt = el.tooltip;\n\n    if (typeof tooltipOpt === 'string') {\n      var content = tooltipOpt;\n      tooltipOpt = {\n        content: content,\n        // Fixed formatter\n        formatter: content\n      };\n    }\n\n    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n    var defaultHtml = subTooltipModel.get('content');\n    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`\n    // only works on cooridinate system. In fact, we have not found case\n    // that requires setting `trigger` nothing on component yet.\n\n    this._showOrMove(subTooltipModel, function () {\n      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);\n    }); // If not dispatch showTip, tip may be hide triggered by axis.\n\n\n    dispatchAction({\n      type: 'showTip',\n      from: this.uid\n    });\n  },\n  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\n    // Reset ticket\n    this._ticket = '';\n\n    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n      return;\n    }\n\n    var tooltipContent = this._tooltipContent;\n    var formatter = tooltipModel.get('formatter');\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var html = defaultHtml;\n\n    if (formatter && typeof formatter === 'string') {\n      html = formatUtil.formatTpl(formatter, params, true);\n    } else if (typeof formatter === 'function') {\n      var callback = bind(function (cbTicket, html) {\n        if (cbTicket === this._ticket) {\n          tooltipContent.setContent(html);\n\n          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n        }\n      }, this);\n      this._ticket = asyncTicket;\n      html = formatter(params, asyncTicket, callback);\n    }\n\n    tooltipContent.setContent(html);\n    tooltipContent.show(tooltipModel);\n\n    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n  },\n\n  /**\n   * @param  {string|Function|Array.<number>|Object} positionExpr\n   * @param  {number} x Mouse x\n   * @param  {number} y Mouse y\n   * @param  {boolean} confine Whether confine tooltip content in view rect.\n   * @param  {Object|<Array.<Object>} params\n   * @param  {module:zrender/Element} el target element\n   * @param  {module:echarts/ExtensionAPI} api\n   * @return {Array.<number>}\n   */\n  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n    var viewWidth = this._api.getWidth();\n\n    var viewHeight = this._api.getHeight();\n\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var contentSize = content.getSize();\n    var align = tooltipModel.get('align');\n    var vAlign = tooltipModel.get('verticalAlign');\n    var rect = el && el.getBoundingRect().clone();\n    el && rect.applyTransform(el.transform);\n\n    if (typeof positionExpr === 'function') {\n      // Callback of position can be an array or a string specify the position\n      positionExpr = positionExpr([x, y], params, content.el, rect, {\n        viewSize: [viewWidth, viewHeight],\n        contentSize: contentSize.slice()\n      });\n    }\n\n    if (zrUtil.isArray(positionExpr)) {\n      x = parsePercent(positionExpr[0], viewWidth);\n      y = parsePercent(positionExpr[1], viewHeight);\n    } else if (zrUtil.isObject(positionExpr)) {\n      positionExpr.width = contentSize[0];\n      positionExpr.height = contentSize[1];\n      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {\n        width: viewWidth,\n        height: viewHeight\n      });\n      x = layoutRect.x;\n      y = layoutRect.y;\n      align = null; // When positionExpr is left/top/right/bottom,\n      // align and verticalAlign will not work.\n\n      vAlign = null;\n    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n    else if (typeof positionExpr === 'string' && el) {\n        var pos = calcTooltipPosition(positionExpr, rect, contentSize);\n        x = pos[0];\n        y = pos[1];\n      } else {\n        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);\n        x = pos[0];\n        y = pos[1];\n      }\n\n    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n    if (tooltipModel.get('confine')) {\n      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);\n      x = pos[0];\n      y = pos[1];\n    }\n\n    content.moveTo(x, y);\n  },\n  // FIXME\n  // Should we remove this but leave this to user?\n  _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n    var lastCoordSys = this._lastDataByCoordSys;\n    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;\n    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n        var thisItem = thisDataByAxis[indexAxis] || {};\n        var lastIndices = lastItem.seriesDataIndices || [];\n        var newIndices = thisItem.seriesDataIndices || [];\n        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;\n        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n          var newIdxItem = newIndices[j];\n          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n        });\n      });\n    });\n    this._lastDataByCoordSys = dataByCoordSys;\n    return !!contentNotChanged;\n  },\n  _hide: function (dispatchAction) {\n    // Do not directly hideLater here, because this behavior may be prevented\n    // in dispatchAction when showTip is dispatched.\n    // FIXME\n    // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n    this._lastDataByCoordSys = null;\n    dispatchAction({\n      type: 'hideTip',\n      from: this.uid\n    });\n  },\n  dispose: function (ecModel, api) {\n    if (env.node || env.wxa) {\n      return;\n    }\n\n    this._tooltipContent.hide();\n\n    globalListener.unregister('itemTooltip', api);\n  }\n});\n/**\n * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n * From top to bottom. (the last one should be globalTooltipModel);\n */\n\n\nfunction buildTooltipModel(modelCascade) {\n  var resultModel = modelCascade.pop();\n\n  while (modelCascade.length) {\n    var tooltipOpt = modelCascade.pop();\n\n    if (tooltipOpt) {\n      if (Model.isInstance(tooltipOpt)) {\n        tooltipOpt = tooltipOpt.get('tooltip', true);\n      } // In each data item tooltip can be simply write:\n      // {\n      //  value: 10,\n      //  tooltip: 'Something you need to know'\n      // }\n\n\n      if (typeof tooltipOpt === 'string') {\n        tooltipOpt = {\n          formatter: tooltipOpt\n        };\n      }\n\n      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n    }\n  }\n\n  return resultModel;\n}\n\nfunction makeDispatchAction(payload, api) {\n  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n}\n\nfunction refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n\n  if (gapH != null) {\n    if (x + width + gapH > viewWidth) {\n      x -= width + gapH;\n    } else {\n      x += gapH;\n    }\n  }\n\n  if (gapV != null) {\n    if (y + height + gapV > viewHeight) {\n      y -= height + gapV;\n    } else {\n      y += gapV;\n    }\n  }\n\n  return [x, y];\n}\n\nfunction confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n  x = Math.min(x + width, viewWidth) - width;\n  y = Math.min(y + height, viewHeight) - height;\n  x = Math.max(x, 0);\n  y = Math.max(y, 0);\n  return [x, y];\n}\n\nfunction getOuterSize(el) {\n  var width = el.clientWidth;\n  var height = el.clientHeight; // Consider browser compatibility.\n  // IE8 does not support getComputedStyle.\n\n  if (document.defaultView && document.defaultView.getComputedStyle) {\n    var stl = document.defaultView.getComputedStyle(el);\n\n    if (stl) {\n      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nfunction calcTooltipPosition(position, rect, contentSize) {\n  var domWidth = contentSize[0];\n  var domHeight = contentSize[1];\n  var gap = 5;\n  var x = 0;\n  var y = 0;\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n\n  switch (position) {\n    case 'inside':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'top':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y - domHeight - gap;\n      break;\n\n    case 'bottom':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight + gap;\n      break;\n\n    case 'left':\n      x = rect.x - domWidth - gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'right':\n      x = rect.x + rectWidth + gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n  }\n\n  return [x, y];\n}\n\nfunction isCenterAlign(align) {\n  return align === 'center' || align === 'middle';\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 206:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar zrColor = __webpack_require__(19);\n\nvar eventUtil = __webpack_require__(31);\n\nvar env = __webpack_require__(7);\n\nvar formatUtil = __webpack_require__(9);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar toCamelCase = formatUtil.toCamelCase;\nvar vendors = ['', '-webkit-', '-moz-', '-o-'];\nvar gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n/**\n * @param {number} duration\n * @return {string}\n * @inner\n */\n\nfunction assembleTransition(duration) {\n  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;\n  return zrUtil.map(vendors, function (vendorPrefix) {\n    return vendorPrefix + 'transition:' + transitionText;\n  }).join(';');\n}\n/**\n * @param {Object} textStyle\n * @return {string}\n * @inner\n */\n\n\nfunction assembleFont(textStyleModel) {\n  var cssText = [];\n  var fontSize = textStyleModel.get('fontSize');\n  var color = textStyleModel.getTextColor();\n  color && cssText.push('color:' + color);\n  cssText.push('font:' + textStyleModel.getFont());\n  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n  each(['decoration', 'align'], function (name) {\n    var val = textStyleModel.get(name);\n    val && cssText.push('text-' + name + ':' + val);\n  });\n  return cssText.join(';');\n}\n/**\n * @param {Object} tooltipModel\n * @return {string}\n * @inner\n */\n\n\nfunction assembleCssText(tooltipModel) {\n  var cssText = [];\n  var transitionDuration = tooltipModel.get('transitionDuration');\n  var backgroundColor = tooltipModel.get('backgroundColor');\n  var textStyleModel = tooltipModel.getModel('textStyle');\n  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.\n\n  transitionDuration && cssText.push(assembleTransition(transitionDuration));\n\n  if (backgroundColor) {\n    if (env.canvasSupported) {\n      cssText.push('background-Color:' + backgroundColor);\n    } else {\n      // for ie\n      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));\n      cssText.push('filter:alpha(opacity=70)');\n    }\n  } // Border style\n\n\n  each(['width', 'color', 'radius'], function (name) {\n    var borderName = 'border-' + name;\n    var camelCase = toCamelCase(borderName);\n    var val = tooltipModel.get(camelCase);\n    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n  }); // Text style\n\n  cssText.push(assembleFont(textStyleModel)); // Padding\n\n  if (padding != null) {\n    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n  }\n\n  return cssText.join(';') + ';';\n}\n/**\n * @alias module:echarts/component/tooltip/TooltipContent\n * @constructor\n */\n\n\nfunction TooltipContent(container, api) {\n  if (env.wxa) {\n    return null;\n  }\n\n  var el = document.createElement('div');\n  var zr = this._zr = api.getZr();\n  this.el = el;\n  this._x = api.getWidth() / 2;\n  this._y = api.getHeight() / 2;\n  container.appendChild(el);\n  this._container = container;\n  this._show = false;\n  /**\n   * @private\n   */\n\n  this._hideTimeout;\n  var self = this;\n\n  el.onmouseenter = function () {\n    // clear the timeout in hideLater and keep showing tooltip\n    if (self._enterable) {\n      clearTimeout(self._hideTimeout);\n      self._show = true;\n    }\n\n    self._inContent = true;\n  };\n\n  el.onmousemove = function (e) {\n    e = e || window.event;\n\n    if (!self._enterable) {\n      // Try trigger zrender event to avoid mouse\n      // in and out shape too frequently\n      var handler = zr.handler;\n      eventUtil.normalizeEvent(container, e, true);\n      handler.dispatch('mousemove', e);\n    }\n  };\n\n  el.onmouseleave = function () {\n    if (self._enterable) {\n      if (self._show) {\n        self.hideLater(self._hideDelay);\n      }\n    }\n\n    self._inContent = false;\n  };\n}\n\nTooltipContent.prototype = {\n  constructor: TooltipContent,\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  _enterable: true,\n\n  /**\n   * Update when tooltip is rendered\n   */\n  update: function () {\n    // FIXME\n    // Move this logic to ec main?\n    var container = this._container;\n    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);\n    var domStyle = container.style;\n\n    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n      domStyle.position = 'relative';\n    } // Hide the tooltip\n    // PENDING\n    // this.hide();\n\n  },\n  show: function (tooltipModel) {\n    clearTimeout(this._hideTimeout);\n    var el = this.el;\n    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');\n    el.style.display = el.innerHTML ? 'block' : 'none';\n    this._show = true;\n  },\n  setContent: function (content) {\n    this.el.innerHTML = content == null ? '' : content;\n  },\n  setEnterable: function (enterable) {\n    this._enterable = enterable;\n  },\n  getSize: function () {\n    var el = this.el;\n    return [el.clientWidth, el.clientHeight];\n  },\n  moveTo: function (x, y) {\n    // xy should be based on canvas root. But tooltipContent is\n    // the sibling of canvas root. So padding of ec container\n    // should be considered here.\n    var zr = this._zr;\n    var viewportRootOffset;\n\n    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n      x += viewportRootOffset.offsetLeft;\n      y += viewportRootOffset.offsetTop;\n    }\n\n    var style = this.el.style;\n    style.left = x + 'px';\n    style.top = y + 'px';\n    this._x = x;\n    this._y = y;\n  },\n  hide: function () {\n    this.el.style.display = 'none';\n    this._show = false;\n  },\n  hideLater: function (time) {\n    if (this._show && !(this._inContent && this._enterable)) {\n      if (time) {\n        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times\n\n        this._show = false;\n        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n      } else {\n        this.hide();\n      }\n    }\n  },\n  isShow: function () {\n    return this._show;\n  }\n};\nvar _default = TooltipContent;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 209:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n__webpack_require__(210);\n\n__webpack_require__(215);\n\n__webpack_require__(211);\n\nvar legendFilter = __webpack_require__(216);\n\nvar Component = __webpack_require__(13);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n/***/ }),\n\n/***/ 210:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar Model = __webpack_require__(12);\n\nvar _model = __webpack_require__(1);\n\nvar isNameSpecified = _model.isNameSpecified;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // \n    zlevel: 0,\n    // \n    z: 4,\n    show: true,\n    // \n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // \n    // 'auto' | 'left' | 'right'\n    //  'auto',  x \n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // \n    borderColor: '#ccc',\n    borderRadius: 0,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // itempx10\n    // \n    itemGap: 10,\n    // \n    itemWidth: 25,\n    // \n    itemHeight: 14,\n    // \n    inactiveColor: '#ccc',\n    textStyle: {\n      // \n      color: '#333'\n    },\n    // formatter: '',\n    // \n    selectedMode: true,\n    // LEGEND.SELECTED\n    // selected: null,\n    // legend.dataitem\n    // data: [],\n    // Tooltip \n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 211:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar _symbol = __webpack_require__(77);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(11);\n\nvar _listComponent = __webpack_require__(212);\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = __webpack_require__(29);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    var excludeSeriesId = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);\n    });\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      } // Representitive series.\n\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api, excludeSeriesId));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode); // FIXME: consider different series has items with the same name.\n\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api, excludeSeriesId));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var symbolKeepAspect = legendModel.get('symbolKeepAspect');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend\n    symbolKeepAspect == null ? true : symbolKeepAspect)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend\n      symbolKeepAspect == null ? true : symbolKeepAspect));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 212:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _layout = __webpack_require__(29);\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = __webpack_require__(9);\n\nvar graphic = __webpack_require__(11);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n/***/ }),\n\n/***/ 215:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n/***/ }),\n\n/***/ 216:\n/***/ (function(module, exports) {\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 217:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(188);\n\n__webpack_require__(189);\n\n__webpack_require__(184);\n\n/***/ }),\n\n/***/ 218:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Cartesian = __webpack_require__(219);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, reserved, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  clampData: function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));\n    return out;\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 219:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 220:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Axis = __webpack_require__(81);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * Implemented in <module:echarts/coord/cartesian/Grid>.\n   * @return {Array.<module:echarts/coord/cartesian/Axis2D>}\n   *         If not on zero of other axis, return null/undefined.\n   *         If no axes, return an empty array.\n   */\n  getAxesOnZeroOf: null,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 221:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(193);\n\nvar ComponentModel = __webpack_require__(13);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid \n//  Cartesian2D \nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 222:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(193);\n\n__webpack_require__(223);\n\n/***/ }),\n\n/***/ 223:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(11);\n\nvar AxisBuilder = __webpack_require__(182);\n\nvar AxisView = __webpack_require__(183);\n\nvar cartesianAxisHelper = __webpack_require__(190);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n  remove: function () {\n    this._splitAreaColors = null;\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitAreaModel,\n      clamp: true\n    });\n\n    if (!ticksCoords.length) {\n      return;\n    } // For Making appropriate splitArea animation, the color and anid\n    // should be corresponding to previous one if possible.\n\n\n    var areaColorsLen = areaColors.length;\n    var lastSplitAreaColors = this._splitAreaColors;\n    var newSplitAreaColors = zrUtil.createHashMap();\n    var colorIndex = 0;\n\n    if (lastSplitAreaColors) {\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n        if (cIndex != null) {\n          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n          break;\n        }\n      }\n    }\n\n    var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prev;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n        prev = x + width;\n      } else {\n        x = gridRect.x;\n        y = prev;\n        width = gridRect.width;\n        height = tickCoord - y;\n        prev = y + height;\n      }\n\n      var tickValue = ticksCoords[i - 1].tickValue;\n      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: tickValue != null ? 'area_' + tickValue : null,\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      colorIndex = (colorIndex + 1) % areaColorsLen;\n    }\n\n    this._splitAreaColors = newSplitAreaColors;\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n/***/ }),\n\n/***/ 241:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(11);\n\nvar LineGroup = __webpack_require__(242);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/LineDraw\n */\n// import IncrementalDisplayable from 'zrender/src/graphic/IncrementalDisplayable';\n\n/**\n * @alias module:echarts/component/marker/LineDraw\n * @constructor\n */\nfunction LineDraw(ctor) {\n  this._ctor = ctor || LineGroup;\n  this.group = new graphic.Group();\n}\n\nvar lineDrawProto = LineDraw.prototype;\n\nlineDrawProto.isPersistent = function () {\n  return true;\n};\n/**\n * @param {module:echarts/data/List} lineData\n */\n\n\nlineDrawProto.updateData = function (lineData) {\n  var lineDraw = this;\n  var group = lineDraw.group;\n  var oldLineData = lineDraw._lineData;\n  lineDraw._lineData = lineData; // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldLineData) {\n    group.removeAll();\n  }\n\n  var seriesScope = makeSeriesScope(lineData);\n  lineData.diff(oldLineData).add(function (idx) {\n    doAdd(lineDraw, lineData, idx, seriesScope);\n  }).update(function (newIdx, oldIdx) {\n    doUpdate(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);\n  }).remove(function (idx) {\n    group.remove(oldLineData.getItemGraphicEl(idx));\n  }).execute();\n};\n\nfunction doAdd(lineDraw, lineData, idx, seriesScope) {\n  var itemLayout = lineData.getItemLayout(idx);\n\n  if (!lineNeedsDraw(itemLayout)) {\n    return;\n  }\n\n  var el = new lineDraw._ctor(lineData, idx, seriesScope);\n  lineData.setItemGraphicEl(idx, el);\n  lineDraw.group.add(el);\n}\n\nfunction doUpdate(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {\n  var itemEl = oldLineData.getItemGraphicEl(oldIdx);\n\n  if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {\n    lineDraw.group.remove(itemEl);\n    return;\n  }\n\n  if (!itemEl) {\n    itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);\n  } else {\n    itemEl.updateData(newLineData, newIdx, seriesScope);\n  }\n\n  newLineData.setItemGraphicEl(newIdx, itemEl);\n  lineDraw.group.add(itemEl);\n}\n\nlineDrawProto.updateLayout = function () {\n  var lineData = this._lineData; // Do not support update layout in incremental mode.\n\n  if (!lineData) {\n    return;\n  }\n\n  lineData.eachItemGraphicEl(function (el, idx) {\n    el.updateLayout(lineData, idx);\n  }, this);\n};\n\nlineDrawProto.incrementalPrepareUpdate = function (lineData) {\n  this._seriesScope = makeSeriesScope(lineData);\n  this._lineData = null;\n  this.group.removeAll();\n};\n\nlineDrawProto.incrementalUpdate = function (taskParams, lineData) {\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var itemLayout = lineData.getItemLayout(idx);\n\n    if (lineNeedsDraw(itemLayout)) {\n      var el = new this._ctor(lineData, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      this.group.add(el);\n      lineData.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction makeSeriesScope(lineData) {\n  var hostModel = lineData.hostModel;\n  return {\n    lineStyle: hostModel.getModel('lineStyle').getLineStyle(),\n    hoverLineStyle: hostModel.getModel('emphasis.lineStyle').getLineStyle(),\n    labelModel: hostModel.getModel('label'),\n    hoverLabelModel: hostModel.getModel('emphasis.label')\n  };\n}\n\nlineDrawProto.remove = function () {\n  this._clearIncremental();\n\n  this._incremental = null;\n  this.group.removeAll();\n};\n\nlineDrawProto._clearIncremental = function () {\n  var incremental = this._incremental;\n\n  if (incremental) {\n    incremental.clearDisplaybles();\n  }\n};\n\nfunction isPointNaN(pt) {\n  return isNaN(pt[0]) || isNaN(pt[1]);\n}\n\nfunction lineNeedsDraw(pts) {\n  return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n}\n\nvar _default = LineDraw;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 242:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar vector = __webpack_require__(2);\n\nvar symbolUtil = __webpack_require__(77);\n\nvar LinePath = __webpack_require__(264);\n\nvar graphic = __webpack_require__(11);\n\nvar _number = __webpack_require__(5);\n\nvar round = _number.round;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/Line\n */\nvar SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n\nfunction makeSymbolTypeKey(symbolCategory) {\n  return '_' + symbolCategory + 'Type';\n}\n/**\n * @inner\n */\n\n\nfunction createSymbol(name, lineData, idx) {\n  var color = lineData.getItemVisual(idx, 'color');\n  var symbolType = lineData.getItemVisual(idx, name);\n  var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n\n  if (!symbolType || symbolType === 'none') {\n    return;\n  }\n\n  if (!zrUtil.isArray(symbolSize)) {\n    symbolSize = [symbolSize, symbolSize];\n  }\n\n  var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);\n  symbolPath.name = name;\n  return symbolPath;\n}\n\nfunction createLine(points) {\n  var line = new LinePath({\n    name: 'line'\n  });\n  setLinePoints(line.shape, points);\n  return line;\n}\n\nfunction setLinePoints(targetShape, points) {\n  var p1 = points[0];\n  var p2 = points[1];\n  var cp1 = points[2];\n  targetShape.x1 = p1[0];\n  targetShape.y1 = p1[1];\n  targetShape.x2 = p2[0];\n  targetShape.y2 = p2[1];\n  targetShape.percent = 1;\n\n  if (cp1) {\n    targetShape.cpx1 = cp1[0];\n    targetShape.cpy1 = cp1[1];\n  } else {\n    targetShape.cpx1 = NaN;\n    targetShape.cpy1 = NaN;\n  }\n}\n\nfunction updateSymbolAndLabelBeforeLineUpdate() {\n  var lineGroup = this;\n  var symbolFrom = lineGroup.childOfName('fromSymbol');\n  var symbolTo = lineGroup.childOfName('toSymbol');\n  var label = lineGroup.childOfName('label'); // Quick reject\n\n  if (!symbolFrom && !symbolTo && label.ignore) {\n    return;\n  }\n\n  var invScale = 1;\n  var parentNode = this.parent;\n\n  while (parentNode) {\n    if (parentNode.scale) {\n      invScale /= parentNode.scale[0];\n    }\n\n    parentNode = parentNode.parent;\n  }\n\n  var line = lineGroup.childOfName('line'); // If line not changed\n  // FIXME Parent scale changed\n\n  if (!this.__dirty && !line.__dirty) {\n    return;\n  }\n\n  var percent = line.shape.percent;\n  var fromPos = line.pointAt(0);\n  var toPos = line.pointAt(percent);\n  var d = vector.sub([], toPos, fromPos);\n  vector.normalize(d, d);\n\n  if (symbolFrom) {\n    symbolFrom.attr('position', fromPos);\n    var tangent = line.tangentAt(0);\n    symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n    symbolFrom.attr('scale', [invScale * percent, invScale * percent]);\n  }\n\n  if (symbolTo) {\n    symbolTo.attr('position', toPos);\n    var tangent = line.tangentAt(1);\n    symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n    symbolTo.attr('scale', [invScale * percent, invScale * percent]);\n  }\n\n  if (!label.ignore) {\n    label.attr('position', toPos);\n    var textPosition;\n    var textAlign;\n    var textVerticalAlign;\n    var distance = 5 * invScale; // End\n\n    if (label.__position === 'end') {\n      textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];\n      textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';\n      textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';\n    } // Middle\n    else if (label.__position === 'middle') {\n        var halfPercent = percent / 2;\n        var tangent = line.tangentAt(halfPercent);\n        var n = [tangent[1], -tangent[0]];\n        var cp = line.pointAt(halfPercent);\n\n        if (n[1] > 0) {\n          n[0] = -n[0];\n          n[1] = -n[1];\n        }\n\n        textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];\n        textAlign = 'center';\n        textVerticalAlign = 'bottom';\n        var rotation = -Math.atan2(tangent[1], tangent[0]);\n\n        if (toPos[0] < fromPos[0]) {\n          rotation = Math.PI + rotation;\n        }\n\n        label.attr('rotation', rotation);\n      } // Start\n      else {\n          textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];\n          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';\n          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';\n        }\n\n    label.attr({\n      style: {\n        // Use the user specified text align and baseline first\n        textVerticalAlign: label.__verticalAlign || textVerticalAlign,\n        textAlign: label.__textAlign || textAlign\n      },\n      position: textPosition,\n      scale: [invScale, invScale]\n    });\n  }\n}\n/**\n * @constructor\n * @extends {module:zrender/graphic/Group}\n * @alias {module:echarts/chart/helper/Line}\n */\n\n\nfunction Line(lineData, idx, seriesScope) {\n  graphic.Group.call(this);\n\n  this._createLine(lineData, idx, seriesScope);\n}\n\nvar lineProto = Line.prototype; // Update symbol position and rotation\n\nlineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;\n\nlineProto._createLine = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var linePoints = lineData.getItemLayout(idx);\n  var line = createLine(linePoints);\n  line.shape.percent = 0;\n  graphic.initProps(line, {\n    shape: {\n      percent: 1\n    }\n  }, seriesModel, idx);\n  this.add(line);\n  var label = new graphic.Text({\n    name: 'label'\n  });\n  this.add(label);\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure\n    // it will be updated after line#update.\n    // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n\n    this.add(symbol);\n    this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n  }, this);\n\n  this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto.updateData = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var line = this.childOfName('line');\n  var linePoints = lineData.getItemLayout(idx);\n  var target = {\n    shape: {}\n  };\n  setLinePoints(target.shape, linePoints);\n  graphic.updateProps(line, target, seriesModel, idx);\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbolType = lineData.getItemVisual(idx, symbolCategory);\n    var key = makeSymbolTypeKey(symbolCategory); // Symbol changed\n\n    if (this[key] !== symbolType) {\n      this.remove(this.childOfName(symbolCategory));\n      var symbol = createSymbol(symbolCategory, lineData, idx);\n      this.add(symbol);\n    }\n\n    this[key] = symbolType;\n  }, this);\n\n  this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var line = this.childOfName('line');\n  var lineStyle = seriesScope && seriesScope.lineStyle;\n  var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset\n\n  if (!seriesScope || lineData.hasItemOption) {\n    var itemModel = lineData.getItemModel(idx);\n    lineStyle = itemModel.getModel('lineStyle').getLineStyle();\n    hoverLineStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();\n    labelModel = itemModel.getModel('label');\n    hoverLabelModel = itemModel.getModel('emphasis.label');\n  }\n\n  var visualColor = lineData.getItemVisual(idx, 'color');\n  var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);\n  line.useStyle(zrUtil.defaults({\n    strokeNoScale: true,\n    fill: 'none',\n    stroke: visualColor,\n    opacity: visualOpacity\n  }, lineStyle));\n  line.hoverStyle = hoverLineStyle; // Update symbol\n\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbol = this.childOfName(symbolCategory);\n\n    if (symbol) {\n      symbol.setColor(visualColor);\n      symbol.setStyle({\n        opacity: visualOpacity\n      });\n    }\n  }, this);\n  var showLabel = labelModel.getShallow('show');\n  var hoverShowLabel = hoverLabelModel.getShallow('show');\n  var label = this.childOfName('label');\n  var defaultLabelColor;\n  var baseText; // FIXME: the logic below probably should be merged to `graphic.setLabelStyle`.\n\n  if (showLabel || hoverShowLabel) {\n    defaultLabelColor = visualColor || '#000';\n    baseText = seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType);\n\n    if (baseText == null) {\n      var rawVal = seriesModel.getRawValue(idx);\n      baseText = rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;\n    }\n  }\n\n  var normalText = showLabel ? baseText : null;\n  var emphasisText = hoverShowLabel ? zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), baseText) : null;\n  var labelStyle = label.style; // Always set `textStyle` even if `normalStyle.text` is null, because default\n  // values have to be set on `normalStyle`.\n\n  if (normalText != null || emphasisText != null) {\n    graphic.setTextStyle(label.style, labelModel, {\n      text: normalText\n    }, {\n      autoColor: defaultLabelColor\n    });\n    label.__textAlign = labelStyle.textAlign;\n    label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'\n\n    label.__position = labelModel.get('position') || 'middle';\n  }\n\n  if (emphasisText != null) {\n    // Only these properties supported in this emphasis style here.\n    label.hoverStyle = {\n      text: emphasisText,\n      textFill: hoverLabelModel.getTextColor(true),\n      // For merging hover style to normal style, do not use\n      // `hoverLabelModel.getFont()` here.\n      fontStyle: hoverLabelModel.getShallow('fontStyle'),\n      fontWeight: hoverLabelModel.getShallow('fontWeight'),\n      fontSize: hoverLabelModel.getShallow('fontSize'),\n      fontFamily: hoverLabelModel.getShallow('fontFamily')\n    };\n  } else {\n    label.hoverStyle = {\n      text: null\n    };\n  }\n\n  label.ignore = !showLabel && !hoverShowLabel;\n  graphic.setHoverStyle(this);\n};\n\nlineProto.highlight = function () {\n  this.trigger('emphasis');\n};\n\nlineProto.downplay = function () {\n  this.trigger('normal');\n};\n\nlineProto.updateLayout = function (lineData, idx) {\n  this.setLinePoints(lineData.getItemLayout(idx));\n};\n\nlineProto.setLinePoints = function (points) {\n  var linePath = this.childOfName('line');\n  setLinePoints(linePath.shape, points);\n  linePath.dirty();\n};\n\nzrUtil.inherits(Line, graphic.Group);\nvar _default = Line;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 246:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(6);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\nvar env = __webpack_require__(7);\n\nvar modelUtil = __webpack_require__(1);\n\nvar formatUtil = __webpack_require__(9);\n\nvar dataFormatMixin = __webpack_require__(90);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar addCommas = formatUtil.addCommas;\nvar encodeHTML = formatUtil.encodeHTML;\n\nfunction fillLabel(opt) {\n  modelUtil.defaultEmphasis(opt, 'label', ['show']);\n}\n\nvar MarkerModel = echarts.extendComponentModel({\n  type: 'marker',\n  dependencies: ['series', 'grid', 'polar', 'geo'],\n\n  /**\n   * @overrite\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  },\n  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n    var MarkerModel = this.constructor;\n    var modelPropName = this.mainType + 'Model';\n\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        var markerOpt = seriesModel.get(this.mainType, true);\n        var markerModel = seriesModel[modelPropName];\n\n        if (!markerOpt || !markerOpt.data) {\n          seriesModel[modelPropName] = null;\n          return;\n        }\n\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n\n          zrUtil.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = new MarkerModel(markerOpt, this, ecModel);\n          zrUtil.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel.mergeOption(markerOpt, ecModel, true);\n        }\n\n        seriesModel[modelPropName] = markerModel;\n      }, this);\n    }\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n    var name = data.getName(dataIndex);\n    var html = encodeHTML(this.name);\n\n    if (value != null || name) {\n      html += '<br />';\n    }\n\n    if (name) {\n      html += encodeHTML(name);\n\n      if (value != null) {\n        html += ' : ';\n      }\n    }\n\n    if (value != null) {\n      html += encodeHTML(formattedValue);\n    }\n\n    return html;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setData: function (data) {\n    this._data = data;\n  }\n});\nzrUtil.mixin(MarkerModel, dataFormatMixin);\nvar _default = MarkerModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 247:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar numberUtil = __webpack_require__(5);\n\nvar _dataStackHelper = __webpack_require__(32);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n} // Make it simple, do not visit all stacked value to count precision.\n// function getPrecision(data, valueAxisDim, dataIndex) {\n//     var precision = -1;\n//     var stackedDim = data.mapDimension(valueAxisDim);\n//     do {\n//         precision = Math.max(\n//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),\n//             precision\n//         );\n//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n//         if (stackedOnSeries) {\n//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);\n//             data = stackedOnSeries.getData();\n//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);\n//             stackedDim = data.getCalculationInfo('stackedDimension');\n//         }\n//         else {\n//             data = null;\n//         }\n//     } while (data);\n//     return precision;\n// }\n\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim\n  /*, otherDataDim*/\n  );\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n\n  return ret;\n}\n\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var data = seriesModel.getData();\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    });\n    return sum / count;\n  } else if (type === 'median') {\n    return data.getMedian(valueDataDim);\n  } else {\n    // max & min\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;\n\n/***/ }),\n\n/***/ 248:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = echarts.extendComponentView({\n  type: 'marker',\n  init: function () {\n    /**\n     * Markline grouped by series\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this.markerGroupMap = zrUtil.createHashMap();\n  },\n  render: function (markerModel, ecModel, api) {\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      item.__keep = false;\n    });\n    var markerModelKey = this.type + 'Model';\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = seriesModel[markerModelKey];\n      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n    }, this);\n    markerGroupMap.each(function (item) {\n      !item.__keep && this.group.remove(item.group);\n    }, this);\n  },\n  renderSeries: function () {}\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 253:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createListSimply = __webpack_require__(192);\n\nvar zrUtil = __webpack_require__(0);\n\nvar _dimensionHelper = __webpack_require__(34);\n\nvar getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar seriesModelMixin = {\n  /**\n   * @private\n   * @type {string}\n   */\n  _baseAxisDim: null,\n\n  /**\n   * @override\n   */\n  getInitialData: function (option, ecModel) {\n    // When both types of xAxis and yAxis are 'value', layout is\n    // needed to be specified by user. Otherwise, layout can be\n    // judged by which axis is category.\n    var ordinalMeta;\n    var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));\n    var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));\n    var xAxisType = xAxisModel.get('type');\n    var yAxisType = yAxisModel.get('type');\n    var addOrdinal; // FIXME\n    // \n\n    if (xAxisType === 'category') {\n      option.layout = 'horizontal';\n      ordinalMeta = xAxisModel.getOrdinalMeta();\n      addOrdinal = true;\n    } else if (yAxisType === 'category') {\n      option.layout = 'vertical';\n      ordinalMeta = yAxisModel.getOrdinalMeta();\n      addOrdinal = true;\n    } else {\n      option.layout = option.layout || 'horizontal';\n    }\n\n    var coordDims = ['x', 'y'];\n    var baseAxisDimIndex = option.layout === 'horizontal' ? 0 : 1;\n    var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];\n    var otherAxisDim = coordDims[1 - baseAxisDimIndex];\n    var axisModels = [xAxisModel, yAxisModel];\n    var baseAxisType = axisModels[baseAxisDimIndex].get('type');\n    var otherAxisType = axisModels[1 - baseAxisDimIndex].get('type');\n    var data = option.data; // ??? FIXME make a stage to perform data transfrom.\n    // MUST create a new data, consider setOption({}) again.\n\n    if (data && addOrdinal) {\n      var newOptionData = [];\n      zrUtil.each(data, function (item, index) {\n        var newItem;\n\n        if (item.value && zrUtil.isArray(item.value)) {\n          newItem = item.value.slice();\n          item.value.unshift(index);\n        } else if (zrUtil.isArray(item)) {\n          newItem = item.slice();\n          item.unshift(index);\n        } else {\n          newItem = item;\n        }\n\n        newOptionData.push(newItem);\n      });\n      option.data = newOptionData;\n    }\n\n    var defaultValueDimensions = this.defaultValueDimensions;\n    return createListSimply(this, {\n      coordDimensions: [{\n        name: baseAxisDim,\n        type: getDimensionTypeByAxis(baseAxisType),\n        ordinalMeta: ordinalMeta,\n        otherDims: {\n          tooltip: false,\n          itemName: 0\n        },\n        dimsDef: ['base']\n      }, {\n        name: otherAxisDim,\n        type: getDimensionTypeByAxis(otherAxisType),\n        dimsDef: defaultValueDimensions.slice()\n      }],\n      dimensionsCount: defaultValueDimensions.length + 1\n    });\n  },\n\n  /**\n   * If horizontal, base axis is x, otherwise y.\n   * @override\n   */\n  getBaseAxis: function () {\n    var dim = this._baseAxisDim;\n    return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;\n  }\n};\nexports.seriesModelMixin = seriesModelMixin;\n\n/***/ }),\n\n/***/ 264:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(11);\n\nvar vec2 = __webpack_require__(2);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Line path for bezier and straight line draw\n */\nvar straightLineProto = graphic.Line.prototype;\nvar bezierCurveProto = graphic.BezierCurve.prototype;\n\nfunction isLine(shape) {\n  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n}\n\nvar _default = graphic.extendShape({\n  type: 'ec-line',\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    percent: 1,\n    cpx1: null,\n    cpy1: null\n  },\n  buildPath: function (ctx, shape) {\n    (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);\n  },\n  pointAt: function (t) {\n    return isLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);\n  },\n  tangentAt: function (t) {\n    var shape = this.shape;\n    var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 277:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n__webpack_require__(278);\n\n__webpack_require__(279);\n\nvar preprocessor = __webpack_require__(280);\n\nvar candlestickVisual = __webpack_require__(281);\n\nvar candlestickLayout = __webpack_require__(282);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\necharts.registerPreprocessor(preprocessor);\necharts.registerVisual(candlestickVisual);\necharts.registerLayout(candlestickLayout);\n\n/***/ }),\n\n/***/ 278:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar SeriesModel = __webpack_require__(78);\n\nvar _whiskerBoxCommon = __webpack_require__(253);\n\nvar seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar CandlestickSeries = SeriesModel.extend({\n  type: 'series.candlestick',\n  dependencies: ['xAxis', 'yAxis', 'grid'],\n\n  /**\n   * @readOnly\n   */\n  defaultValueDimensions: [{\n    name: 'open',\n    defaultTooltip: true\n  }, {\n    name: 'close',\n    defaultTooltip: true\n  }, {\n    name: 'lowest',\n    defaultTooltip: true\n  }, {\n    name: 'highest',\n    defaultTooltip: true\n  }],\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: null,\n\n  /**\n   * @override\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    layout: null,\n    // 'horizontal' or 'vertical'\n    itemStyle: {\n      color: '#c23531',\n      //  positive\n      color0: '#314656',\n      //  negative     '#c23531', '#314656'\n      borderWidth: 1,\n      // FIXME\n      // ec2lineStyle.color  lineStyle.color0\n      borderColor: '#c23531',\n      borderColor0: '#314656'\n    },\n    emphasis: {\n      itemStyle: {\n        borderWidth: 2\n      }\n    },\n    barMaxWidth: null,\n    barMinWidth: null,\n    barWidth: null,\n    large: true,\n    largeThreshold: 600,\n    progressive: 5e3,\n    progressiveThreshold: 1e4,\n    progressiveChunkMode: 'mod',\n    animationUpdate: false,\n    animationEasing: 'linear',\n    animationDuration: 300\n  },\n\n  /**\n   * Get dimension for shadow in dataZoom\n   * @return {string} dimension name\n   */\n  getShadowDim: function () {\n    return 'open';\n  },\n  brushSelector: function (dataIndex, data, selectors) {\n    var itemLayout = data.getItemLayout(dataIndex);\n    return itemLayout && selectors.rect(itemLayout.brushRect);\n  }\n});\nzrUtil.mixin(CandlestickSeries, seriesModelMixin, true);\nvar _default = CandlestickSeries;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 279:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar ChartView = __webpack_require__(79);\n\nvar graphic = __webpack_require__(11);\n\nvar Path = __webpack_require__(3);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar NORMAL_ITEM_STYLE_PATH = ['itemStyle'];\nvar EMPHASIS_ITEM_STYLE_PATH = ['emphasis', 'itemStyle'];\nvar SKIP_PROPS = ['color', 'color0', 'borderColor', 'borderColor0'];\nvar CandlestickView = ChartView.extend({\n  type: 'candlestick',\n  render: function (seriesModel, ecModel, api) {\n    this._updateDrawMode(seriesModel);\n\n    this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);\n  },\n  incrementalPrepareRender: function (seriesModel, ecModel, api) {\n    this._clear();\n\n    this._updateDrawMode(seriesModel);\n  },\n  incrementalRender: function (params, seriesModel, ecModel, api) {\n    this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);\n  },\n  _updateDrawMode: function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n\n    if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n\n      this._clear();\n    }\n  },\n  _renderNormal: function (seriesModel) {\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var isSimpleBox = data.getLayout('isSimpleBox'); // There is no old data only when first rendering or switching from\n    // stream mode to normal mode, where previous elements should be removed.\n\n    if (!this._data) {\n      group.removeAll();\n    }\n\n    data.diff(oldData).add(function (newIdx) {\n      if (data.hasValue(newIdx)) {\n        var el;\n        var itemLayout = data.getItemLayout(newIdx);\n        el = createNormalBox(itemLayout, newIdx, true);\n        graphic.initProps(el, {\n          shape: {\n            points: itemLayout.ends\n          }\n        }, seriesModel, newIdx);\n        setBoxCommon(el, data, newIdx, isSimpleBox);\n        group.add(el);\n        data.setItemGraphicEl(newIdx, el);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx); // Empty data\n\n      if (!data.hasValue(newIdx)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemLayout = data.getItemLayout(newIdx);\n\n      if (!el) {\n        el = createNormalBox(itemLayout, newIdx);\n      } else {\n        graphic.updateProps(el, {\n          shape: {\n            points: itemLayout.ends\n          }\n        }, seriesModel, newIdx);\n      }\n\n      setBoxCommon(el, data, newIdx, isSimpleBox);\n      group.add(el);\n      data.setItemGraphicEl(newIdx, el);\n    }).remove(function (oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      el && group.remove(el);\n    }).execute();\n    this._data = data;\n  },\n  _renderLarge: function (seriesModel) {\n    this._clear();\n\n    createLarge(seriesModel, this.group);\n  },\n  _incrementalRenderNormal: function (params, seriesModel) {\n    var data = seriesModel.getData();\n    var isSimpleBox = data.getLayout('isSimpleBox');\n    var dataIndex;\n\n    while ((dataIndex = params.next()) != null) {\n      var el;\n      var itemLayout = data.getItemLayout(dataIndex);\n      el = createNormalBox(itemLayout, dataIndex);\n      setBoxCommon(el, data, dataIndex, isSimpleBox);\n      el.incremental = true;\n      this.group.add(el);\n    }\n  },\n  _incrementalRenderLarge: function (params, seriesModel) {\n    createLarge(seriesModel, this.group, true);\n  },\n  remove: function (ecModel) {\n    this._clear();\n  },\n  _clear: function () {\n    this.group.removeAll();\n    this._data = null;\n  },\n  dispose: zrUtil.noop\n});\nvar NormalBoxPath = Path.extend({\n  type: 'normalCandlestickBox',\n  shape: {},\n  buildPath: function (ctx, shape) {\n    var ends = shape.points;\n\n    if (this.__simpleBox) {\n      ctx.moveTo(ends[4][0], ends[4][1]);\n      ctx.lineTo(ends[6][0], ends[6][1]);\n    } else {\n      ctx.moveTo(ends[0][0], ends[0][1]);\n      ctx.lineTo(ends[1][0], ends[1][1]);\n      ctx.lineTo(ends[2][0], ends[2][1]);\n      ctx.lineTo(ends[3][0], ends[3][1]);\n      ctx.closePath();\n      ctx.moveTo(ends[4][0], ends[4][1]);\n      ctx.lineTo(ends[5][0], ends[5][1]);\n      ctx.moveTo(ends[6][0], ends[6][1]);\n      ctx.lineTo(ends[7][0], ends[7][1]);\n    }\n  }\n});\n\nfunction createNormalBox(itemLayout, dataIndex, isInit) {\n  var ends = itemLayout.ends;\n  return new NormalBoxPath({\n    shape: {\n      points: isInit ? transInit(ends, itemLayout) : ends\n    },\n    z2: 100\n  });\n}\n\nfunction setBoxCommon(el, data, dataIndex, isSimpleBox) {\n  var itemModel = data.getItemModel(dataIndex);\n  var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);\n  var color = data.getItemVisual(dataIndex, 'color');\n  var borderColor = data.getItemVisual(dataIndex, 'borderColor') || color; // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n\n  var itemStyle = normalItemStyleModel.getItemStyle(SKIP_PROPS);\n  el.useStyle(itemStyle);\n  el.style.strokeNoScale = true;\n  el.style.fill = color;\n  el.style.stroke = borderColor;\n  el.__simpleBox = isSimpleBox;\n  var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();\n  graphic.setHoverStyle(el, hoverStyle);\n}\n\nfunction transInit(points, itemLayout) {\n  return zrUtil.map(points, function (point) {\n    point = point.slice();\n    point[1] = itemLayout.initBaseline;\n    return point;\n  });\n}\n\nvar LargeBoxPath = Path.extend({\n  type: 'largeCandlestickBox',\n  shape: {},\n  buildPath: function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n\n    for (var i = 0; i < points.length;) {\n      if (this.__sign === points[i++]) {\n        var x = points[i++];\n        ctx.moveTo(x, points[i++]);\n        ctx.lineTo(x, points[i++]);\n      } else {\n        i += 3;\n      }\n    }\n  }\n});\n\nfunction createLarge(seriesModel, group, incremental) {\n  var data = seriesModel.getData();\n  var largePoints = data.getLayout('largePoints');\n  var elP = new LargeBoxPath({\n    shape: {\n      points: largePoints\n    },\n    __sign: 1\n  });\n  group.add(elP);\n  var elN = new LargeBoxPath({\n    shape: {\n      points: largePoints\n    },\n    __sign: -1\n  });\n  group.add(elN);\n  setLargeStyle(1, elP, seriesModel, data);\n  setLargeStyle(-1, elN, seriesModel, data);\n\n  if (incremental) {\n    elP.incremental = true;\n    elN.incremental = true;\n  }\n}\n\nfunction setLargeStyle(sign, el, seriesModel, data) {\n  var suffix = sign > 0 ? 'P' : 'N';\n  var borderColor = data.getVisual('borderColor' + suffix) || data.getVisual('color' + suffix); // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n\n  var itemStyle = seriesModel.getModel(NORMAL_ITEM_STYLE_PATH).getItemStyle(SKIP_PROPS);\n  el.useStyle(itemStyle);\n  el.style.fill = null;\n  el.style.stroke = borderColor; // No different\n  // el.style.lineWidth = .5;\n}\n\nvar _default = CandlestickView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 280:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(option) {\n  if (!option || !zrUtil.isArray(option.series)) {\n    return;\n  } // Translate 'k' to 'candlestick'.\n\n\n  zrUtil.each(option.series, function (seriesItem) {\n    if (zrUtil.isObject(seriesItem) && seriesItem.type === 'k') {\n      seriesItem.type = 'candlestick';\n    }\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 281:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createRenderPlanner = __webpack_require__(44);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar positiveBorderColorQuery = ['itemStyle', 'borderColor'];\nvar negativeBorderColorQuery = ['itemStyle', 'borderColor0'];\nvar positiveColorQuery = ['itemStyle', 'color'];\nvar negativeColorQuery = ['itemStyle', 'color0'];\nvar _default = {\n  seriesType: 'candlestick',\n  plan: createRenderPlanner(),\n  // For legend.\n  performRawSeries: true,\n  reset: function (seriesModel, ecModel) {\n    var data = seriesModel.getData();\n    var isLargeRender = seriesModel.pipelineContext.large;\n    data.setVisual({\n      legendSymbol: 'roundRect',\n      colorP: getColor(1, seriesModel),\n      colorN: getColor(-1, seriesModel),\n      borderColorP: getBorderColor(1, seriesModel),\n      borderColorN: getBorderColor(-1, seriesModel)\n    }); // Only visible series has each data be visual encoded\n\n    if (ecModel.isSeriesFiltered(seriesModel)) {\n      return;\n    }\n\n    return !isLargeRender && {\n      progress: progress\n    };\n\n    function progress(params, data) {\n      var dataIndex;\n\n      while ((dataIndex = params.next()) != null) {\n        var itemModel = data.getItemModel(dataIndex);\n        var sign = data.getItemLayout(dataIndex).sign;\n        data.setItemVisual(dataIndex, {\n          color: getColor(sign, itemModel),\n          borderColor: getBorderColor(sign, itemModel)\n        });\n      }\n    }\n\n    function getColor(sign, model) {\n      return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);\n    }\n\n    function getBorderColor(sign, model) {\n      return model.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);\n    }\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 282:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _graphic = __webpack_require__(11);\n\nvar subPixelOptimize = _graphic.subPixelOptimize;\n\nvar createRenderPlanner = __webpack_require__(44);\n\nvar _number = __webpack_require__(5);\n\nvar parsePercent = _number.parsePercent;\n\nvar _util = __webpack_require__(0);\n\nvar retrieve2 = _util.retrieve2;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar _default = {\n  seriesType: 'candlestick',\n  plan: createRenderPlanner(),\n  reset: function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    var data = seriesModel.getData();\n    var candleWidth = calculateCandleWidth(seriesModel, data);\n    var cDimIdx = 0;\n    var vDimIdx = 1;\n    var coordDims = ['x', 'y'];\n    var cDim = data.mapDimension(coordDims[cDimIdx]);\n    var vDims = data.mapDimension(coordDims[vDimIdx], true);\n    var openDim = vDims[0];\n    var closeDim = vDims[1];\n    var lowestDim = vDims[2];\n    var highestDim = vDims[3];\n    data.setLayout({\n      candleWidth: candleWidth,\n      // The value is experimented visually.\n      isSimpleBox: candleWidth <= 1.3\n    });\n\n    if (cDim == null || vDims.length < 4) {\n      return;\n    }\n\n    return {\n      progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress\n    };\n\n    function normalProgress(params, data) {\n      var dataIndex;\n\n      while ((dataIndex = params.next()) != null) {\n        var axisDimVal = data.get(cDim, dataIndex);\n        var openVal = data.get(openDim, dataIndex);\n        var closeVal = data.get(closeDim, dataIndex);\n        var lowestVal = data.get(lowestDim, dataIndex);\n        var highestVal = data.get(highestDim, dataIndex);\n        var ocLow = Math.min(openVal, closeVal);\n        var ocHigh = Math.max(openVal, closeVal);\n        var ocLowPoint = getPoint(ocLow, axisDimVal);\n        var ocHighPoint = getPoint(ocHigh, axisDimVal);\n        var lowestPoint = getPoint(lowestVal, axisDimVal);\n        var highestPoint = getPoint(highestVal, axisDimVal);\n        var ends = [];\n        addBodyEnd(ends, ocHighPoint, 0);\n        addBodyEnd(ends, ocLowPoint, 1);\n        ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));\n        data.setItemLayout(dataIndex, {\n          sign: getSign(data, dataIndex, openVal, closeVal, closeDim),\n          initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],\n          // open point.\n          ends: ends,\n          brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)\n        });\n      }\n\n      function getPoint(val, axisDimVal) {\n        var p = [];\n        p[cDimIdx] = axisDimVal;\n        p[vDimIdx] = val;\n        return isNaN(axisDimVal) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);\n      }\n\n      function addBodyEnd(ends, point, start) {\n        var point1 = point.slice();\n        var point2 = point.slice();\n        point1[cDimIdx] = subPixelOptimize(point1[cDimIdx] + candleWidth / 2, 1, false);\n        point2[cDimIdx] = subPixelOptimize(point2[cDimIdx] - candleWidth / 2, 1, true);\n        start ? ends.push(point1, point2) : ends.push(point2, point1);\n      }\n\n      function makeBrushRect(lowestVal, highestVal, axisDimVal) {\n        var pmin = getPoint(lowestVal, axisDimVal);\n        var pmax = getPoint(highestVal, axisDimVal);\n        pmin[cDimIdx] -= candleWidth / 2;\n        pmax[cDimIdx] -= candleWidth / 2;\n        return {\n          x: pmin[0],\n          y: pmin[1],\n          width: vDimIdx ? candleWidth : pmax[0] - pmin[0],\n          height: vDimIdx ? pmax[1] - pmin[1] : candleWidth\n        };\n      }\n\n      function subPixelOptimizePoint(point) {\n        point[cDimIdx] = subPixelOptimize(point[cDimIdx], 1);\n        return point;\n      }\n    }\n\n    function largeProgress(params, data) {\n      // Structure: [sign, x, yhigh, ylow, sign, x, yhigh, ylow, ...]\n      var points = new LargeArr(params.count * 5);\n      var offset = 0;\n      var point;\n      var tmpIn = [];\n      var tmpOut = [];\n      var dataIndex;\n\n      while ((dataIndex = params.next()) != null) {\n        var axisDimVal = data.get(cDim, dataIndex);\n        var openVal = data.get(openDim, dataIndex);\n        var closeVal = data.get(closeDim, dataIndex);\n        var lowestVal = data.get(lowestDim, dataIndex);\n        var highestVal = data.get(highestDim, dataIndex);\n\n        if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {\n          points[offset++] = NaN;\n          offset += 4;\n          continue;\n        }\n\n        points[offset++] = getSign(data, dataIndex, openVal, closeVal, closeDim);\n        tmpIn[cDimIdx] = axisDimVal;\n        tmpIn[vDimIdx] = lowestVal;\n        point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n        points[offset++] = point ? point[0] : NaN;\n        points[offset++] = point ? point[1] : NaN;\n        tmpIn[vDimIdx] = highestVal;\n        point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n        points[offset++] = point ? point[1] : NaN;\n      }\n\n      data.setLayout('largePoints', points);\n    }\n  }\n};\n\nfunction getSign(data, dataIndex, openVal, closeVal, closeDim) {\n  var sign;\n\n  if (openVal > closeVal) {\n    sign = -1;\n  } else if (openVal < closeVal) {\n    sign = 1;\n  } else {\n    sign = dataIndex > 0 // If close === open, compare with close of last record\n    ? data.get(closeDim, dataIndex - 1) <= closeVal ? 1 : -1 : // No record of previous, set to be positive\n    1;\n  }\n\n  return sign;\n}\n\nfunction calculateCandleWidth(seriesModel, data) {\n  var baseAxis = seriesModel.getBaseAxis();\n  var extent;\n  var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());\n  var barMaxWidth = parsePercent(retrieve2(seriesModel.get('barMaxWidth'), bandWidth), bandWidth);\n  var barMinWidth = parsePercent(retrieve2(seriesModel.get('barMinWidth'), 1), bandWidth);\n  var barWidth = seriesModel.get('barWidth');\n  return barWidth != null ? parsePercent(barWidth, bandWidth) // Put max outer to ensure bar visible in spite of overlap.\n  : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 285:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(76);\n\n__webpack_require__(286);\n\n__webpack_require__(287);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\necharts.registerPreprocessor(function (opt) {\n  // Make sure markLine component is enabled\n  opt.markLine = opt.markLine || {};\n});\n\n/***/ }),\n\n/***/ 286:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MarkerModel = __webpack_require__(246);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = MarkerModel.extend({\n  type: 'markLine',\n  defaultOption: {\n    zlevel: 0,\n    z: 5,\n    symbol: ['circle', 'arrow'],\n    symbolSize: [8, 16],\n    //symbolRotate: 0,\n    precision: 2,\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      show: true,\n      position: 'end'\n    },\n    lineStyle: {\n      type: 'dashed'\n    },\n    emphasis: {\n      label: {\n        show: true\n      },\n      lineStyle: {\n        width: 3\n      }\n    },\n    animationEasing: 'linear'\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 287:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar List = __webpack_require__(41);\n\nvar numberUtil = __webpack_require__(5);\n\nvar markerHelper = __webpack_require__(247);\n\nvar LineDraw = __webpack_require__(241);\n\nvar MarkerView = __webpack_require__(248);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n  var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average', 'median'\n\n  var mlType = item.type;\n\n  if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' // In case\n  // data: [{\n  //   yAxis: 10\n  // }]\n  || item.xAxis != null || item.yAxis != null)) {\n    var valueAxis;\n    var valueDataDim;\n    var value;\n\n    if (item.yAxis != null || item.xAxis != null) {\n      valueDataDim = item.yAxis != null ? 'y' : 'x';\n      valueAxis = coordSys.getAxis(valueDataDim);\n      value = zrUtil.retrieve(item.yAxis, item.xAxis);\n    } else {\n      var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);\n      valueDataDim = axisInfo.valueDataDim;\n      valueAxis = axisInfo.valueAxis;\n      value = markerHelper.numCalculate(data, valueDataDim, mlType);\n    }\n\n    var valueIndex = valueDataDim === 'x' ? 0 : 1;\n    var baseIndex = 1 - valueIndex;\n    var mlFrom = zrUtil.clone(item);\n    var mlTo = {};\n    mlFrom.type = null;\n    mlFrom.coord = [];\n    mlTo.coord = [];\n    mlFrom.coord[baseIndex] = -Infinity;\n    mlTo.coord[baseIndex] = Infinity;\n    var precision = mlModel.get('precision');\n\n    if (precision >= 0 && typeof value === 'number') {\n      value = +value.toFixed(Math.min(precision, 20));\n    }\n\n    mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n    item = [mlFrom, mlTo, {\n      // Extra option for tooltip and label\n      type: mlType,\n      valueIndex: item.valueIndex,\n      // Force to use the value of calculated value.\n      value: value\n    }];\n  }\n\n  item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type\n\n  item[2].type = item[2].type || ''; // Merge from option and to option into line option\n\n  zrUtil.merge(item[2], item[0]);\n  zrUtil.merge(item[2], item[1]);\n  return item;\n};\n\nfunction isInifinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markLine has one dim\n\n\nfunction ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  var dimName = coordSys.dimensions[dimIndex];\n  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n}\n\nfunction markLineFilter(coordSys, item) {\n  if (coordSys.type === 'cartesian2d') {\n    var fromCoord = item[0].coord;\n    var toCoord = item[1].coord; // In case\n    // {\n    //  markLine: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n\n    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n\n  return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);\n}\n\nfunction updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPoisition\n      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));\n    } else {\n      var dims = coordSys.dimensions;\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      point = coordSys.dataToPoint([x, y]);\n    } // Expand line to the edge of grid if value on one axis is Inifnity\n    // In case\n    //  markLine: {\n    //    data: [{\n    //      yAxis: 2\n    //      // or\n    //      type: 'average'\n    //    }]\n    //  }\n\n\n    if (coordSys.type === 'cartesian2d') {\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var dims = coordSys.dimensions;\n\n      if (isInifinity(data.get(dims[0], idx))) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n      } else if (isInifinity(data.get(dims[1], idx))) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n\n  data.setItemLayout(idx, point);\n}\n\nvar _default = MarkerView.extend({\n  type: 'markLine',\n  // updateLayout: function (markLineModel, ecModel, api) {\n  //     ecModel.eachSeries(function (seriesModel) {\n  //         var mlModel = seriesModel.markLineModel;\n  //         if (mlModel) {\n  //             var mlData = mlModel.getData();\n  //             var fromData = mlModel.__from;\n  //             var toData = mlModel.__to;\n  //             // Update visual and layout of from symbol and to symbol\n  //             fromData.each(function (idx) {\n  //                 updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n  //                 updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n  //             });\n  //             // Update layout of line\n  //             mlData.each(function (idx) {\n  //                 mlData.setItemLayout(idx, [\n  //                     fromData.getItemLayout(idx),\n  //                     toData.getItemLayout(idx)\n  //                 ]);\n  //             });\n  //             this.markerGroupMap.get(seriesModel.id).updateLayout();\n  //         }\n  //     }, this);\n  // },\n  updateTransform: function (markLineModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mlModel = seriesModel.markLineModel;\n\n      if (mlModel) {\n        var mlData = mlModel.getData();\n        var fromData = mlModel.__from;\n        var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol\n\n        fromData.each(function (idx) {\n          updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n          updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n        }); // Update layout of line\n\n        mlData.each(function (idx) {\n          mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n        });\n        this.markerGroupMap.get(seriesModel.id).updateLayout();\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, mlModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var lineDrawMap = this.markerGroupMap;\n    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());\n    this.group.add(lineDraw.group);\n    var mlData = createList(coordSys, seriesModel, mlModel);\n    var fromData = mlData.from;\n    var toData = mlData.to;\n    var lineData = mlData.line;\n    mlModel.__from = fromData;\n    mlModel.__to = toData; // Line data for tooltip and formatter\n\n    mlModel.setData(lineData);\n    var symbolType = mlModel.get('symbol');\n    var symbolSize = mlModel.get('symbolSize');\n\n    if (!zrUtil.isArray(symbolType)) {\n      symbolType = [symbolType, symbolType];\n    }\n\n    if (typeof symbolSize === 'number') {\n      symbolSize = [symbolSize, symbolSize];\n    } // Update visual and layout of from symbol and to symbol\n\n\n    mlData.from.each(function (idx) {\n      updateDataVisualAndLayout(fromData, idx, true);\n      updateDataVisualAndLayout(toData, idx, false);\n    }); // Update visual and layout of line\n\n    lineData.each(function (idx) {\n      var lineColor = lineData.getItemModel(idx).get('lineStyle.color');\n      lineData.setItemVisual(idx, {\n        color: lineColor || fromData.getItemVisual(idx, 'color')\n      });\n      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n      lineData.setItemVisual(idx, {\n        'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),\n        'fromSymbol': fromData.getItemVisual(idx, 'symbol'),\n        'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),\n        'toSymbol': toData.getItemVisual(idx, 'symbol')\n      });\n    });\n    lineDraw.updateData(lineData); // Set host model for tooltip\n    // FIXME\n\n    mlData.line.eachItemGraphicEl(function (el, idx) {\n      el.traverse(function (child) {\n        child.dataModel = mlModel;\n      });\n    });\n\n    function updateDataVisualAndLayout(data, idx, isFrom) {\n      var itemModel = data.getItemModel(idx);\n      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);\n      data.setItemVisual(idx, {\n        symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n        symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n        color: itemModel.get('itemStyle.color') || seriesData.getVisual('color')\n      });\n    }\n\n    lineDraw.__keep = true;\n    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} coordSys\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\n\nfunction createList(coordSys, seriesModel, mlModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return zrUtil.defaults({\n        name: coordDim\n      }, info);\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var fromData = new List(coordDimsInfos, mlModel);\n  var toData = new List(coordDimsInfos, mlModel); // No dimensions\n\n  var lineData = new List([], mlModel);\n  var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));\n\n  if (coordSys) {\n    optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));\n  }\n\n  var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  };\n  fromData.initData(zrUtil.map(optData, function (item) {\n    return item[0];\n  }), null, dimValueGetter);\n  toData.initData(zrUtil.map(optData, function (item) {\n    return item[1];\n  }), null, dimValueGetter);\n  lineData.initData(zrUtil.map(optData, function (item) {\n    return item[2];\n  }));\n  lineData.hasItemOption = true;\n  return {\n    from: fromData,\n    to: toData,\n    line: lineData\n  };\n}\n\nmodule.exports = _default;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/CandlestickReact.efc3d13d.chunk.js","/**\r\n * Created by yongyuehuang on 2017/8/5.\r\n */\r\nimport React from 'react'\r\nimport echarts from 'echarts/lib/echarts' //\r\nimport 'echarts/lib/chart/candlestick' //\r\nimport 'echarts/lib/component/tooltip'\r\nimport 'echarts/lib/component/legend'\r\nimport 'echarts/lib/component/grid'\r\nimport 'echarts/lib/component/markLine'\r\n\r\nexport default class CandlestickReact extends React.Component {\r\n  \r\n  constructor(props) {\r\n    super(props)\r\n    this.initPie = this.initPie.bind(this)\r\n  }\r\n  \r\n  initPie() {\r\n    const { option={} } = this.props //data\r\n    let myChart = echarts.init(this.ID) //echarts\r\n    \r\n    //options\r\n    myChart.setOption(option)\r\n    window.onresize = function() {\r\n      myChart.resize()\r\n    }\r\n  }\r\n  \r\n  componentDidMount() {\r\n    this.initPie()\r\n  }\r\n  \r\n  componentDidUpdate() {\r\n    this.initPie()\r\n  }\r\n  \r\n  render() {\r\n    const { width=\"100%\", height=\"400px\" } = this.props\r\n    return <div ref={ID => this.ID = ID} style={{width, height}}></div>\r\n  }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/EchartsDemo/CandlestickReact.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n// allAxesInfo should be updated when setOption performed.\n\nfunction collect(ecModel, api) {\n  var result = {\n    /**\n     * key: makeKey(axis.model)\n     * value: {\n     *      axis,\n     *      coordSys,\n     *      axisPointerModel,\n     *      triggerTooltip,\n     *      involveSeries,\n     *      snap,\n     *      seriesModels,\n     *      seriesDataCount\n     * }\n     */\n    axesInfo: {},\n    seriesInvolved: false,\n\n    /**\n     * key: makeKey(coordSys.model)\n     * value: Object: key makeKey(axis.model), value: axisInfo\n     */\n    coordSysAxesInfo: {},\n    coordSysMap: {}\n  };\n  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.\n\n  result.seriesInvolved && collectSeriesInfo(result, ecModel);\n  return result;\n}\n\nfunction collectAxesInfo(result, ecModel, api) {\n  var globalTooltipModel = ecModel.getComponent('tooltip');\n  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.\n\n  var linksOption = globalAxisPointerModel.get('link', true) || [];\n  var linkGroups = []; // Collect axes info.\n\n  each(api.getCoordinateSystems(), function (coordSys) {\n    // Some coordinate system do not support axes, like geo.\n    if (!coordSys.axisPointerEnabled) {\n      return;\n    }\n\n    var coordSysKey = makeKey(coordSys.model);\n    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer\n    // for user. So we enable seting tooltip on coordSys model.\n\n    var coordSysModel = coordSys.model;\n    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.\n    // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n\n    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not\n    // show but axisPointer will show as normal.\n    && baseTooltipModel.get('show')) {\n      // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n      // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n\n      if (triggerAxis || cross) {\n        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));\n      }\n\n      if (cross) {\n        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n      }\n    } // fromTooltip: true | false | 'cross'\n    // triggerTooltip: true | false | null\n\n\n    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n      var axisPointerShow = axisPointerModel.get('show');\n\n      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {\n        return;\n      }\n\n      if (triggerTooltip == null) {\n        triggerTooltip = axisPointerModel.get('triggerTooltip');\n      }\n\n      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;\n      var snap = axisPointerModel.get('snap');\n      var key = makeKey(axis.model);\n      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n\n      var axisInfo = result.axesInfo[key] = {\n        key: key,\n        axis: axis,\n        coordSys: coordSys,\n        axisPointerModel: axisPointerModel,\n        triggerTooltip: triggerTooltip,\n        involveSeries: involveSeries,\n        snap: snap,\n        useHandle: isHandleTrigger(axisPointerModel),\n        seriesModels: []\n      };\n      axesInfoInCoordSys[key] = axisInfo;\n      result.seriesInvolved |= involveSeries;\n      var groupIndex = getLinkGroupIndex(linksOption, axis);\n\n      if (groupIndex != null) {\n        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {\n          axesInfo: {}\n        });\n        linkGroup.axesInfo[key] = axisInfo;\n        linkGroup.mapper = linksOption[groupIndex].mapper;\n        axisInfo.linkGroup = linkGroup;\n      }\n    }\n  });\n}\n\nfunction makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {\n  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n  var volatileOption = {};\n  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {\n    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n  }); // category axis do not auto snap, otherwise some tick that do not\n  // has value can not be hovered. value/time/log axis default snap if\n  // triggered from tooltip and trigger tooltip.\n\n  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.\n  // Only these properties can be overrided from tooltip to axisPointer.\n\n  if (tooltipAxisPointerModel.get('type') === 'cross') {\n    volatileOption.type = 'line';\n  }\n\n  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.\n\n  labelOption.show == null && (labelOption.show = false);\n\n  if (fromTooltip === 'cross') {\n    // When 'cross', both axes show labels.\n    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get('label.show');\n    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style\n    // (cross style is dashed by default)\n\n    if (!triggerTooltip) {\n      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);\n    }\n  }\n\n  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));\n}\n\nfunction collectSeriesInfo(result, ecModel) {\n  // Prepare data for axis trigger\n  ecModel.eachSeries(function (seriesModel) {\n    // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n    var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n\n    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {\n      return;\n    }\n\n    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n      var axis = axisInfo.axis;\n\n      if (coordSys.getAxis(axis.dim) === axis) {\n        axisInfo.seriesModels.push(seriesModel);\n        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n        axisInfo.seriesDataCount += seriesModel.getData().count();\n      }\n    });\n  }, this);\n}\n/**\n * For example:\n * {\n *     axisPointer: {\n *         links: [{\n *             xAxisIndex: [2, 4],\n *             yAxisIndex: 'all'\n *         }, {\n *             xAxisId: ['a5', 'a7'],\n *             xAxisName: 'xxx'\n *         }]\n *     }\n * }\n */\n\n\nfunction getLinkGroupIndex(linksOption, axis) {\n  var axisModel = axis.model;\n  var dim = axis.dim;\n\n  for (var i = 0; i < linksOption.length; i++) {\n    var linkOption = linksOption[i] || {};\n\n    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {\n      return i;\n    }\n  }\n}\n\nfunction checkPropInLink(linkPropValue, axisPropValue) {\n  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;\n}\n\nfunction fixValue(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n\n  if (!axisInfo) {\n    return;\n  }\n\n  var axisPointerModel = axisInfo.axisPointerModel;\n  var scale = axisInfo.axis.scale;\n  var option = axisPointerModel.option;\n  var status = axisPointerModel.get('status');\n  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.\n\n  if (value != null) {\n    value = scale.parse(value);\n  }\n\n  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value\n  // and status should be initialized.\n\n  if (status == null) {\n    option.status = useHandle ? 'show' : 'hide';\n  }\n\n  var extent = scale.getExtent().slice();\n  extent[0] > extent[1] && extent.reverse();\n\n  if ( // Pick a value on axis when initializing.\n  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n  // where we should re-pick a value to keep `handle` displaying normally.\n  || value > extent[1]) {\n    // Make handle displayed on the end of the axis when init, which looks better.\n    value = extent[1];\n  }\n\n  if (value < extent[0]) {\n    value = extent[0];\n  }\n\n  option.value = value;\n\n  if (useHandle) {\n    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n  }\n}\n\nfunction getAxisInfo(axisModel) {\n  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n}\n\nfunction getAxisPointerModel(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n  return axisInfo && axisInfo.axisPointerModel;\n}\n\nfunction isHandleTrigger(axisPointerModel) {\n  return !!axisPointerModel.get('handle.show');\n}\n/**\n * @param {module:echarts/model/Model} model\n * @return {string} unique key\n */\n\n\nfunction makeKey(model) {\n  return model.type + '||' + model.id;\n}\n\nexports.collect = collect;\nexports.fixValue = fixValue;\nexports.getAxisInfo = getAxisInfo;\nexports.getAxisPointerModel = getAxisPointerModel;\nexports.makeKey = makeKey;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/modelHelper.js\n// module id = 181\n// module chunks = 0 1 2 3 4 5","var _util = require(\"zrender/lib/core/util\");\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _number = require(\"../../util/number\");\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar _vector = require(\"zrender/lib/core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n    var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;\n\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];\n          symbol.attr({\n            rotation: point.rotate,\n            position: pos,\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticksCoords[i].tickValue,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {\n      itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickValue);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickValue,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: formattedLabel,\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always use formatted label as\n      // input. But in interval scale the formatted label is like '223,445', which\n      // maked user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = rawLabel;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/AxisBuilder.js\n// module id = 182\n// module chunks = 0 1 2 3 4 5 6","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar axisPointerModelHelper = require(\"../axisPointer/modelHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Base class of AxisView.\n */\nvar AxisView = echarts.extendComponentView({\n  type: 'axis',\n\n  /**\n   * @private\n   */\n  _axisPointer: null,\n\n  /**\n   * @protected\n   * @type {string}\n   */\n  axisPointerClass: null,\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    // FIXME\n    // This process should proformed after coordinate systems updated\n    // (axis scale updated), and should be performed each time update.\n    // So put it here temporarily, although it is not appropriate to\n    // put a model-writing procedure in `view`.\n    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n    AxisView.superApply(this, 'render', arguments);\n    updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n  },\n\n  /**\n   * Action handler.\n   * @public\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/model/Global} ecModel\n   * @param {module:echarts/ExtensionAPI} api\n   * @param {Object} payload\n   */\n  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n    updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    var axisPointer = this._axisPointer;\n    axisPointer && axisPointer.remove(api);\n    AxisView.superApply(this, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    disposeAxisPointer(this, api);\n    AxisView.superApply(this, 'dispose', arguments);\n  }\n});\n\nfunction updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n\n  if (!Clazz) {\n    return;\n  }\n\n  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);\n}\n\nfunction disposeAxisPointer(axisView, ecModel, api) {\n  var axisPointer = axisView._axisPointer;\n  axisPointer && axisPointer.dispose(ecModel, api);\n  axisView._axisPointer = null;\n}\n\nvar axisPointerClazz = [];\n\nAxisView.registerAxisPointerClass = function (type, clazz) {\n  axisPointerClazz[type] = clazz;\n};\n\nAxisView.getAxisPointerClass = function (type) {\n  return type && axisPointerClazz[type];\n};\n\nvar _default = AxisView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/AxisView.js\n// module id = 183\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisPointerModelHelper = require(\"./axisPointer/modelHelper\");\n\nvar axisTrigger = require(\"./axisPointer/axisTrigger\");\n\nrequire(\"./axisPointer/AxisPointerModel\");\n\nrequire(\"./axisPointer/AxisPointerView\");\n\nrequire(\"./axisPointer/CartesianAxisPointer\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// CartesianAxisPointer is not supposed to be required here. But consider\n// echarts.simple.js and online build tooltip, which only require gridSimple,\n// CartesianAxisPointer should be able to required somewhere.\necharts.registerPreprocessor(function (option) {\n  // Always has a global axisPointerModel for default setting.\n  if (option) {\n    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});\n    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link\n    // is not set, remain null/undefined, otherwise it will\n    // override existent link setting.\n\n    if (link && !zrUtil.isArray(link)) {\n      option.axisPointer.link = [link];\n    }\n  }\n}); // This process should proformed after coordinate systems created\n// and series data processed. So put it on statistic processing stage.\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n  // allAxesInfo should be updated when setOption performed.\n  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);\n}); // Broadcast to all views.\n\necharts.registerAction({\n  type: 'updateAxisPointer',\n  event: 'updateAxisPointer',\n  update: ':updateAxisPointer'\n}, axisTrigger);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer.js\n// module id = 184\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar AxisBuilder = require(\"../axis/AxisBuilder\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\n\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get('label.precision'),\n    formatter: axisPointerModel.get('label.formatter')\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get('axisLine.lineStyle.color');\n  }\n\n  elOption.label = {\n    shape: {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      r: labelModel.get('borderRadius')\n    },\n    position: position.slice(),\n    // TODO: rich\n    style: {\n      text: text,\n      textFont: font,\n      textFill: labelModel.getTextColor(),\n      textPosition: 'inside',\n      fill: bgColor,\n      stroke: labelModel.get('borderColor') || 'transparent',\n      lineWidth: labelModel.get('borderWidth') || 0,\n      shadowBlur: labelModel.get('shadowBlur'),\n      shadowColor: labelModel.get('shadowColor'),\n      shadowOffsetX: labelModel.get('shadowOffsetX'),\n      shadowOffsetY: labelModel.get('shadowOffsetY')\n    },\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\n\n\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  value = axis.scale.parse(value);\n  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which\n  // helps to debounce when when moving label.\n  value, {\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params = {\n      value: axisHelper.getAxisRawValue(axis, value),\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params);\n    }\n  }\n\n  return text;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\n\n\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\n\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\n\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}\n\nexports.buildElStyle = buildElStyle;\nexports.buildLabelElOption = buildLabelElOption;\nexports.getValueLabel = getValueLabel;\nexports.getTransformedPosition = getTransformedPosition;\nexports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;\nexports.makeLineShape = makeLineShape;\nexports.makeRectShape = makeRectShape;\nexports.makeSectorShape = makeSectorShape;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/viewHelper.js\n// module id = 185\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} {point: [x, y], el: ...} point Will not be null.\n */\nfunction _default(finder, ecModel) {\n  var point = [];\n  var seriesIndex = finder.seriesIndex;\n  var seriesModel;\n\n  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {\n    return {\n      point: []\n    };\n  }\n\n  var data = seriesModel.getData();\n  var dataIndex = modelUtil.queryDataIndex(data, finder);\n\n  if (dataIndex == null || dataIndex < 0 || zrUtil.isArray(dataIndex)) {\n    return {\n      point: []\n    };\n  }\n\n  var el = data.getItemGraphicEl(dataIndex);\n  var coordSys = seriesModel.coordinateSystem;\n\n  if (seriesModel.getTooltipPosition) {\n    point = seriesModel.getTooltipPosition(dataIndex) || [];\n  } else if (coordSys && coordSys.dataToPoint) {\n    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {\n      return data.mapDimension(dim);\n    }), dataIndex, true)) || [];\n  } else if (el) {\n    // Use graphic bounding rect\n    var rect = el.getBoundingRect().clone();\n    rect.applyTransform(el.transform);\n    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n\n  return {\n    point: point,\n    el: el\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js\n// module id = 186\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\nvar each = zrUtil.each;\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n * @param {Function} handler\n *      param: {string} currTrigger\n *      param: {Array.<number>} point\n */\n\nfunction register(key, api, handler) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  inner(zr).records || (inner(zr).records = {});\n  initGlobalListeners(zr, api);\n  var record = inner(zr).records[key] || (inner(zr).records[key] = {});\n  record.handler = handler;\n}\n\nfunction initGlobalListeners(zr, api) {\n  if (inner(zr).initialized) {\n    return;\n  }\n\n  inner(zr).initialized = true;\n  useHandler('click', zrUtil.curry(doEnter, 'click'));\n  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);\n\n  useHandler('globalout', onLeave);\n\n  function useHandler(eventType, cb) {\n    zr.on(eventType, function (e) {\n      var dis = makeDispatchAction(api);\n      each(inner(zr).records, function (record) {\n        record && cb(record, e, dis.dispatchAction);\n      });\n      dispatchTooltipFinally(dis.pendings, api);\n    });\n  }\n}\n\nfunction dispatchTooltipFinally(pendings, api) {\n  var showLen = pendings.showTip.length;\n  var hideLen = pendings.hideTip.length;\n  var actuallyPayload;\n\n  if (showLen) {\n    actuallyPayload = pendings.showTip[showLen - 1];\n  } else if (hideLen) {\n    actuallyPayload = pendings.hideTip[hideLen - 1];\n  }\n\n  if (actuallyPayload) {\n    actuallyPayload.dispatchAction = null;\n    api.dispatchAction(actuallyPayload);\n  }\n}\n\nfunction onLeave(record, e, dispatchAction) {\n  record.handler('leave', null, dispatchAction);\n}\n\nfunction doEnter(currTrigger, record, e, dispatchAction) {\n  record.handler(currTrigger, e, dispatchAction);\n}\n\nfunction makeDispatchAction(api) {\n  var pendings = {\n    showTip: [],\n    hideTip: []\n  }; // FIXME\n  // better approach?\n  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n  // So we have to add \"final stage\" to merge those dispatched actions.\n\n  var dispatchAction = function (payload) {\n    var pendingList = pendings[payload.type];\n\n    if (pendingList) {\n      pendingList.push(payload);\n    } else {\n      payload.dispatchAction = dispatchAction;\n      api.dispatchAction(payload);\n    }\n  };\n\n  return {\n    dispatchAction: dispatchAction,\n    pendings: pendings\n  };\n}\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction unregister(key, api) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  var record = (inner(zr).records || {})[key];\n\n  if (record) {\n    inner(zr).records[key] = null;\n  }\n}\n\nexports.register = register;\nexports.unregister = unregister;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/globalListener.js\n// module id = 187\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../util/graphic\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./axis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/gridSimple.js\n// module id = 188\n// module chunks = 0 1 2 3 4","var graphic = require(\"../../util/graphic\");\n\nvar BaseAxisPointer = require(\"./BaseAxisPointer\");\n\nvar viewHelper = require(\"./viewHelper\");\n\nvar cartesianAxisHelper = require(\"../../coord/cartesian/cartesianAxisHelper\");\n\nvar AxisView = require(\"../axis/AxisView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar CartesianAxisPointer = BaseAxisPointer.extend({\n  /**\n   * @override\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisPointerType = axisPointerModel.get('type');\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = viewHelper.buildElStyle(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n\n    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n  },\n\n  /**\n   * @override\n   */\n  getHandleTransform: function (value, axisModel, axisPointerModel) {\n    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n      labelInside: false\n    });\n    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n    return {\n      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n    };\n  },\n\n  /**\n   * @override\n   */\n  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisExtent = axis.getGlobalExtent(true);\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var dimIndex = axis.dim === 'x' ? 0 : 1;\n    var currPosition = transform.position;\n    currPosition[dimIndex] += delta[dimIndex];\n    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n    var cursorPoint = [cursorOtherValue, cursorOtherValue];\n    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.\n\n    var tooltipOptions = [{\n      verticalAlign: 'middle'\n    }, {\n      align: 'center'\n    }];\n    return {\n      position: currPosition,\n      rotation: transform.rotation,\n      cursorPoint: cursorPoint,\n      tooltipOption: tooltipOptions[dimIndex]\n    };\n  }\n});\n\nfunction getCartesian(grid, axis) {\n  var opt = {};\n  opt[axis.dim + 'AxisIndex'] = axis.index;\n  return grid.getCartesian(opt);\n}\n\nvar pointerShapeBuilder = {\n  line: function (axis, pixelValue, otherExtent, elStyle) {\n    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));\n    graphic.subPixelOptimizeLine({\n      shape: targetShape,\n      style: elStyle\n    });\n    return {\n      type: 'Line',\n      shape: targetShape\n    };\n  },\n  shadow: function (axis, pixelValue, otherExtent, elStyle) {\n    var bandWidth = Math.max(1, axis.getBandWidth());\n    var span = otherExtent[1] - otherExtent[0];\n    return {\n      type: 'Rect',\n      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))\n    };\n  }\n};\n\nfunction getAxisDimIndex(axis) {\n  return axis.dim === 'x' ? 0 : 1;\n}\n\nAxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\nvar _default = CartesianAxisPointer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js\n// module id = 189\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Can only be called after coordinate system creation stage.\n * (Can be called before coordinate system update stage).\n *\n * @param {Object} opt {labelInside}\n * @return {Object} {\n *  position, rotation, labelDirection, labelOffset,\n *  tickDirection, labelRotate, z2\n * }\n */\nfunction layout(gridModel, axisModel, opt) {\n  opt = opt || {};\n  var grid = gridModel.coordinateSystem;\n  var axis = axisModel.axis;\n  var layout = {};\n  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];\n  var rawAxisPosition = axis.position;\n  var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;\n  var axisDim = axis.dim;\n  var rect = grid.getRect();\n  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n  var idx = {\n    left: 0,\n    right: 1,\n    top: 0,\n    bottom: 1,\n    onZero: 2\n  };\n  var axisOffset = axisModel.get('offset') || 0;\n  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n  if (otherAxisOnZeroOf) {\n    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));\n    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n  } // Axis position\n\n\n  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation\n\n  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim\n\n  var dirMap = {\n    top: -1,\n    bottom: 1,\n    left: -1,\n    right: 1\n  };\n  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n  layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n  if (axisModel.get('axisTick.inside')) {\n    layout.tickDirection = -layout.tickDirection;\n  }\n\n  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n    layout.labelDirection = -layout.labelDirection;\n  } // Special label rotation\n\n\n  var labelRotate = axisModel.get('axisLabel.rotate');\n  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea\n\n  layout.z2 = 1;\n  return layout;\n}\n\nexports.layout = layout;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js\n// module id = 190\n// module chunks = 0 1 2 3 4 5","var createDimensions = require(\"../../data/helper/createDimensions\");\n\nvar List = require(\"../../data/List\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListSimply.js\n// module id = 192\n// module chunks = 0 1 2 5 6","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\nvar axisModelCreator = require(\"../axisModelCreator\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/AxisModel.js\n// module id = 193\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar clazzUtil = require(\"../../util/clazz\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar axisPointerModelHelper = require(\"./modelHelper\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar throttleUtil = require(\"../../util/throttle\");\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\nvar clone = zrUtil.clone;\nvar bind = zrUtil.bind;\n/**\n * Base axis pointer class in 2D.\n * Implemenents {module:echarts/component/axis/IAxisPointer}.\n */\n\nfunction BaseAxisPointer() {}\n\nBaseAxisPointer.prototype = {\n  /**\n   * @private\n   */\n  _group: null,\n\n  /**\n   * @private\n   */\n  _lastGraphicKey: null,\n\n  /**\n   * @private\n   */\n  _handle: null,\n\n  /**\n   * @private\n   */\n  _dragging: false,\n\n  /**\n   * @private\n   */\n  _lastValue: null,\n\n  /**\n   * @private\n   */\n  _lastStatus: null,\n\n  /**\n   * @private\n   */\n  _payloadInfo: null,\n\n  /**\n   * In px, arbitrary value. Do not set too small,\n   * no animation is ok for most cases.\n   * @protected\n   */\n  animationThreshold: 15,\n\n  /**\n   * @implement\n   */\n  render: function (axisModel, axisPointerModel, api, forceRender) {\n    var value = axisPointerModel.get('value');\n    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not\n    // be replaced when user calling setOption in not merge mode.\n\n    this._axisModel = axisModel;\n    this._axisPointerModel = axisPointerModel;\n    this._api = api; // Optimize: `render` will be called repeatly during mouse move.\n    // So it is power consuming if performing `render` each time,\n    // especially on mobile device.\n\n    if (!forceRender && this._lastValue === value && this._lastStatus === status) {\n      return;\n    }\n\n    this._lastValue = value;\n    this._lastStatus = status;\n    var group = this._group;\n    var handle = this._handle;\n\n    if (!status || status === 'hide') {\n      // Do not clear here, for animation better.\n      group && group.hide();\n      handle && handle.hide();\n      return;\n    }\n\n    group && group.show();\n    handle && handle.show(); // Otherwise status is 'show'\n\n    var elOption = {};\n    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.\n\n    var graphicKey = elOption.graphicKey;\n\n    if (graphicKey !== this._lastGraphicKey) {\n      this.clear(api);\n    }\n\n    this._lastGraphicKey = graphicKey;\n    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);\n\n    if (!group) {\n      group = this._group = new graphic.Group();\n      this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n      this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n      api.getZr().add(group);\n    } else {\n      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n    }\n\n    updateMandatoryProps(group, axisPointerModel, true);\n\n    this._renderHandle(value);\n  },\n\n  /**\n   * @implement\n   */\n  remove: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @implement\n   */\n  dispose: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @protected\n   */\n  determineAnimation: function (axisModel, axisPointerModel) {\n    var animation = axisPointerModel.get('animation');\n    var axis = axisModel.axis;\n    var isCategoryAxis = axis.type === 'category';\n    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.\n\n    if (!useSnap && !isCategoryAxis) {\n      return false;\n    }\n\n    if (animation === 'auto' || animation == null) {\n      var animationThreshold = this.animationThreshold;\n\n      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n        return true;\n      } // It is important to auto animation when snap used. Consider if there is\n      // a dataZoom, animation will be disabled when too many points exist, while\n      // it will be enabled for better visual effect when little points exist.\n\n\n      if (useSnap) {\n        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n        var axisExtent = axis.getExtent(); // Approximate band width\n\n        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n      }\n\n      return false;\n    }\n\n    return animation === true;\n  },\n\n  /**\n   * add {pointer, label, graphicKey} to elOption\n   * @protected\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.\n  },\n\n  /**\n   * @protected\n   */\n  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n    var pointerOption = elOption.pointer;\n\n    if (pointerOption) {\n      var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));\n      group.add(pointerEl);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n    if (elOption.label) {\n      var labelEl = inner(group).labelEl = new graphic.Rect(clone(elOption.label));\n      group.add(labelEl);\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updatePointerEl: function (group, elOption, updateProps) {\n    var pointerEl = inner(group).pointerEl;\n\n    if (pointerEl) {\n      pointerEl.setStyle(elOption.pointer.style);\n      updateProps(pointerEl, {\n        shape: elOption.pointer.shape\n      });\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n    var labelEl = inner(group).labelEl;\n\n    if (labelEl) {\n      labelEl.setStyle(elOption.label.style);\n      updateProps(labelEl, {\n        // Consider text length change in vertical axis, animation should\n        // be used on shape, otherwise the effect will be weird.\n        shape: elOption.label.shape,\n        position: elOption.label.position\n      });\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _renderHandle: function (value) {\n    if (this._dragging || !this.updateHandleTransform) {\n      return;\n    }\n\n    var axisPointerModel = this._axisPointerModel;\n\n    var zr = this._api.getZr();\n\n    var handle = this._handle;\n    var handleModel = axisPointerModel.getModel('handle');\n    var status = axisPointerModel.get('status');\n\n    if (!handleModel.get('show') || !status || status === 'hide') {\n      handle && zr.remove(handle);\n      this._handle = null;\n      return;\n    }\n\n    var isInit;\n\n    if (!this._handle) {\n      isInit = true;\n      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {\n        cursor: 'move',\n        draggable: true,\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n        drift: bind(this._onHandleDragMove, this),\n        ondragend: bind(this._onHandleDragEnd, this)\n      });\n      zr.add(handle);\n    }\n\n    updateMandatoryProps(handle, axisPointerModel, false); // update style\n\n    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position\n\n    var handleSize = handleModel.get('size');\n\n    if (!zrUtil.isArray(handleSize)) {\n      handleSize = [handleSize, handleSize];\n    }\n\n    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');\n\n    this._moveHandleToValue(value, isInit);\n  },\n\n  /**\n   * @private\n   */\n  _moveHandleToValue: function (value, isInit) {\n    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragMove: function (dx, dy) {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    this._dragging = true; // Persistent for throttle.\n\n    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);\n    this._payloadInfo = trans;\n    handle.stopAnimation();\n    handle.attr(getHandleTransProps(trans));\n    inner(handle).lastProp = null;\n\n    this._doDispatchAxisPointer();\n  },\n\n  /**\n   * Throttled method.\n   * @private\n   */\n  _doDispatchAxisPointer: function () {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var payloadInfo = this._payloadInfo;\n    var axisModel = this._axisModel;\n\n    this._api.dispatchAction({\n      type: 'updateAxisPointer',\n      x: payloadInfo.cursorPoint[0],\n      y: payloadInfo.cursorPoint[1],\n      tooltipOption: payloadInfo.tooltipOption,\n      axesInfo: [{\n        axisDim: axisModel.axis.dim,\n        axisIndex: axisModel.componentIndex\n      }]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragEnd: function (moveAnimation) {\n    this._dragging = false;\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with\n    // axisPointer. So move handle to align the exact value position when\n    // drag ended.\n\n\n    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle\n    // button, and will be hidden after finger left handle button.\n\n\n    this._api.dispatchAction({\n      type: 'hideTip'\n    });\n  },\n\n  /**\n   * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {number} value\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0}\n   */\n  getHandleTransform: null,\n\n  /**\n   * * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {Object} transform {position, rotation}\n   * @param {Array.<number>} delta [dx, dy]\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n   */\n  updateHandleTransform: null,\n\n  /**\n   * @private\n   */\n  clear: function (api) {\n    this._lastValue = null;\n    this._lastStatus = null;\n    var zr = api.getZr();\n    var group = this._group;\n    var handle = this._handle;\n\n    if (zr && group) {\n      this._lastGraphicKey = null;\n      group && zr.remove(group);\n      handle && zr.remove(handle);\n      this._group = null;\n      this._handle = null;\n      this._payloadInfo = null;\n    }\n  },\n\n  /**\n   * @protected\n   */\n  doClear: function () {// Implemented by sub-class if necessary.\n  },\n\n  /**\n   * @protected\n   * @param {Array.<number>} xy\n   * @param {Array.<number>} wh\n   * @param {number} [xDimIndex=0] or 1\n   */\n  buildLabel: function (xy, wh, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n      x: xy[xDimIndex],\n      y: xy[1 - xDimIndex],\n      width: wh[xDimIndex],\n      height: wh[1 - xDimIndex]\n    };\n  }\n};\nBaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\nfunction updateProps(animationModel, moveAnimation, el, props) {\n  // Animation optimize.\n  if (!propsEqual(inner(el).lastProp, props)) {\n    inner(el).lastProp = props;\n    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));\n  }\n}\n\nfunction propsEqual(lastProps, newProps) {\n  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n    var equals = true;\n    zrUtil.each(newProps, function (item, key) {\n      equals = equals && propsEqual(lastProps[key], item);\n    });\n    return !!equals;\n  } else {\n    return lastProps === newProps;\n  }\n}\n\nfunction updateLabelShowHide(labelEl, axisPointerModel) {\n  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n}\n\nfunction getHandleTransProps(trans) {\n  return {\n    position: trans.position.slice(),\n    rotation: trans.rotation || 0\n  };\n}\n\nfunction updateMandatoryProps(group, axisPointerModel, silent) {\n  var z = axisPointerModel.get('z');\n  var zlevel = axisPointerModel.get('zlevel');\n  group && group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n      el.silent = silent;\n    }\n  });\n}\n\nclazzUtil.enableClassExtend(BaseAxisPointer);\nvar _default = BaseAxisPointer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js\n// module id = 194\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../echarts\");\n\nrequire(\"./axisPointer\");\n\nrequire(\"./tooltip/TooltipModel\");\n\nrequire(\"./tooltip/TooltipView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME Better way to pack data in graphic element\n\n/**\n * @action\n * @property {string} type\n * @property {number} seriesIndex\n * @property {number} dataIndex\n * @property {number} [x]\n * @property {number} [y]\n */\necharts.registerAction({\n  type: 'showTip',\n  event: 'showTip',\n  update: 'tooltip:manuallyShowTip'\n}, // noop\nfunction () {});\necharts.registerAction({\n  type: 'hideTip',\n  event: 'hideTip',\n  update: 'tooltip:manuallyHideTip'\n}, // noop\nfunction () {});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip.js\n// module id = 195\n// module chunks = 0 1 2 3 4 5","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\nvar each = _util.each;\nvar map = _util.map;\nvar indexOf = _util.indexOf;\nvar retrieve = _util.retrieve;\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar _axisHelper = require(\"../../coord/axisHelper\");\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar ifAxisCrossZero = _axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\nvar estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\nrequire(\"./GridModel\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxis ? [otherAxis] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxis;\n  var axisModel = axis.model;\n  var onZero = axisModel.get('axisLine.onZero');\n  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxis = otherAxes[onZeroAxisIndex];\n    }\n\n    return;\n  } // Find the first available other axis.\n\n\n  for (var idx in otherAxes) {\n    if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])) {\n      otherAxis = otherAxes[idx];\n      break;\n    }\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = estimateLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(data.mapDimension(axis.dim, true), function (dim) {\n      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension\n      // is [0.1, 0.5], the extent of the `stackResultDimension`\n      // is [7, 9], the final extent should not include [0.1, 0.5].\n      data, getStackedDimension(data, dim));\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Grid.js\n// module id = 196\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisDefault = require(\"./axisDefault\");\n\nvar ComponentModel = require(\"../model/Component\");\n\nvar _layout = require(\"../util/layout\");\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n\nvar OrdinalMeta = require(\"../data/OrdinalMeta\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      /**\n       * @readOnly\n       */\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n\n      /**\n       * @override\n       */\n      optionUpdated: function () {\n        var thisOption = this.option;\n\n        if (thisOption.type === 'category') {\n          this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);\n        }\n      },\n\n      /**\n       * Should not be called before all of 'getInitailData' finished.\n       * Because categories are collected during initializing data.\n       */\n      getCategories: function (rawData) {\n        var option = this.option; // FIXME\n        // warning if called before all of 'getInitailData' finished.\n\n        if (option.type === 'category') {\n          if (rawData) {\n            return option.data;\n          }\n\n          return this.__ordinalMeta.categories;\n        }\n      },\n      getOrdinalMeta: function () {\n        return this.__ordinalMeta;\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/axisModelCreator.js\n// module id = 197\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // By degree. By defualt auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // The arrow at both ends the the axis.\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  // Only usefull in the case like: category is\n  // ['2012-01-01', '2012-01-02', ...], where the input\n  // data has been ensured not duplicate and is large data.\n  // null means \"auto\":\n  // if axis.data provided, do not deduplication,\n  // else do deduplication.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For value axis, [GAP, GAP], where\n  // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)\n  boundaryGap: [0, 0],\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  // Min value of the axis. can be:\n  // + a number\n  // + 'dataMin': use the min value in data.\n  // + null/undefined: auto decide min value (consider pretty look and boundaryGap).\n  // min: null,\n  // Max value of the axis. can be:\n  // + a number\n  // + 'dataMax': use the max value in data.\n  // + null/undefined: auto decide max value (consider pretty look and boundaryGap).\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // Optional value can be:\n  // + `false`: always include value 0.\n  // + `true`: the extent do not consider value 0.\n  // scale: false,\n  // AxisTick and axisLabel and splitLine are caculated based on splitNumber.\n  splitNumber: 5 // Interval specifies the span of the ticks is mandatorily.\n  // interval: null\n  // Specify min interval when auto calculate tick interval.\n  // minInterval: null\n  // Specify max interval when auto calculate tick interval.\n  // maxInterval: null\n\n}, defaultOption);\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/axisDefault.js\n// module id = 198\n// module chunks = 0 1 2 3 4 6","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\n\nvar modelHelper = require(\"./modelHelper\");\n\nvar findPointFromSeries = require(\"./findPointFromSeries\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar curry = zrUtil.curry;\nvar inner = makeInner();\n/**\n * Basic logic: check all axis, if they do not demand show/highlight,\n * then hide/downplay them.\n *\n * @param {Object} coordSysAxesInfo\n * @param {Object} payload\n * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n * @param {Object} [payload.dataIndex] finder, restrict target axes.\n * @param {Object} [payload.axesInfo] finder, restrict target axes.\n *        [{\n *          axisDim: 'x'|'y'|'angle'|...,\n *          axisIndex: ...,\n *          value: ...\n *        }, ...]\n * @param {Function} [payload.dispatchAction]\n * @param {Object} [payload.tooltipOption]\n * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n *        which can be specified in dispatchAction\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n * @return {Object} content of event obj for echarts.connect.\n */\n\nfunction _default(payload, ecModel, api) {\n  var currTrigger = payload.currTrigger;\n  var point = [payload.x, payload.y];\n  var finder = payload;\n  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending\n  // See #6121. But we are not able to reproduce it yet.\n\n  if (!coordSysAxesInfo) {\n    return;\n  }\n\n  if (illegalPoint(point)) {\n    // Used in the default behavior of `connection`: use the sample seriesIndex\n    // and dataIndex. And also used in the tooltipView trigger.\n    point = findPointFromSeries({\n      seriesIndex: finder.seriesIndex,\n      // Do not use dataIndexInside from other ec instance.\n      // FIXME: auto detect it?\n      dataIndex: finder.dataIndex\n    }, ecModel).point;\n  }\n\n  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n  // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n  // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n  // and dataIndex.\n\n  var inputAxesInfo = finder.axesInfo;\n  var axesInfo = coordSysAxesInfo.axesInfo;\n  var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n  var outputFinder = {};\n  var showValueMap = {};\n  var dataByCoordSys = {\n    list: [],\n    map: {}\n  };\n  var updaters = {\n    showPointer: curry(showPointer, showValueMap),\n    showTooltip: curry(showTooltip, dataByCoordSys)\n  }; // Process for triggered axes.\n\n  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n    // If a point given, it must be contained by the coordinate system.\n    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n      var axis = axisInfo.axis;\n      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.\n\n      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n        var val = inputAxisInfo && inputAxisInfo.value;\n\n        if (val == null && !isIllegalPoint) {\n          val = axis.pointToData(point);\n        }\n\n        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n      }\n    });\n  }); // Process for linked axes.\n\n  var linkTriggers = {};\n  each(axesInfo, function (tarAxisInfo, tarKey) {\n    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.\n\n    if (linkGroup && !showValueMap[tarKey]) {\n      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.\n\n        if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n          var val = srcValItem.value;\n          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));\n          linkTriggers[tarAxisInfo.key] = val;\n        }\n      });\n    }\n  });\n  each(linkTriggers, function (val, tarKey) {\n    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n  });\n  updateModelActually(showValueMap, axesInfo, outputFinder);\n  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n  dispatchHighDownActually(axesInfo, dispatchAction, api);\n  return outputFinder;\n}\n\nfunction processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n  var axis = axisInfo.axis;\n\n  if (axis.scale.isBlank() || !axis.containData(newValue)) {\n    return;\n  }\n\n  if (!axisInfo.involveSeries) {\n    updaters.showPointer(axisInfo, newValue);\n    return;\n  } // Heavy calculation. So put it after axis.containData checking.\n\n\n  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n  var payloadBatch = payloadInfo.payloadBatch;\n  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.\n  // By defualt use the first involved series data as a sample to connect.\n\n  if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n    zrUtil.extend(outputFinder, payloadBatch[0]);\n  } // If no linkSource input, this process is for collecting link\n  // target, where snap should not be accepted.\n\n\n  if (!dontSnap && axisInfo.snap) {\n    if (axis.containData(snapToValue) && snapToValue != null) {\n      newValue = snapToValue;\n    }\n  }\n\n  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be\n  // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n\n  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n}\n\nfunction buildPayloadsBySeries(value, axisInfo) {\n  var axis = axisInfo.axis;\n  var dim = axis.dim;\n  var snapToValue = value;\n  var payloadBatch = [];\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n  each(axisInfo.seriesModels, function (series, idx) {\n    var dataDim = series.getData().mapDimension(dim, true);\n    var seriesNestestValue;\n    var dataIndices;\n\n    if (series.getAxisTooltipData) {\n      var result = series.getAxisTooltipData(dataDim, value, axis);\n      dataIndices = result.dataIndices;\n      seriesNestestValue = result.nestestValue;\n    } else {\n      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex\n      // when data length is not same.\n      // false,\n      axis.type === 'category' ? 0.5 : null);\n\n      if (!dataIndices.length) {\n        return;\n      }\n\n      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n    }\n\n    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n      return;\n    }\n\n    var diff = value - seriesNestestValue;\n    var dist = Math.abs(diff); // Consider category case\n\n    if (dist <= minDist) {\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        snapToValue = seriesNestestValue;\n        payloadBatch.length = 0;\n      }\n\n      each(dataIndices, function (dataIndex) {\n        payloadBatch.push({\n          seriesIndex: series.seriesIndex,\n          dataIndexInside: dataIndex,\n          dataIndex: series.getData().getRawIndex(dataIndex)\n        });\n      });\n    }\n  });\n  return {\n    payloadBatch: payloadBatch,\n    snapToValue: snapToValue\n  };\n}\n\nfunction showPointer(showValueMap, axisInfo, value, payloadBatch) {\n  showValueMap[axisInfo.key] = {\n    value: value,\n    payloadBatch: payloadBatch\n  };\n}\n\nfunction showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n  var payloadBatch = payloadInfo.payloadBatch;\n  var axis = axisInfo.axis;\n  var axisModel = axis.model;\n  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,\n  // whose length will be used to judge whether dispatch action.\n\n  if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n    return;\n  }\n\n  var coordSysModel = axisInfo.coordSys.model;\n  var coordSysKey = modelHelper.makeKey(coordSysModel);\n  var coordSysItem = dataByCoordSys.map[coordSysKey];\n\n  if (!coordSysItem) {\n    coordSysItem = dataByCoordSys.map[coordSysKey] = {\n      coordSysId: coordSysModel.id,\n      coordSysIndex: coordSysModel.componentIndex,\n      coordSysType: coordSysModel.type,\n      coordSysMainType: coordSysModel.mainType,\n      dataByAxis: []\n    };\n    dataByCoordSys.list.push(coordSysItem);\n  }\n\n  coordSysItem.dataByAxis.push({\n    axisDim: axis.dim,\n    axisIndex: axisModel.componentIndex,\n    axisType: axisModel.type,\n    axisId: axisModel.id,\n    value: value,\n    // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n    // depends that all models have been updated. So it should not be performed\n    // here. Considering axisPointerModel used here is volatile, which is hard\n    // to be retrieve in TooltipView, we prepare parameters here.\n    valueLabelOpt: {\n      precision: axisPointerModel.get('label.precision'),\n      formatter: axisPointerModel.get('label.formatter')\n    },\n    seriesDataIndices: payloadBatch.slice()\n  });\n}\n\nfunction updateModelActually(showValueMap, axesInfo, outputFinder) {\n  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    var valItem = showValueMap[key];\n\n    if (valItem) {\n      !axisInfo.useHandle && (option.status = 'show');\n      option.value = valItem.value; // For label formatter param and highlight.\n\n      option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n    } // When always show (e.g., handle used), remain\n    // original value and status.\n    else {\n        // If hide, value still need to be set, consider\n        // click legend to toggle axis blank.\n        !axisInfo.useHandle && (option.status = 'hide');\n      } // If status is 'hide', should be no info in payload.\n\n\n    option.status === 'show' && outputAxesInfo.push({\n      axisDim: axisInfo.axis.dim,\n      axisIndex: axisInfo.axis.model.componentIndex,\n      value: option.value\n    });\n  });\n}\n\nfunction dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n  // Basic logic: If no showTip required, hideTip will be dispatched.\n  if (illegalPoint(point) || !dataByCoordSys.list.length) {\n    dispatchAction({\n      type: 'hideTip'\n    });\n    return;\n  } // In most case only one axis (or event one series is used). It is\n  // convinient to fetch payload.seriesIndex and payload.dataIndex\n  // dirtectly. So put the first seriesIndex and dataIndex of the first\n  // axis on the payload.\n\n\n  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n  dispatchAction({\n    type: 'showTip',\n    escapeConnect: true,\n    x: point[0],\n    y: point[1],\n    tooltipOption: payload.tooltipOption,\n    position: payload.position,\n    dataIndexInside: sampleItem.dataIndexInside,\n    dataIndex: sampleItem.dataIndex,\n    seriesIndex: sampleItem.seriesIndex,\n    dataByCoordSys: dataByCoordSys.list\n  });\n}\n\nfunction dispatchHighDownActually(axesInfo, dispatchAction, api) {\n  // FIXME\n  // highlight status modification shoule be a stage of main process?\n  // (Consider confilct (e.g., legend and axisPointer) and setOption)\n  var zr = api.getZr();\n  var highDownKey = 'axisPointerLastHighlights';\n  var lastHighlights = inner(zr)[highDownKey] || {};\n  var newHighlights = inner(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.\n  // Build hash map and remove duplicate incidentally.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n      newHighlights[key] = batchItem;\n    });\n  }); // Diff.\n\n  var toHighlight = [];\n  var toDownplay = [];\n  zrUtil.each(lastHighlights, function (batchItem, key) {\n    !newHighlights[key] && toDownplay.push(batchItem);\n  });\n  zrUtil.each(newHighlights, function (batchItem, key) {\n    !lastHighlights[key] && toHighlight.push(batchItem);\n  });\n  toDownplay.length && api.dispatchAction({\n    type: 'downplay',\n    escapeConnect: true,\n    batch: toDownplay\n  });\n  toHighlight.length && api.dispatchAction({\n    type: 'highlight',\n    escapeConnect: true,\n    batch: toHighlight\n  });\n}\n\nfunction findInputAxisInfo(inputAxesInfo, axisInfo) {\n  for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n    var inputAxisInfo = inputAxesInfo[i];\n\n    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {\n      return inputAxisInfo;\n    }\n  }\n}\n\nfunction makeMapperParam(axisInfo) {\n  var axisModel = axisInfo.axis.model;\n  var item = {};\n  var dim = item.axisDim = axisInfo.axis.dim;\n  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n  item.axisName = item[dim + 'AxisName'] = axisModel.name;\n  item.axisId = item[dim + 'AxisId'] = axisModel.id;\n  return item;\n}\n\nfunction illegalPoint(point) {\n  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/axisTrigger.js\n// module id = 201\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../../echarts\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisPointerModel = echarts.extendComponentModel({\n  type: 'axisPointer',\n  coordSysAxesInfo: null,\n  defaultOption: {\n    // 'auto' means that show when triggered by tooltip or handle.\n    show: 'auto',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: null,\n    // set default in AxisPonterView.js\n    zlevel: 0,\n    z: 50,\n    type: 'line',\n    // axispointer triggered by tootip determine snap automatically,\n    // see `modelHelper`.\n    snap: false,\n    triggerTooltip: true,\n    value: null,\n    status: null,\n    // Init value depends on whether handle is used.\n    // [group0, group1, ...]\n    // Each group can be: {\n    //      mapper: function () {},\n    //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n    //      xAxisId: ...,\n    //      yAxisName: ...,\n    //      angleAxisIndex: ...\n    // }\n    // mapper: can be ignored.\n    //      input: {axisInfo, value}\n    //      output: {axisInfo, value}\n    link: [],\n    // Do not set 'auto' here, otherwise global animation: false\n    // will not effect at this axispointer.\n    animation: null,\n    animationDurationUpdate: 200,\n    lineStyle: {\n      color: '#aaa',\n      width: 1,\n      type: 'solid'\n    },\n    shadowStyle: {\n      color: 'rgba(150,150,150,0.3)'\n    },\n    label: {\n      show: true,\n      formatter: null,\n      // string | Function\n      precision: 'auto',\n      // Or a number like 0, 1, 2 ...\n      margin: 3,\n      color: '#fff',\n      padding: [5, 7, 5, 7],\n      backgroundColor: 'auto',\n      // default: axis line color\n      borderColor: null,\n      borderWidth: 0,\n      shadowBlur: 3,\n      shadowColor: '#aaa' // Considering applicability, common style should\n      // better not have shadowOffset.\n      // shadowOffsetX: 0,\n      // shadowOffsetY: 2\n\n    },\n    handle: {\n      show: false,\n      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',\n      // jshint ignore:line\n      size: 45,\n      // handle margin is from symbol center to axis, which is stable when circular move.\n      margin: 50,\n      // color: '#1b8bbd'\n      // color: '#2f4554'\n      color: '#333',\n      shadowBlur: 3,\n      shadowColor: '#aaa',\n      shadowOffsetX: 0,\n      shadowOffsetY: 2,\n      // For mobile performance\n      throttle: 40\n    }\n  }\n});\nvar _default = AxisPointerModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js\n// module id = 202\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../../echarts\");\n\nvar globalListener = require(\"./globalListener\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisPointerView = echarts.extendComponentView({\n  type: 'axisPointer',\n  render: function (globalAxisPointerModel, ecModel, api) {\n    var globalTooltipModel = ecModel.getComponent('tooltip');\n    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable\n    // AxisPointerView to be independent to Tooltip.\n\n    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {\n        dispatchAction({\n          type: 'updateAxisPointer',\n          currTrigger: currTrigger,\n          x: e && e.offsetX,\n          y: e && e.offsetY\n        });\n      }\n    });\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    globalListener.unregister(api.getZr(), 'axisPointer');\n    AxisPointerView.superApply(this._model, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    globalListener.unregister('axisPointer', api);\n    AxisPointerView.superApply(this._model, 'dispose', arguments);\n  }\n});\nvar _default = AxisPointerView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js\n// module id = 203\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../../echarts\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = echarts.extendComponentModel({\n  type: 'tooltip',\n  dependencies: ['axisPointer'],\n  defaultOption: {\n    zlevel: 0,\n    z: 8,\n    show: true,\n    // tooltip\n    showContent: true,\n    // 'trigger' only works on coordinate system.\n    // 'item' | 'axis' | 'none'\n    trigger: 'item',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: 'mousemove|click',\n    alwaysShowContent: false,\n    displayMode: 'single',\n    // 'single' | 'multipleByCoordSys'\n    //  {Array} | {Function}\n    // position: null\n    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n    // align: null,\n    // verticalAlign: null,\n    //  content  viewRect  false \n    confine: false,\n    // {string}Template  {Function}\n    // formatter: null\n    showDelay: 0,\n    // ms\n    hideDelay: 100,\n    // s\n    transitionDuration: 0.4,\n    enterable: false,\n    // 0.7\n    backgroundColor: 'rgba(50,50,50,0.7)',\n    // \n    borderColor: '#333',\n    // px4\n    borderRadius: 4,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // Extra css text\n    extraCssText: '',\n    // \n    axisPointer: {\n      // \n      // 'line' | 'shadow' | 'cross'\n      type: 'line',\n      // type  line  tooltip line \n      //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n      //  'auto' category  x \n      //  angle \n      axis: 'auto',\n      animation: 'auto',\n      animationDurationUpdate: 200,\n      animationEasingUpdate: 'exponentialOut',\n      crossStyle: {\n        color: '#999',\n        width: 1,\n        type: 'dashed',\n        // TODO formatter\n        textStyle: {} // lineStyle and shadowStyle should not be specified here,\n        // otherwise it will always override those styles on option.axisPointer.\n\n      }\n    },\n    textStyle: {\n      color: '#fff',\n      fontSize: 14\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 204\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar TooltipContent = require(\"./TooltipContent\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar findPointFromSeries = require(\"../axisPointer/findPointFromSeries\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar Model = require(\"../../model/Model\");\n\nvar globalListener = require(\"../axisPointer/globalListener\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar axisPointerViewHelper = require(\"../axisPointer/viewHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar bind = zrUtil.bind;\nvar each = zrUtil.each;\nvar parsePercent = numberUtil.parsePercent;\nvar proxyRect = new graphic.Rect({\n  shape: {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  }\n});\n\nvar _default = echarts.extendComponentView({\n  type: 'tooltip',\n  init: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    var tooltipContent = new TooltipContent(api.getDom(), api);\n    this._tooltipContent = tooltipContent;\n  },\n  render: function (tooltipModel, ecModel, api) {\n    if (env.node || env.wxa) {\n      return;\n    } // Reset\n\n\n    this.group.removeAll();\n    /**\n     * @private\n     * @type {module:echarts/component/tooltip/TooltipModel}\n     */\n\n    this._tooltipModel = tooltipModel;\n    /**\n     * @private\n     * @type {module:echarts/model/Global}\n     */\n\n    this._ecModel = ecModel;\n    /**\n     * @private\n     * @type {module:echarts/ExtensionAPI}\n     */\n\n    this._api = api;\n    /**\n     * Should be cleaned when render.\n     * @private\n     * @type {Array.<Array.<Object>>}\n     */\n\n    this._lastDataByCoordSys = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n    var tooltipContent = this._tooltipContent;\n    tooltipContent.update();\n    tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n    this._initGlobalListener();\n\n    this._keepShow();\n  },\n  _initGlobalListener: function () {\n    var tooltipModel = this._tooltipModel;\n    var triggerOn = tooltipModel.get('triggerOn');\n    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none') {\n        if (triggerOn.indexOf(currTrigger) >= 0) {\n          this._tryShow(e, dispatchAction);\n        } else if (currTrigger === 'leave') {\n          this._hide(dispatchAction);\n        }\n      }\n    }, this));\n  },\n  _keepShow: function () {\n    var tooltipModel = this._tooltipModel;\n    var ecModel = this._ecModel;\n    var api = this._api; // Try to keep the tooltip show when refreshing\n\n    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,\n    // self.manuallyShowTip({x, y}) might cause tooltip hide,\n    // which is not expected.\n    && tooltipModel.get('triggerOn') !== 'none') {\n      var self = this;\n      clearTimeout(this._refreshUpdateTimeout);\n      this._refreshUpdateTimeout = setTimeout(function () {\n        // Show tip next tick after other charts are rendered\n        // In case highlight action has wrong result\n        // FIXME\n        self.manuallyShowTip(tooltipModel, ecModel, api, {\n          x: self._lastX,\n          y: self._lastY\n        });\n      });\n    }\n  },\n\n  /**\n   * Show tip manually by\n   * dispatchAction({\n   *     type: 'showTip',\n   *     x: 10,\n   *     y: 10\n   * });\n   * Or\n   * dispatchAction({\n   *      type: 'showTip',\n   *      seriesIndex: 0,\n   *      dataIndex or dataIndexInside or name\n   * });\n   *\n   *  TODO Batch\n   */\n  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n    if (payload.from === this.uid || env.node) {\n      return;\n    }\n\n    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket\n\n    this._ticket = ''; // When triggered from axisPointer.\n\n    var dataByCoordSys = payload.dataByCoordSys;\n\n    if (payload.tooltip && payload.x != null && payload.y != null) {\n      var el = proxyRect;\n      el.position = [payload.x, payload.y];\n      el.update();\n      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        target: el\n      }, dispatchAction);\n    } else if (dataByCoordSys) {\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        event: {},\n        dataByCoordSys: payload.dataByCoordSys,\n        tooltipOption: payload.tooltipOption\n      }, dispatchAction);\n    } else if (payload.seriesIndex != null) {\n      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n        return;\n      }\n\n      var pointInfo = findPointFromSeries(payload, ecModel);\n      var cx = pointInfo.point[0];\n      var cy = pointInfo.point[1];\n\n      if (cx != null && cy != null) {\n        this._tryShow({\n          offsetX: cx,\n          offsetY: cy,\n          position: payload.position,\n          target: pointInfo.el,\n          event: {}\n        }, dispatchAction);\n      }\n    } else if (payload.x != null && payload.y != null) {\n      // FIXME\n      // should wrap dispatchAction like `axisPointer/globalListener` ?\n      api.dispatchAction({\n        type: 'updateAxisPointer',\n        x: payload.x,\n        y: payload.y\n      });\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        target: api.getZr().findHover(payload.x, payload.y).target,\n        event: {}\n      }, dispatchAction);\n    }\n  },\n  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n    var tooltipContent = this._tooltipContent;\n\n    if (!this._alwaysShowContent && this._tooltipModel) {\n      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n    }\n\n    this._lastX = this._lastY = null;\n\n    if (payload.from !== this.uid) {\n      this._hide(makeDispatchAction(payload, api));\n    }\n  },\n  // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n  // and tooltip.\n  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n    var seriesIndex = payload.seriesIndex;\n    var dataIndex = payload.dataIndex;\n    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n      return;\n    }\n\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n    if (!seriesModel) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);\n\n    if (tooltipModel.get('trigger') !== 'axis') {\n      return;\n    }\n\n    api.dispatchAction({\n      type: 'updateAxisPointer',\n      seriesIndex: seriesIndex,\n      dataIndex: dataIndex,\n      position: payload.position\n    });\n    return true;\n  },\n  _tryShow: function (e, dispatchAction) {\n    var el = e.target;\n    var tooltipModel = this._tooltipModel;\n\n    if (!tooltipModel) {\n      return;\n    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\n\n    this._lastX = e.offsetX;\n    this._lastY = e.offsetY;\n    var dataByCoordSys = e.dataByCoordSys;\n\n    if (dataByCoordSys && dataByCoordSys.length) {\n      this._showAxisTooltip(dataByCoordSys, e);\n    } // Always show item tooltip if mouse is on the element with dataIndex\n    else if (el && el.dataIndex != null) {\n        this._lastDataByCoordSys = null;\n\n        this._showSeriesItemTooltip(e, el, dispatchAction);\n      } // Tooltip provided directly. Like legend.\n      else if (el && el.tooltip) {\n          this._lastDataByCoordSys = null;\n\n          this._showComponentItemTooltip(e, el, dispatchAction);\n        } else {\n          this._lastDataByCoordSys = null;\n\n          this._hide(dispatchAction);\n        }\n  },\n  _showOrMove: function (tooltipModel, cb) {\n    // showDelay is used in this case: tooltip.enterable is set\n    // as true. User intent to move mouse into tooltip and click\n    // something. `showDelay` makes it easyer to enter the content\n    // but tooltip do not move immediately.\n    var delay = tooltipModel.get('showDelay');\n    cb = zrUtil.bind(cb, this);\n    clearTimeout(this._showTimout);\n    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();\n  },\n  _showAxisTooltip: function (dataByCoordSys, e) {\n    var ecModel = this._ecModel;\n    var globalTooltipModel = this._tooltipModel;\n    var point = [e.offsetX, e.offsetY];\n    var singleDefaultHTML = [];\n    var singleParamsList = [];\n    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);\n    each(dataByCoordSys, function (itemCoordSys) {\n      // var coordParamList = [];\n      // var coordDefaultHTML = [];\n      // var coordTooltipModel = buildTooltipModel([\n      //     e.tooltipOption,\n      //     itemCoordSys.tooltipOption,\n      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n      //     globalTooltipModel\n      // ]);\n      // var displayMode = coordTooltipModel.get('displayMode');\n      // var paramsList = displayMode === 'single' ? singleParamsList : [];\n      each(itemCoordSys.dataByAxis, function (item) {\n        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n        var axisValue = item.value;\n        var seriesDefaultHTML = [];\n\n        if (!axisModel || axisValue == null) {\n          return;\n        }\n\n        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);\n        zrUtil.each(item.seriesDataIndices, function (idxItem) {\n          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n          var dataIndex = idxItem.dataIndexInside;\n          var dataParams = series && series.getDataParams(dataIndex);\n          dataParams.axisDim = item.axisDim;\n          dataParams.axisIndex = item.axisIndex;\n          dataParams.axisType = item.axisType;\n          dataParams.axisId = item.axisId;\n          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n          dataParams.axisValueLabel = valueLabel;\n\n          if (dataParams) {\n            singleParamsList.push(dataParams);\n            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n          }\n        }); // Default tooltip content\n        // FIXME\n        // (1) shold be the first data which has name?\n        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\n        var firstLine = valueLabel;\n        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));\n      });\n    }, this); // In most case, the second axis is shown upper than the first one.\n\n    singleDefaultHTML.reverse();\n    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n    var positionExpr = e.position;\n\n    this._showOrMove(singleTooltipModel, function () {\n      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);\n      } else {\n        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);\n      }\n    }); // Do not trigger events here, because this branch only be entered\n    // from dispatchAction.\n\n  },\n  _showSeriesItemTooltip: function (e, el, dispatchAction) {\n    var ecModel = this._ecModel; // Use dataModel in element if possible\n    // Used when mouseover on a element like markPoint or edge\n    // In which case, the data is not main data in series.\n\n    var seriesIndex = el.seriesIndex;\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.\n\n    var dataModel = el.dataModel || seriesModel;\n    var dataIndex = el.dataIndex;\n    var dataType = el.dataType;\n    var data = dataModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);\n    var tooltipTrigger = tooltipModel.get('trigger');\n\n    if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n      return;\n    }\n\n    var params = dataModel.getDataParams(dataIndex, dataType);\n    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n    this._showOrMove(tooltipModel, function () {\n      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);\n    }); // FIXME\n    // duplicated showtip if manuallyShowTip is called from dispatchAction.\n\n\n    dispatchAction({\n      type: 'showTip',\n      dataIndexInside: dataIndex,\n      dataIndex: data.getRawIndex(dataIndex),\n      seriesIndex: seriesIndex,\n      from: this.uid\n    });\n  },\n  _showComponentItemTooltip: function (e, el, dispatchAction) {\n    var tooltipOpt = el.tooltip;\n\n    if (typeof tooltipOpt === 'string') {\n      var content = tooltipOpt;\n      tooltipOpt = {\n        content: content,\n        // Fixed formatter\n        formatter: content\n      };\n    }\n\n    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n    var defaultHtml = subTooltipModel.get('content');\n    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`\n    // only works on cooridinate system. In fact, we have not found case\n    // that requires setting `trigger` nothing on component yet.\n\n    this._showOrMove(subTooltipModel, function () {\n      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);\n    }); // If not dispatch showTip, tip may be hide triggered by axis.\n\n\n    dispatchAction({\n      type: 'showTip',\n      from: this.uid\n    });\n  },\n  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\n    // Reset ticket\n    this._ticket = '';\n\n    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n      return;\n    }\n\n    var tooltipContent = this._tooltipContent;\n    var formatter = tooltipModel.get('formatter');\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var html = defaultHtml;\n\n    if (formatter && typeof formatter === 'string') {\n      html = formatUtil.formatTpl(formatter, params, true);\n    } else if (typeof formatter === 'function') {\n      var callback = bind(function (cbTicket, html) {\n        if (cbTicket === this._ticket) {\n          tooltipContent.setContent(html);\n\n          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n        }\n      }, this);\n      this._ticket = asyncTicket;\n      html = formatter(params, asyncTicket, callback);\n    }\n\n    tooltipContent.setContent(html);\n    tooltipContent.show(tooltipModel);\n\n    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n  },\n\n  /**\n   * @param  {string|Function|Array.<number>|Object} positionExpr\n   * @param  {number} x Mouse x\n   * @param  {number} y Mouse y\n   * @param  {boolean} confine Whether confine tooltip content in view rect.\n   * @param  {Object|<Array.<Object>} params\n   * @param  {module:zrender/Element} el target element\n   * @param  {module:echarts/ExtensionAPI} api\n   * @return {Array.<number>}\n   */\n  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n    var viewWidth = this._api.getWidth();\n\n    var viewHeight = this._api.getHeight();\n\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var contentSize = content.getSize();\n    var align = tooltipModel.get('align');\n    var vAlign = tooltipModel.get('verticalAlign');\n    var rect = el && el.getBoundingRect().clone();\n    el && rect.applyTransform(el.transform);\n\n    if (typeof positionExpr === 'function') {\n      // Callback of position can be an array or a string specify the position\n      positionExpr = positionExpr([x, y], params, content.el, rect, {\n        viewSize: [viewWidth, viewHeight],\n        contentSize: contentSize.slice()\n      });\n    }\n\n    if (zrUtil.isArray(positionExpr)) {\n      x = parsePercent(positionExpr[0], viewWidth);\n      y = parsePercent(positionExpr[1], viewHeight);\n    } else if (zrUtil.isObject(positionExpr)) {\n      positionExpr.width = contentSize[0];\n      positionExpr.height = contentSize[1];\n      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {\n        width: viewWidth,\n        height: viewHeight\n      });\n      x = layoutRect.x;\n      y = layoutRect.y;\n      align = null; // When positionExpr is left/top/right/bottom,\n      // align and verticalAlign will not work.\n\n      vAlign = null;\n    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n    else if (typeof positionExpr === 'string' && el) {\n        var pos = calcTooltipPosition(positionExpr, rect, contentSize);\n        x = pos[0];\n        y = pos[1];\n      } else {\n        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);\n        x = pos[0];\n        y = pos[1];\n      }\n\n    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n    if (tooltipModel.get('confine')) {\n      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);\n      x = pos[0];\n      y = pos[1];\n    }\n\n    content.moveTo(x, y);\n  },\n  // FIXME\n  // Should we remove this but leave this to user?\n  _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n    var lastCoordSys = this._lastDataByCoordSys;\n    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;\n    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n        var thisItem = thisDataByAxis[indexAxis] || {};\n        var lastIndices = lastItem.seriesDataIndices || [];\n        var newIndices = thisItem.seriesDataIndices || [];\n        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;\n        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n          var newIdxItem = newIndices[j];\n          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n        });\n      });\n    });\n    this._lastDataByCoordSys = dataByCoordSys;\n    return !!contentNotChanged;\n  },\n  _hide: function (dispatchAction) {\n    // Do not directly hideLater here, because this behavior may be prevented\n    // in dispatchAction when showTip is dispatched.\n    // FIXME\n    // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n    this._lastDataByCoordSys = null;\n    dispatchAction({\n      type: 'hideTip',\n      from: this.uid\n    });\n  },\n  dispose: function (ecModel, api) {\n    if (env.node || env.wxa) {\n      return;\n    }\n\n    this._tooltipContent.hide();\n\n    globalListener.unregister('itemTooltip', api);\n  }\n});\n/**\n * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n * From top to bottom. (the last one should be globalTooltipModel);\n */\n\n\nfunction buildTooltipModel(modelCascade) {\n  var resultModel = modelCascade.pop();\n\n  while (modelCascade.length) {\n    var tooltipOpt = modelCascade.pop();\n\n    if (tooltipOpt) {\n      if (Model.isInstance(tooltipOpt)) {\n        tooltipOpt = tooltipOpt.get('tooltip', true);\n      } // In each data item tooltip can be simply write:\n      // {\n      //  value: 10,\n      //  tooltip: 'Something you need to know'\n      // }\n\n\n      if (typeof tooltipOpt === 'string') {\n        tooltipOpt = {\n          formatter: tooltipOpt\n        };\n      }\n\n      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n    }\n  }\n\n  return resultModel;\n}\n\nfunction makeDispatchAction(payload, api) {\n  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n}\n\nfunction refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n\n  if (gapH != null) {\n    if (x + width + gapH > viewWidth) {\n      x -= width + gapH;\n    } else {\n      x += gapH;\n    }\n  }\n\n  if (gapV != null) {\n    if (y + height + gapV > viewHeight) {\n      y -= height + gapV;\n    } else {\n      y += gapV;\n    }\n  }\n\n  return [x, y];\n}\n\nfunction confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n  x = Math.min(x + width, viewWidth) - width;\n  y = Math.min(y + height, viewHeight) - height;\n  x = Math.max(x, 0);\n  y = Math.max(y, 0);\n  return [x, y];\n}\n\nfunction getOuterSize(el) {\n  var width = el.clientWidth;\n  var height = el.clientHeight; // Consider browser compatibility.\n  // IE8 does not support getComputedStyle.\n\n  if (document.defaultView && document.defaultView.getComputedStyle) {\n    var stl = document.defaultView.getComputedStyle(el);\n\n    if (stl) {\n      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nfunction calcTooltipPosition(position, rect, contentSize) {\n  var domWidth = contentSize[0];\n  var domHeight = contentSize[1];\n  var gap = 5;\n  var x = 0;\n  var y = 0;\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n\n  switch (position) {\n    case 'inside':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'top':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y - domHeight - gap;\n      break;\n\n    case 'bottom':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight + gap;\n      break;\n\n    case 'left':\n      x = rect.x - domWidth - gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'right':\n      x = rect.x + rectWidth + gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n  }\n\n  return [x, y];\n}\n\nfunction isCenterAlign(align) {\n  return align === 'center' || align === 'middle';\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipView.js\n// module id = 205\n// module chunks = 0 1 2 3 4 5","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar eventUtil = require(\"zrender/lib/core/event\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar formatUtil = require(\"../../util/format\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar toCamelCase = formatUtil.toCamelCase;\nvar vendors = ['', '-webkit-', '-moz-', '-o-'];\nvar gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n/**\n * @param {number} duration\n * @return {string}\n * @inner\n */\n\nfunction assembleTransition(duration) {\n  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;\n  return zrUtil.map(vendors, function (vendorPrefix) {\n    return vendorPrefix + 'transition:' + transitionText;\n  }).join(';');\n}\n/**\n * @param {Object} textStyle\n * @return {string}\n * @inner\n */\n\n\nfunction assembleFont(textStyleModel) {\n  var cssText = [];\n  var fontSize = textStyleModel.get('fontSize');\n  var color = textStyleModel.getTextColor();\n  color && cssText.push('color:' + color);\n  cssText.push('font:' + textStyleModel.getFont());\n  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n  each(['decoration', 'align'], function (name) {\n    var val = textStyleModel.get(name);\n    val && cssText.push('text-' + name + ':' + val);\n  });\n  return cssText.join(';');\n}\n/**\n * @param {Object} tooltipModel\n * @return {string}\n * @inner\n */\n\n\nfunction assembleCssText(tooltipModel) {\n  var cssText = [];\n  var transitionDuration = tooltipModel.get('transitionDuration');\n  var backgroundColor = tooltipModel.get('backgroundColor');\n  var textStyleModel = tooltipModel.getModel('textStyle');\n  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.\n\n  transitionDuration && cssText.push(assembleTransition(transitionDuration));\n\n  if (backgroundColor) {\n    if (env.canvasSupported) {\n      cssText.push('background-Color:' + backgroundColor);\n    } else {\n      // for ie\n      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));\n      cssText.push('filter:alpha(opacity=70)');\n    }\n  } // Border style\n\n\n  each(['width', 'color', 'radius'], function (name) {\n    var borderName = 'border-' + name;\n    var camelCase = toCamelCase(borderName);\n    var val = tooltipModel.get(camelCase);\n    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n  }); // Text style\n\n  cssText.push(assembleFont(textStyleModel)); // Padding\n\n  if (padding != null) {\n    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n  }\n\n  return cssText.join(';') + ';';\n}\n/**\n * @alias module:echarts/component/tooltip/TooltipContent\n * @constructor\n */\n\n\nfunction TooltipContent(container, api) {\n  if (env.wxa) {\n    return null;\n  }\n\n  var el = document.createElement('div');\n  var zr = this._zr = api.getZr();\n  this.el = el;\n  this._x = api.getWidth() / 2;\n  this._y = api.getHeight() / 2;\n  container.appendChild(el);\n  this._container = container;\n  this._show = false;\n  /**\n   * @private\n   */\n\n  this._hideTimeout;\n  var self = this;\n\n  el.onmouseenter = function () {\n    // clear the timeout in hideLater and keep showing tooltip\n    if (self._enterable) {\n      clearTimeout(self._hideTimeout);\n      self._show = true;\n    }\n\n    self._inContent = true;\n  };\n\n  el.onmousemove = function (e) {\n    e = e || window.event;\n\n    if (!self._enterable) {\n      // Try trigger zrender event to avoid mouse\n      // in and out shape too frequently\n      var handler = zr.handler;\n      eventUtil.normalizeEvent(container, e, true);\n      handler.dispatch('mousemove', e);\n    }\n  };\n\n  el.onmouseleave = function () {\n    if (self._enterable) {\n      if (self._show) {\n        self.hideLater(self._hideDelay);\n      }\n    }\n\n    self._inContent = false;\n  };\n}\n\nTooltipContent.prototype = {\n  constructor: TooltipContent,\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  _enterable: true,\n\n  /**\n   * Update when tooltip is rendered\n   */\n  update: function () {\n    // FIXME\n    // Move this logic to ec main?\n    var container = this._container;\n    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);\n    var domStyle = container.style;\n\n    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n      domStyle.position = 'relative';\n    } // Hide the tooltip\n    // PENDING\n    // this.hide();\n\n  },\n  show: function (tooltipModel) {\n    clearTimeout(this._hideTimeout);\n    var el = this.el;\n    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');\n    el.style.display = el.innerHTML ? 'block' : 'none';\n    this._show = true;\n  },\n  setContent: function (content) {\n    this.el.innerHTML = content == null ? '' : content;\n  },\n  setEnterable: function (enterable) {\n    this._enterable = enterable;\n  },\n  getSize: function () {\n    var el = this.el;\n    return [el.clientWidth, el.clientHeight];\n  },\n  moveTo: function (x, y) {\n    // xy should be based on canvas root. But tooltipContent is\n    // the sibling of canvas root. So padding of ec container\n    // should be considered here.\n    var zr = this._zr;\n    var viewportRootOffset;\n\n    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n      x += viewportRootOffset.offsetLeft;\n      y += viewportRootOffset.offsetTop;\n    }\n\n    var style = this.el.style;\n    style.left = x + 'px';\n    style.top = y + 'px';\n    this._x = x;\n    this._y = y;\n  },\n  hide: function () {\n    this.el.style.display = 'none';\n    this._show = false;\n  },\n  hideLater: function (time) {\n    if (this._show && !(this._inContent && this._enterable)) {\n      if (time) {\n        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times\n\n        this._show = false;\n        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n      } else {\n        this.hide();\n      }\n    }\n  },\n  isShow: function () {\n    return this._show;\n  }\n};\nvar _default = TooltipContent;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipContent.js\n// module id = 206\n// module chunks = 0 1 2 3 4 5","var echarts = require(\"../echarts\");\n\nrequire(\"./legend/LegendModel\");\n\nrequire(\"./legend/legendAction\");\n\nrequire(\"./legend/LegendView\");\n\nvar legendFilter = require(\"./legend/legendFilter\");\n\nvar Component = require(\"../model/Component\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend.js\n// module id = 209\n// module chunks = 0 1 2 3 5","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _model = require(\"../../util/model\");\n\nvar isNameSpecified = _model.isNameSpecified;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // \n    zlevel: 0,\n    // \n    z: 4,\n    show: true,\n    // \n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // \n    // 'auto' | 'left' | 'right'\n    //  'auto',  x \n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // \n    borderColor: '#ccc',\n    borderRadius: 0,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // itempx10\n    // \n    itemGap: 10,\n    // \n    itemWidth: 25,\n    // \n    itemHeight: 14,\n    // \n    inactiveColor: '#ccc',\n    textStyle: {\n      // \n      color: '#333'\n    },\n    // formatter: '',\n    // \n    selectedMode: true,\n    // LEGEND.SELECTED\n    // selected: null,\n    // legend.dataitem\n    // data: [],\n    // Tooltip \n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendModel.js\n// module id = 210\n// module chunks = 0 1 2 3 5","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _listComponent = require(\"../helper/listComponent\");\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = require(\"../../util/layout\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    var excludeSeriesId = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);\n    });\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      } // Representitive series.\n\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api, excludeSeriesId));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode); // FIXME: consider different series has items with the same name.\n\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api, excludeSeriesId));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var symbolKeepAspect = legendModel.get('symbolKeepAspect');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend\n    symbolKeepAspect == null ? true : symbolKeepAspect)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend\n      symbolKeepAspect == null ? true : symbolKeepAspect));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendView.js\n// module id = 211\n// module chunks = 0 1 2 3 5","var _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/listComponent.js\n// module id = 212\n// module chunks = 0 1 2 3 5","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendAction.js\n// module id = 215\n// module chunks = 0 1 2 3 5","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendFilter.js\n// module id = 216\n// module chunks = 0 1 2 3 5","require(\"./gridSimple\");\n\nrequire(\"./axisPointer/CartesianAxisPointer\");\n\nrequire(\"./axisPointer\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/grid.js\n// module id = 217\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Cartesian = require(\"./Cartesian\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, reserved, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  clampData: function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));\n    return out;\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 218\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Cartesian.js\n// module id = 219\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * Implemented in <module:echarts/coord/cartesian/Grid>.\n   * @return {Array.<module:echarts/coord/cartesian/Axis2D>}\n   *         If not on zero of other axis, return null/undefined.\n   *         If no axes, return an empty array.\n   */\n  getAxesOnZeroOf: null,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/Axis2D.js\n// module id = 220\n// module chunks = 0 1 2 3 4","require(\"./AxisModel\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid \n//  Cartesian2D \nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/cartesian/GridModel.js\n// module id = 221\n// module chunks = 0 1 2 3 4","require(\"../coord/cartesian/AxisModel\");\n\nrequire(\"./axis/CartesianAxisView\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis.js\n// module id = 222\n// module chunks = 0 1 2 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"../../coord/cartesian/cartesianAxisHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n  remove: function () {\n    this._splitAreaColors = null;\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitAreaModel,\n      clamp: true\n    });\n\n    if (!ticksCoords.length) {\n      return;\n    } // For Making appropriate splitArea animation, the color and anid\n    // should be corresponding to previous one if possible.\n\n\n    var areaColorsLen = areaColors.length;\n    var lastSplitAreaColors = this._splitAreaColors;\n    var newSplitAreaColors = zrUtil.createHashMap();\n    var colorIndex = 0;\n\n    if (lastSplitAreaColors) {\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n        if (cIndex != null) {\n          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n          break;\n        }\n      }\n    }\n\n    var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prev;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n        prev = x + width;\n      } else {\n        x = gridRect.x;\n        y = prev;\n        width = gridRect.width;\n        height = tickCoord - y;\n        prev = y + height;\n      }\n\n      var tickValue = ticksCoords[i - 1].tickValue;\n      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: tickValue != null ? 'area_' + tickValue : null,\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      colorIndex = (colorIndex + 1) % areaColorsLen;\n    }\n\n    this._splitAreaColors = newSplitAreaColors;\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/CartesianAxisView.js\n// module id = 223\n// module chunks = 0 1 2 3 4","var graphic = require(\"../../util/graphic\");\n\nvar LineGroup = require(\"./Line\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/LineDraw\n */\n// import IncrementalDisplayable from 'zrender/src/graphic/IncrementalDisplayable';\n\n/**\n * @alias module:echarts/component/marker/LineDraw\n * @constructor\n */\nfunction LineDraw(ctor) {\n  this._ctor = ctor || LineGroup;\n  this.group = new graphic.Group();\n}\n\nvar lineDrawProto = LineDraw.prototype;\n\nlineDrawProto.isPersistent = function () {\n  return true;\n};\n/**\n * @param {module:echarts/data/List} lineData\n */\n\n\nlineDrawProto.updateData = function (lineData) {\n  var lineDraw = this;\n  var group = lineDraw.group;\n  var oldLineData = lineDraw._lineData;\n  lineDraw._lineData = lineData; // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldLineData) {\n    group.removeAll();\n  }\n\n  var seriesScope = makeSeriesScope(lineData);\n  lineData.diff(oldLineData).add(function (idx) {\n    doAdd(lineDraw, lineData, idx, seriesScope);\n  }).update(function (newIdx, oldIdx) {\n    doUpdate(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);\n  }).remove(function (idx) {\n    group.remove(oldLineData.getItemGraphicEl(idx));\n  }).execute();\n};\n\nfunction doAdd(lineDraw, lineData, idx, seriesScope) {\n  var itemLayout = lineData.getItemLayout(idx);\n\n  if (!lineNeedsDraw(itemLayout)) {\n    return;\n  }\n\n  var el = new lineDraw._ctor(lineData, idx, seriesScope);\n  lineData.setItemGraphicEl(idx, el);\n  lineDraw.group.add(el);\n}\n\nfunction doUpdate(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {\n  var itemEl = oldLineData.getItemGraphicEl(oldIdx);\n\n  if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {\n    lineDraw.group.remove(itemEl);\n    return;\n  }\n\n  if (!itemEl) {\n    itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);\n  } else {\n    itemEl.updateData(newLineData, newIdx, seriesScope);\n  }\n\n  newLineData.setItemGraphicEl(newIdx, itemEl);\n  lineDraw.group.add(itemEl);\n}\n\nlineDrawProto.updateLayout = function () {\n  var lineData = this._lineData; // Do not support update layout in incremental mode.\n\n  if (!lineData) {\n    return;\n  }\n\n  lineData.eachItemGraphicEl(function (el, idx) {\n    el.updateLayout(lineData, idx);\n  }, this);\n};\n\nlineDrawProto.incrementalPrepareUpdate = function (lineData) {\n  this._seriesScope = makeSeriesScope(lineData);\n  this._lineData = null;\n  this.group.removeAll();\n};\n\nlineDrawProto.incrementalUpdate = function (taskParams, lineData) {\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var itemLayout = lineData.getItemLayout(idx);\n\n    if (lineNeedsDraw(itemLayout)) {\n      var el = new this._ctor(lineData, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      this.group.add(el);\n      lineData.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction makeSeriesScope(lineData) {\n  var hostModel = lineData.hostModel;\n  return {\n    lineStyle: hostModel.getModel('lineStyle').getLineStyle(),\n    hoverLineStyle: hostModel.getModel('emphasis.lineStyle').getLineStyle(),\n    labelModel: hostModel.getModel('label'),\n    hoverLabelModel: hostModel.getModel('emphasis.label')\n  };\n}\n\nlineDrawProto.remove = function () {\n  this._clearIncremental();\n\n  this._incremental = null;\n  this.group.removeAll();\n};\n\nlineDrawProto._clearIncremental = function () {\n  var incremental = this._incremental;\n\n  if (incremental) {\n    incremental.clearDisplaybles();\n  }\n};\n\nfunction isPointNaN(pt) {\n  return isNaN(pt[0]) || isNaN(pt[1]);\n}\n\nfunction lineNeedsDraw(pts) {\n  return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n}\n\nvar _default = LineDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/LineDraw.js\n// module id = 241\n// module chunks = 0 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar vector = require(\"zrender/lib/core/vector\");\n\nvar symbolUtil = require(\"../../util/symbol\");\n\nvar LinePath = require(\"./LinePath\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar round = _number.round;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/Line\n */\nvar SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n\nfunction makeSymbolTypeKey(symbolCategory) {\n  return '_' + symbolCategory + 'Type';\n}\n/**\n * @inner\n */\n\n\nfunction createSymbol(name, lineData, idx) {\n  var color = lineData.getItemVisual(idx, 'color');\n  var symbolType = lineData.getItemVisual(idx, name);\n  var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n\n  if (!symbolType || symbolType === 'none') {\n    return;\n  }\n\n  if (!zrUtil.isArray(symbolSize)) {\n    symbolSize = [symbolSize, symbolSize];\n  }\n\n  var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);\n  symbolPath.name = name;\n  return symbolPath;\n}\n\nfunction createLine(points) {\n  var line = new LinePath({\n    name: 'line'\n  });\n  setLinePoints(line.shape, points);\n  return line;\n}\n\nfunction setLinePoints(targetShape, points) {\n  var p1 = points[0];\n  var p2 = points[1];\n  var cp1 = points[2];\n  targetShape.x1 = p1[0];\n  targetShape.y1 = p1[1];\n  targetShape.x2 = p2[0];\n  targetShape.y2 = p2[1];\n  targetShape.percent = 1;\n\n  if (cp1) {\n    targetShape.cpx1 = cp1[0];\n    targetShape.cpy1 = cp1[1];\n  } else {\n    targetShape.cpx1 = NaN;\n    targetShape.cpy1 = NaN;\n  }\n}\n\nfunction updateSymbolAndLabelBeforeLineUpdate() {\n  var lineGroup = this;\n  var symbolFrom = lineGroup.childOfName('fromSymbol');\n  var symbolTo = lineGroup.childOfName('toSymbol');\n  var label = lineGroup.childOfName('label'); // Quick reject\n\n  if (!symbolFrom && !symbolTo && label.ignore) {\n    return;\n  }\n\n  var invScale = 1;\n  var parentNode = this.parent;\n\n  while (parentNode) {\n    if (parentNode.scale) {\n      invScale /= parentNode.scale[0];\n    }\n\n    parentNode = parentNode.parent;\n  }\n\n  var line = lineGroup.childOfName('line'); // If line not changed\n  // FIXME Parent scale changed\n\n  if (!this.__dirty && !line.__dirty) {\n    return;\n  }\n\n  var percent = line.shape.percent;\n  var fromPos = line.pointAt(0);\n  var toPos = line.pointAt(percent);\n  var d = vector.sub([], toPos, fromPos);\n  vector.normalize(d, d);\n\n  if (symbolFrom) {\n    symbolFrom.attr('position', fromPos);\n    var tangent = line.tangentAt(0);\n    symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n    symbolFrom.attr('scale', [invScale * percent, invScale * percent]);\n  }\n\n  if (symbolTo) {\n    symbolTo.attr('position', toPos);\n    var tangent = line.tangentAt(1);\n    symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n    symbolTo.attr('scale', [invScale * percent, invScale * percent]);\n  }\n\n  if (!label.ignore) {\n    label.attr('position', toPos);\n    var textPosition;\n    var textAlign;\n    var textVerticalAlign;\n    var distance = 5 * invScale; // End\n\n    if (label.__position === 'end') {\n      textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];\n      textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';\n      textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';\n    } // Middle\n    else if (label.__position === 'middle') {\n        var halfPercent = percent / 2;\n        var tangent = line.tangentAt(halfPercent);\n        var n = [tangent[1], -tangent[0]];\n        var cp = line.pointAt(halfPercent);\n\n        if (n[1] > 0) {\n          n[0] = -n[0];\n          n[1] = -n[1];\n        }\n\n        textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];\n        textAlign = 'center';\n        textVerticalAlign = 'bottom';\n        var rotation = -Math.atan2(tangent[1], tangent[0]);\n\n        if (toPos[0] < fromPos[0]) {\n          rotation = Math.PI + rotation;\n        }\n\n        label.attr('rotation', rotation);\n      } // Start\n      else {\n          textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];\n          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';\n          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';\n        }\n\n    label.attr({\n      style: {\n        // Use the user specified text align and baseline first\n        textVerticalAlign: label.__verticalAlign || textVerticalAlign,\n        textAlign: label.__textAlign || textAlign\n      },\n      position: textPosition,\n      scale: [invScale, invScale]\n    });\n  }\n}\n/**\n * @constructor\n * @extends {module:zrender/graphic/Group}\n * @alias {module:echarts/chart/helper/Line}\n */\n\n\nfunction Line(lineData, idx, seriesScope) {\n  graphic.Group.call(this);\n\n  this._createLine(lineData, idx, seriesScope);\n}\n\nvar lineProto = Line.prototype; // Update symbol position and rotation\n\nlineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;\n\nlineProto._createLine = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var linePoints = lineData.getItemLayout(idx);\n  var line = createLine(linePoints);\n  line.shape.percent = 0;\n  graphic.initProps(line, {\n    shape: {\n      percent: 1\n    }\n  }, seriesModel, idx);\n  this.add(line);\n  var label = new graphic.Text({\n    name: 'label'\n  });\n  this.add(label);\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure\n    // it will be updated after line#update.\n    // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n\n    this.add(symbol);\n    this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n  }, this);\n\n  this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto.updateData = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var line = this.childOfName('line');\n  var linePoints = lineData.getItemLayout(idx);\n  var target = {\n    shape: {}\n  };\n  setLinePoints(target.shape, linePoints);\n  graphic.updateProps(line, target, seriesModel, idx);\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbolType = lineData.getItemVisual(idx, symbolCategory);\n    var key = makeSymbolTypeKey(symbolCategory); // Symbol changed\n\n    if (this[key] !== symbolType) {\n      this.remove(this.childOfName(symbolCategory));\n      var symbol = createSymbol(symbolCategory, lineData, idx);\n      this.add(symbol);\n    }\n\n    this[key] = symbolType;\n  }, this);\n\n  this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n  var seriesModel = lineData.hostModel;\n  var line = this.childOfName('line');\n  var lineStyle = seriesScope && seriesScope.lineStyle;\n  var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset\n\n  if (!seriesScope || lineData.hasItemOption) {\n    var itemModel = lineData.getItemModel(idx);\n    lineStyle = itemModel.getModel('lineStyle').getLineStyle();\n    hoverLineStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();\n    labelModel = itemModel.getModel('label');\n    hoverLabelModel = itemModel.getModel('emphasis.label');\n  }\n\n  var visualColor = lineData.getItemVisual(idx, 'color');\n  var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);\n  line.useStyle(zrUtil.defaults({\n    strokeNoScale: true,\n    fill: 'none',\n    stroke: visualColor,\n    opacity: visualOpacity\n  }, lineStyle));\n  line.hoverStyle = hoverLineStyle; // Update symbol\n\n  zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n    var symbol = this.childOfName(symbolCategory);\n\n    if (symbol) {\n      symbol.setColor(visualColor);\n      symbol.setStyle({\n        opacity: visualOpacity\n      });\n    }\n  }, this);\n  var showLabel = labelModel.getShallow('show');\n  var hoverShowLabel = hoverLabelModel.getShallow('show');\n  var label = this.childOfName('label');\n  var defaultLabelColor;\n  var baseText; // FIXME: the logic below probably should be merged to `graphic.setLabelStyle`.\n\n  if (showLabel || hoverShowLabel) {\n    defaultLabelColor = visualColor || '#000';\n    baseText = seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType);\n\n    if (baseText == null) {\n      var rawVal = seriesModel.getRawValue(idx);\n      baseText = rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;\n    }\n  }\n\n  var normalText = showLabel ? baseText : null;\n  var emphasisText = hoverShowLabel ? zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), baseText) : null;\n  var labelStyle = label.style; // Always set `textStyle` even if `normalStyle.text` is null, because default\n  // values have to be set on `normalStyle`.\n\n  if (normalText != null || emphasisText != null) {\n    graphic.setTextStyle(label.style, labelModel, {\n      text: normalText\n    }, {\n      autoColor: defaultLabelColor\n    });\n    label.__textAlign = labelStyle.textAlign;\n    label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'\n\n    label.__position = labelModel.get('position') || 'middle';\n  }\n\n  if (emphasisText != null) {\n    // Only these properties supported in this emphasis style here.\n    label.hoverStyle = {\n      text: emphasisText,\n      textFill: hoverLabelModel.getTextColor(true),\n      // For merging hover style to normal style, do not use\n      // `hoverLabelModel.getFont()` here.\n      fontStyle: hoverLabelModel.getShallow('fontStyle'),\n      fontWeight: hoverLabelModel.getShallow('fontWeight'),\n      fontSize: hoverLabelModel.getShallow('fontSize'),\n      fontFamily: hoverLabelModel.getShallow('fontFamily')\n    };\n  } else {\n    label.hoverStyle = {\n      text: null\n    };\n  }\n\n  label.ignore = !showLabel && !hoverShowLabel;\n  graphic.setHoverStyle(this);\n};\n\nlineProto.highlight = function () {\n  this.trigger('emphasis');\n};\n\nlineProto.downplay = function () {\n  this.trigger('normal');\n};\n\nlineProto.updateLayout = function (lineData, idx) {\n  this.setLinePoints(lineData.getItemLayout(idx));\n};\n\nlineProto.setLinePoints = function (points) {\n  var linePath = this.childOfName('line');\n  setLinePoints(linePath.shape, points);\n  linePath.dirty();\n};\n\nzrUtil.inherits(Line, graphic.Group);\nvar _default = Line;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/Line.js\n// module id = 242\n// module chunks = 0 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar dataFormatMixin = require(\"../../model/mixin/dataFormat\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar addCommas = formatUtil.addCommas;\nvar encodeHTML = formatUtil.encodeHTML;\n\nfunction fillLabel(opt) {\n  modelUtil.defaultEmphasis(opt, 'label', ['show']);\n}\n\nvar MarkerModel = echarts.extendComponentModel({\n  type: 'marker',\n  dependencies: ['series', 'grid', 'polar', 'geo'],\n\n  /**\n   * @overrite\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  },\n  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n    var MarkerModel = this.constructor;\n    var modelPropName = this.mainType + 'Model';\n\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        var markerOpt = seriesModel.get(this.mainType, true);\n        var markerModel = seriesModel[modelPropName];\n\n        if (!markerOpt || !markerOpt.data) {\n          seriesModel[modelPropName] = null;\n          return;\n        }\n\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n\n          zrUtil.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = new MarkerModel(markerOpt, this, ecModel);\n          zrUtil.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel.mergeOption(markerOpt, ecModel, true);\n        }\n\n        seriesModel[modelPropName] = markerModel;\n      }, this);\n    }\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n    var name = data.getName(dataIndex);\n    var html = encodeHTML(this.name);\n\n    if (value != null || name) {\n      html += '<br />';\n    }\n\n    if (name) {\n      html += encodeHTML(name);\n\n      if (value != null) {\n        html += ' : ';\n      }\n    }\n\n    if (value != null) {\n      html += encodeHTML(formattedValue);\n    }\n\n    return html;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setData: function (data) {\n    this._data = data;\n  }\n});\nzrUtil.mixin(MarkerModel, dataFormatMixin);\nvar _default = MarkerModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkerModel.js\n// module id = 246\n// module chunks = 0 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n} // Make it simple, do not visit all stacked value to count precision.\n// function getPrecision(data, valueAxisDim, dataIndex) {\n//     var precision = -1;\n//     var stackedDim = data.mapDimension(valueAxisDim);\n//     do {\n//         precision = Math.max(\n//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),\n//             precision\n//         );\n//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n//         if (stackedOnSeries) {\n//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);\n//             data = stackedOnSeries.getData();\n//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);\n//             stackedDim = data.getCalculationInfo('stackedDimension');\n//         }\n//         else {\n//             data = null;\n//         }\n//     } while (data);\n//     return precision;\n// }\n\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim\n  /*, otherDataDim*/\n  );\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n\n  return ret;\n}\n\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var data = seriesModel.getData();\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    });\n    return sum / count;\n  } else if (type === 'median') {\n    return data.getMedian(valueDataDim);\n  } else {\n    // max & min\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/markerHelper.js\n// module id = 247\n// module chunks = 0 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = echarts.extendComponentView({\n  type: 'marker',\n  init: function () {\n    /**\n     * Markline grouped by series\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this.markerGroupMap = zrUtil.createHashMap();\n  },\n  render: function (markerModel, ecModel, api) {\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      item.__keep = false;\n    });\n    var markerModelKey = this.type + 'Model';\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = seriesModel[markerModelKey];\n      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n    }, this);\n    markerGroupMap.each(function (item) {\n      !item.__keep && this.group.remove(item.group);\n    }, this);\n  },\n  renderSeries: function () {}\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkerView.js\n// module id = 248\n// module chunks = 0 2","var createListSimply = require(\"../helper/createListSimply\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _dimensionHelper = require(\"../../data/helper/dimensionHelper\");\n\nvar getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar seriesModelMixin = {\n  /**\n   * @private\n   * @type {string}\n   */\n  _baseAxisDim: null,\n\n  /**\n   * @override\n   */\n  getInitialData: function (option, ecModel) {\n    // When both types of xAxis and yAxis are 'value', layout is\n    // needed to be specified by user. Otherwise, layout can be\n    // judged by which axis is category.\n    var ordinalMeta;\n    var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));\n    var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));\n    var xAxisType = xAxisModel.get('type');\n    var yAxisType = yAxisModel.get('type');\n    var addOrdinal; // FIXME\n    // \n\n    if (xAxisType === 'category') {\n      option.layout = 'horizontal';\n      ordinalMeta = xAxisModel.getOrdinalMeta();\n      addOrdinal = true;\n    } else if (yAxisType === 'category') {\n      option.layout = 'vertical';\n      ordinalMeta = yAxisModel.getOrdinalMeta();\n      addOrdinal = true;\n    } else {\n      option.layout = option.layout || 'horizontal';\n    }\n\n    var coordDims = ['x', 'y'];\n    var baseAxisDimIndex = option.layout === 'horizontal' ? 0 : 1;\n    var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];\n    var otherAxisDim = coordDims[1 - baseAxisDimIndex];\n    var axisModels = [xAxisModel, yAxisModel];\n    var baseAxisType = axisModels[baseAxisDimIndex].get('type');\n    var otherAxisType = axisModels[1 - baseAxisDimIndex].get('type');\n    var data = option.data; // ??? FIXME make a stage to perform data transfrom.\n    // MUST create a new data, consider setOption({}) again.\n\n    if (data && addOrdinal) {\n      var newOptionData = [];\n      zrUtil.each(data, function (item, index) {\n        var newItem;\n\n        if (item.value && zrUtil.isArray(item.value)) {\n          newItem = item.value.slice();\n          item.value.unshift(index);\n        } else if (zrUtil.isArray(item)) {\n          newItem = item.slice();\n          item.unshift(index);\n        } else {\n          newItem = item;\n        }\n\n        newOptionData.push(newItem);\n      });\n      option.data = newOptionData;\n    }\n\n    var defaultValueDimensions = this.defaultValueDimensions;\n    return createListSimply(this, {\n      coordDimensions: [{\n        name: baseAxisDim,\n        type: getDimensionTypeByAxis(baseAxisType),\n        ordinalMeta: ordinalMeta,\n        otherDims: {\n          tooltip: false,\n          itemName: 0\n        },\n        dimsDef: ['base']\n      }, {\n        name: otherAxisDim,\n        type: getDimensionTypeByAxis(otherAxisType),\n        dimsDef: defaultValueDimensions.slice()\n      }],\n      dimensionsCount: defaultValueDimensions.length + 1\n    });\n  },\n\n  /**\n   * If horizontal, base axis is x, otherwise y.\n   * @override\n   */\n  getBaseAxis: function () {\n    var dim = this._baseAxisDim;\n    return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;\n  }\n};\nexports.seriesModelMixin = seriesModelMixin;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js\n// module id = 253\n// module chunks = 0 2","var graphic = require(\"../../util/graphic\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Line path for bezier and straight line draw\n */\nvar straightLineProto = graphic.Line.prototype;\nvar bezierCurveProto = graphic.BezierCurve.prototype;\n\nfunction isLine(shape) {\n  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n}\n\nvar _default = graphic.extendShape({\n  type: 'ec-line',\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    percent: 1,\n    cpx1: null,\n    cpy1: null\n  },\n  buildPath: function (ctx, shape) {\n    (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);\n  },\n  pointAt: function (t) {\n    return isLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);\n  },\n  tangentAt: function (t) {\n    var shape = this.shape;\n    var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/LinePath.js\n// module id = 264\n// module chunks = 0 2","var echarts = require(\"../echarts\");\n\nrequire(\"./candlestick/CandlestickSeries\");\n\nrequire(\"./candlestick/CandlestickView\");\n\nvar preprocessor = require(\"./candlestick/preprocessor\");\n\nvar candlestickVisual = require(\"./candlestick/candlestickVisual\");\n\nvar candlestickLayout = require(\"./candlestick/candlestickLayout\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\necharts.registerPreprocessor(preprocessor);\necharts.registerVisual(candlestickVisual);\necharts.registerLayout(candlestickLayout);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/candlestick.js\n// module id = 277\n// module chunks = 0 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar _whiskerBoxCommon = require(\"../helper/whiskerBoxCommon\");\n\nvar seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar CandlestickSeries = SeriesModel.extend({\n  type: 'series.candlestick',\n  dependencies: ['xAxis', 'yAxis', 'grid'],\n\n  /**\n   * @readOnly\n   */\n  defaultValueDimensions: [{\n    name: 'open',\n    defaultTooltip: true\n  }, {\n    name: 'close',\n    defaultTooltip: true\n  }, {\n    name: 'lowest',\n    defaultTooltip: true\n  }, {\n    name: 'highest',\n    defaultTooltip: true\n  }],\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: null,\n\n  /**\n   * @override\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    layout: null,\n    // 'horizontal' or 'vertical'\n    itemStyle: {\n      color: '#c23531',\n      //  positive\n      color0: '#314656',\n      //  negative     '#c23531', '#314656'\n      borderWidth: 1,\n      // FIXME\n      // ec2lineStyle.color  lineStyle.color0\n      borderColor: '#c23531',\n      borderColor0: '#314656'\n    },\n    emphasis: {\n      itemStyle: {\n        borderWidth: 2\n      }\n    },\n    barMaxWidth: null,\n    barMinWidth: null,\n    barWidth: null,\n    large: true,\n    largeThreshold: 600,\n    progressive: 5e3,\n    progressiveThreshold: 1e4,\n    progressiveChunkMode: 'mod',\n    animationUpdate: false,\n    animationEasing: 'linear',\n    animationDuration: 300\n  },\n\n  /**\n   * Get dimension for shadow in dataZoom\n   * @return {string} dimension name\n   */\n  getShadowDim: function () {\n    return 'open';\n  },\n  brushSelector: function (dataIndex, data, selectors) {\n    var itemLayout = data.getItemLayout(dataIndex);\n    return itemLayout && selectors.rect(itemLayout.brushRect);\n  }\n});\nzrUtil.mixin(CandlestickSeries, seriesModelMixin, true);\nvar _default = CandlestickSeries;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js\n// module id = 278\n// module chunks = 0 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Path = require(\"zrender/lib/graphic/Path\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar NORMAL_ITEM_STYLE_PATH = ['itemStyle'];\nvar EMPHASIS_ITEM_STYLE_PATH = ['emphasis', 'itemStyle'];\nvar SKIP_PROPS = ['color', 'color0', 'borderColor', 'borderColor0'];\nvar CandlestickView = ChartView.extend({\n  type: 'candlestick',\n  render: function (seriesModel, ecModel, api) {\n    this._updateDrawMode(seriesModel);\n\n    this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);\n  },\n  incrementalPrepareRender: function (seriesModel, ecModel, api) {\n    this._clear();\n\n    this._updateDrawMode(seriesModel);\n  },\n  incrementalRender: function (params, seriesModel, ecModel, api) {\n    this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);\n  },\n  _updateDrawMode: function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n\n    if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n\n      this._clear();\n    }\n  },\n  _renderNormal: function (seriesModel) {\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var isSimpleBox = data.getLayout('isSimpleBox'); // There is no old data only when first rendering or switching from\n    // stream mode to normal mode, where previous elements should be removed.\n\n    if (!this._data) {\n      group.removeAll();\n    }\n\n    data.diff(oldData).add(function (newIdx) {\n      if (data.hasValue(newIdx)) {\n        var el;\n        var itemLayout = data.getItemLayout(newIdx);\n        el = createNormalBox(itemLayout, newIdx, true);\n        graphic.initProps(el, {\n          shape: {\n            points: itemLayout.ends\n          }\n        }, seriesModel, newIdx);\n        setBoxCommon(el, data, newIdx, isSimpleBox);\n        group.add(el);\n        data.setItemGraphicEl(newIdx, el);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx); // Empty data\n\n      if (!data.hasValue(newIdx)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemLayout = data.getItemLayout(newIdx);\n\n      if (!el) {\n        el = createNormalBox(itemLayout, newIdx);\n      } else {\n        graphic.updateProps(el, {\n          shape: {\n            points: itemLayout.ends\n          }\n        }, seriesModel, newIdx);\n      }\n\n      setBoxCommon(el, data, newIdx, isSimpleBox);\n      group.add(el);\n      data.setItemGraphicEl(newIdx, el);\n    }).remove(function (oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      el && group.remove(el);\n    }).execute();\n    this._data = data;\n  },\n  _renderLarge: function (seriesModel) {\n    this._clear();\n\n    createLarge(seriesModel, this.group);\n  },\n  _incrementalRenderNormal: function (params, seriesModel) {\n    var data = seriesModel.getData();\n    var isSimpleBox = data.getLayout('isSimpleBox');\n    var dataIndex;\n\n    while ((dataIndex = params.next()) != null) {\n      var el;\n      var itemLayout = data.getItemLayout(dataIndex);\n      el = createNormalBox(itemLayout, dataIndex);\n      setBoxCommon(el, data, dataIndex, isSimpleBox);\n      el.incremental = true;\n      this.group.add(el);\n    }\n  },\n  _incrementalRenderLarge: function (params, seriesModel) {\n    createLarge(seriesModel, this.group, true);\n  },\n  remove: function (ecModel) {\n    this._clear();\n  },\n  _clear: function () {\n    this.group.removeAll();\n    this._data = null;\n  },\n  dispose: zrUtil.noop\n});\nvar NormalBoxPath = Path.extend({\n  type: 'normalCandlestickBox',\n  shape: {},\n  buildPath: function (ctx, shape) {\n    var ends = shape.points;\n\n    if (this.__simpleBox) {\n      ctx.moveTo(ends[4][0], ends[4][1]);\n      ctx.lineTo(ends[6][0], ends[6][1]);\n    } else {\n      ctx.moveTo(ends[0][0], ends[0][1]);\n      ctx.lineTo(ends[1][0], ends[1][1]);\n      ctx.lineTo(ends[2][0], ends[2][1]);\n      ctx.lineTo(ends[3][0], ends[3][1]);\n      ctx.closePath();\n      ctx.moveTo(ends[4][0], ends[4][1]);\n      ctx.lineTo(ends[5][0], ends[5][1]);\n      ctx.moveTo(ends[6][0], ends[6][1]);\n      ctx.lineTo(ends[7][0], ends[7][1]);\n    }\n  }\n});\n\nfunction createNormalBox(itemLayout, dataIndex, isInit) {\n  var ends = itemLayout.ends;\n  return new NormalBoxPath({\n    shape: {\n      points: isInit ? transInit(ends, itemLayout) : ends\n    },\n    z2: 100\n  });\n}\n\nfunction setBoxCommon(el, data, dataIndex, isSimpleBox) {\n  var itemModel = data.getItemModel(dataIndex);\n  var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);\n  var color = data.getItemVisual(dataIndex, 'color');\n  var borderColor = data.getItemVisual(dataIndex, 'borderColor') || color; // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n\n  var itemStyle = normalItemStyleModel.getItemStyle(SKIP_PROPS);\n  el.useStyle(itemStyle);\n  el.style.strokeNoScale = true;\n  el.style.fill = color;\n  el.style.stroke = borderColor;\n  el.__simpleBox = isSimpleBox;\n  var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();\n  graphic.setHoverStyle(el, hoverStyle);\n}\n\nfunction transInit(points, itemLayout) {\n  return zrUtil.map(points, function (point) {\n    point = point.slice();\n    point[1] = itemLayout.initBaseline;\n    return point;\n  });\n}\n\nvar LargeBoxPath = Path.extend({\n  type: 'largeCandlestickBox',\n  shape: {},\n  buildPath: function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n\n    for (var i = 0; i < points.length;) {\n      if (this.__sign === points[i++]) {\n        var x = points[i++];\n        ctx.moveTo(x, points[i++]);\n        ctx.lineTo(x, points[i++]);\n      } else {\n        i += 3;\n      }\n    }\n  }\n});\n\nfunction createLarge(seriesModel, group, incremental) {\n  var data = seriesModel.getData();\n  var largePoints = data.getLayout('largePoints');\n  var elP = new LargeBoxPath({\n    shape: {\n      points: largePoints\n    },\n    __sign: 1\n  });\n  group.add(elP);\n  var elN = new LargeBoxPath({\n    shape: {\n      points: largePoints\n    },\n    __sign: -1\n  });\n  group.add(elN);\n  setLargeStyle(1, elP, seriesModel, data);\n  setLargeStyle(-1, elN, seriesModel, data);\n\n  if (incremental) {\n    elP.incremental = true;\n    elN.incremental = true;\n  }\n}\n\nfunction setLargeStyle(sign, el, seriesModel, data) {\n  var suffix = sign > 0 ? 'P' : 'N';\n  var borderColor = data.getVisual('borderColor' + suffix) || data.getVisual('color' + suffix); // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n\n  var itemStyle = seriesModel.getModel(NORMAL_ITEM_STYLE_PATH).getItemStyle(SKIP_PROPS);\n  el.useStyle(itemStyle);\n  el.style.fill = null;\n  el.style.stroke = borderColor; // No different\n  // el.style.lineWidth = .5;\n}\n\nvar _default = CandlestickView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/candlestick/CandlestickView.js\n// module id = 279\n// module chunks = 0 2","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(option) {\n  if (!option || !zrUtil.isArray(option.series)) {\n    return;\n  } // Translate 'k' to 'candlestick'.\n\n\n  zrUtil.each(option.series, function (seriesItem) {\n    if (zrUtil.isObject(seriesItem) && seriesItem.type === 'k') {\n      seriesItem.type = 'candlestick';\n    }\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/candlestick/preprocessor.js\n// module id = 280\n// module chunks = 0 2","var createRenderPlanner = require(\"../helper/createRenderPlanner\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar positiveBorderColorQuery = ['itemStyle', 'borderColor'];\nvar negativeBorderColorQuery = ['itemStyle', 'borderColor0'];\nvar positiveColorQuery = ['itemStyle', 'color'];\nvar negativeColorQuery = ['itemStyle', 'color0'];\nvar _default = {\n  seriesType: 'candlestick',\n  plan: createRenderPlanner(),\n  // For legend.\n  performRawSeries: true,\n  reset: function (seriesModel, ecModel) {\n    var data = seriesModel.getData();\n    var isLargeRender = seriesModel.pipelineContext.large;\n    data.setVisual({\n      legendSymbol: 'roundRect',\n      colorP: getColor(1, seriesModel),\n      colorN: getColor(-1, seriesModel),\n      borderColorP: getBorderColor(1, seriesModel),\n      borderColorN: getBorderColor(-1, seriesModel)\n    }); // Only visible series has each data be visual encoded\n\n    if (ecModel.isSeriesFiltered(seriesModel)) {\n      return;\n    }\n\n    return !isLargeRender && {\n      progress: progress\n    };\n\n    function progress(params, data) {\n      var dataIndex;\n\n      while ((dataIndex = params.next()) != null) {\n        var itemModel = data.getItemModel(dataIndex);\n        var sign = data.getItemLayout(dataIndex).sign;\n        data.setItemVisual(dataIndex, {\n          color: getColor(sign, itemModel),\n          borderColor: getBorderColor(sign, itemModel)\n        });\n      }\n    }\n\n    function getColor(sign, model) {\n      return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);\n    }\n\n    function getBorderColor(sign, model) {\n      return model.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);\n    }\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/candlestick/candlestickVisual.js\n// module id = 281\n// module chunks = 0 2","var _graphic = require(\"../../util/graphic\");\n\nvar subPixelOptimize = _graphic.subPixelOptimize;\n\nvar createRenderPlanner = require(\"../helper/createRenderPlanner\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar retrieve2 = _util.retrieve2;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar _default = {\n  seriesType: 'candlestick',\n  plan: createRenderPlanner(),\n  reset: function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    var data = seriesModel.getData();\n    var candleWidth = calculateCandleWidth(seriesModel, data);\n    var cDimIdx = 0;\n    var vDimIdx = 1;\n    var coordDims = ['x', 'y'];\n    var cDim = data.mapDimension(coordDims[cDimIdx]);\n    var vDims = data.mapDimension(coordDims[vDimIdx], true);\n    var openDim = vDims[0];\n    var closeDim = vDims[1];\n    var lowestDim = vDims[2];\n    var highestDim = vDims[3];\n    data.setLayout({\n      candleWidth: candleWidth,\n      // The value is experimented visually.\n      isSimpleBox: candleWidth <= 1.3\n    });\n\n    if (cDim == null || vDims.length < 4) {\n      return;\n    }\n\n    return {\n      progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress\n    };\n\n    function normalProgress(params, data) {\n      var dataIndex;\n\n      while ((dataIndex = params.next()) != null) {\n        var axisDimVal = data.get(cDim, dataIndex);\n        var openVal = data.get(openDim, dataIndex);\n        var closeVal = data.get(closeDim, dataIndex);\n        var lowestVal = data.get(lowestDim, dataIndex);\n        var highestVal = data.get(highestDim, dataIndex);\n        var ocLow = Math.min(openVal, closeVal);\n        var ocHigh = Math.max(openVal, closeVal);\n        var ocLowPoint = getPoint(ocLow, axisDimVal);\n        var ocHighPoint = getPoint(ocHigh, axisDimVal);\n        var lowestPoint = getPoint(lowestVal, axisDimVal);\n        var highestPoint = getPoint(highestVal, axisDimVal);\n        var ends = [];\n        addBodyEnd(ends, ocHighPoint, 0);\n        addBodyEnd(ends, ocLowPoint, 1);\n        ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));\n        data.setItemLayout(dataIndex, {\n          sign: getSign(data, dataIndex, openVal, closeVal, closeDim),\n          initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],\n          // open point.\n          ends: ends,\n          brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)\n        });\n      }\n\n      function getPoint(val, axisDimVal) {\n        var p = [];\n        p[cDimIdx] = axisDimVal;\n        p[vDimIdx] = val;\n        return isNaN(axisDimVal) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);\n      }\n\n      function addBodyEnd(ends, point, start) {\n        var point1 = point.slice();\n        var point2 = point.slice();\n        point1[cDimIdx] = subPixelOptimize(point1[cDimIdx] + candleWidth / 2, 1, false);\n        point2[cDimIdx] = subPixelOptimize(point2[cDimIdx] - candleWidth / 2, 1, true);\n        start ? ends.push(point1, point2) : ends.push(point2, point1);\n      }\n\n      function makeBrushRect(lowestVal, highestVal, axisDimVal) {\n        var pmin = getPoint(lowestVal, axisDimVal);\n        var pmax = getPoint(highestVal, axisDimVal);\n        pmin[cDimIdx] -= candleWidth / 2;\n        pmax[cDimIdx] -= candleWidth / 2;\n        return {\n          x: pmin[0],\n          y: pmin[1],\n          width: vDimIdx ? candleWidth : pmax[0] - pmin[0],\n          height: vDimIdx ? pmax[1] - pmin[1] : candleWidth\n        };\n      }\n\n      function subPixelOptimizePoint(point) {\n        point[cDimIdx] = subPixelOptimize(point[cDimIdx], 1);\n        return point;\n      }\n    }\n\n    function largeProgress(params, data) {\n      // Structure: [sign, x, yhigh, ylow, sign, x, yhigh, ylow, ...]\n      var points = new LargeArr(params.count * 5);\n      var offset = 0;\n      var point;\n      var tmpIn = [];\n      var tmpOut = [];\n      var dataIndex;\n\n      while ((dataIndex = params.next()) != null) {\n        var axisDimVal = data.get(cDim, dataIndex);\n        var openVal = data.get(openDim, dataIndex);\n        var closeVal = data.get(closeDim, dataIndex);\n        var lowestVal = data.get(lowestDim, dataIndex);\n        var highestVal = data.get(highestDim, dataIndex);\n\n        if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {\n          points[offset++] = NaN;\n          offset += 4;\n          continue;\n        }\n\n        points[offset++] = getSign(data, dataIndex, openVal, closeVal, closeDim);\n        tmpIn[cDimIdx] = axisDimVal;\n        tmpIn[vDimIdx] = lowestVal;\n        point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n        points[offset++] = point ? point[0] : NaN;\n        points[offset++] = point ? point[1] : NaN;\n        tmpIn[vDimIdx] = highestVal;\n        point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n        points[offset++] = point ? point[1] : NaN;\n      }\n\n      data.setLayout('largePoints', points);\n    }\n  }\n};\n\nfunction getSign(data, dataIndex, openVal, closeVal, closeDim) {\n  var sign;\n\n  if (openVal > closeVal) {\n    sign = -1;\n  } else if (openVal < closeVal) {\n    sign = 1;\n  } else {\n    sign = dataIndex > 0 // If close === open, compare with close of last record\n    ? data.get(closeDim, dataIndex - 1) <= closeVal ? 1 : -1 : // No record of previous, set to be positive\n    1;\n  }\n\n  return sign;\n}\n\nfunction calculateCandleWidth(seriesModel, data) {\n  var baseAxis = seriesModel.getBaseAxis();\n  var extent;\n  var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());\n  var barMaxWidth = parsePercent(retrieve2(seriesModel.get('barMaxWidth'), bandWidth), bandWidth);\n  var barMinWidth = parsePercent(retrieve2(seriesModel.get('barMinWidth'), 1), bandWidth);\n  var barWidth = seriesModel.get('barWidth');\n  return barWidth != null ? parsePercent(barWidth, bandWidth) // Put max outer to ensure bar visible in spite of overlap.\n  : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/candlestick/candlestickLayout.js\n// module id = 282\n// module chunks = 0 2","var echarts = require(\"../echarts\");\n\nrequire(\"./marker/MarkLineModel\");\n\nrequire(\"./marker/MarkLineView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\necharts.registerPreprocessor(function (opt) {\n  // Make sure markLine component is enabled\n  opt.markLine = opt.markLine || {};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/markLine.js\n// module id = 285\n// module chunks = 0 2","var MarkerModel = require(\"./MarkerModel\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = MarkerModel.extend({\n  type: 'markLine',\n  defaultOption: {\n    zlevel: 0,\n    z: 5,\n    symbol: ['circle', 'arrow'],\n    symbolSize: [8, 16],\n    //symbolRotate: 0,\n    precision: 2,\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      show: true,\n      position: 'end'\n    },\n    lineStyle: {\n      type: 'dashed'\n    },\n    emphasis: {\n      label: {\n        show: true\n      },\n      lineStyle: {\n        width: 3\n      }\n    },\n    animationEasing: 'linear'\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkLineModel.js\n// module id = 286\n// module chunks = 0 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar List = require(\"../../data/List\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar markerHelper = require(\"./markerHelper\");\n\nvar LineDraw = require(\"../../chart/helper/LineDraw\");\n\nvar MarkerView = require(\"./MarkerView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n  var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average', 'median'\n\n  var mlType = item.type;\n\n  if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' // In case\n  // data: [{\n  //   yAxis: 10\n  // }]\n  || item.xAxis != null || item.yAxis != null)) {\n    var valueAxis;\n    var valueDataDim;\n    var value;\n\n    if (item.yAxis != null || item.xAxis != null) {\n      valueDataDim = item.yAxis != null ? 'y' : 'x';\n      valueAxis = coordSys.getAxis(valueDataDim);\n      value = zrUtil.retrieve(item.yAxis, item.xAxis);\n    } else {\n      var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);\n      valueDataDim = axisInfo.valueDataDim;\n      valueAxis = axisInfo.valueAxis;\n      value = markerHelper.numCalculate(data, valueDataDim, mlType);\n    }\n\n    var valueIndex = valueDataDim === 'x' ? 0 : 1;\n    var baseIndex = 1 - valueIndex;\n    var mlFrom = zrUtil.clone(item);\n    var mlTo = {};\n    mlFrom.type = null;\n    mlFrom.coord = [];\n    mlTo.coord = [];\n    mlFrom.coord[baseIndex] = -Infinity;\n    mlTo.coord[baseIndex] = Infinity;\n    var precision = mlModel.get('precision');\n\n    if (precision >= 0 && typeof value === 'number') {\n      value = +value.toFixed(Math.min(precision, 20));\n    }\n\n    mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n    item = [mlFrom, mlTo, {\n      // Extra option for tooltip and label\n      type: mlType,\n      valueIndex: item.valueIndex,\n      // Force to use the value of calculated value.\n      value: value\n    }];\n  }\n\n  item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type\n\n  item[2].type = item[2].type || ''; // Merge from option and to option into line option\n\n  zrUtil.merge(item[2], item[0]);\n  zrUtil.merge(item[2], item[1]);\n  return item;\n};\n\nfunction isInifinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markLine has one dim\n\n\nfunction ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  var dimName = coordSys.dimensions[dimIndex];\n  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n}\n\nfunction markLineFilter(coordSys, item) {\n  if (coordSys.type === 'cartesian2d') {\n    var fromCoord = item[0].coord;\n    var toCoord = item[1].coord; // In case\n    // {\n    //  markLine: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n\n    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n\n  return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);\n}\n\nfunction updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPoisition\n      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));\n    } else {\n      var dims = coordSys.dimensions;\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      point = coordSys.dataToPoint([x, y]);\n    } // Expand line to the edge of grid if value on one axis is Inifnity\n    // In case\n    //  markLine: {\n    //    data: [{\n    //      yAxis: 2\n    //      // or\n    //      type: 'average'\n    //    }]\n    //  }\n\n\n    if (coordSys.type === 'cartesian2d') {\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var dims = coordSys.dimensions;\n\n      if (isInifinity(data.get(dims[0], idx))) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n      } else if (isInifinity(data.get(dims[1], idx))) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n\n  data.setItemLayout(idx, point);\n}\n\nvar _default = MarkerView.extend({\n  type: 'markLine',\n  // updateLayout: function (markLineModel, ecModel, api) {\n  //     ecModel.eachSeries(function (seriesModel) {\n  //         var mlModel = seriesModel.markLineModel;\n  //         if (mlModel) {\n  //             var mlData = mlModel.getData();\n  //             var fromData = mlModel.__from;\n  //             var toData = mlModel.__to;\n  //             // Update visual and layout of from symbol and to symbol\n  //             fromData.each(function (idx) {\n  //                 updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n  //                 updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n  //             });\n  //             // Update layout of line\n  //             mlData.each(function (idx) {\n  //                 mlData.setItemLayout(idx, [\n  //                     fromData.getItemLayout(idx),\n  //                     toData.getItemLayout(idx)\n  //                 ]);\n  //             });\n  //             this.markerGroupMap.get(seriesModel.id).updateLayout();\n  //         }\n  //     }, this);\n  // },\n  updateTransform: function (markLineModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mlModel = seriesModel.markLineModel;\n\n      if (mlModel) {\n        var mlData = mlModel.getData();\n        var fromData = mlModel.__from;\n        var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol\n\n        fromData.each(function (idx) {\n          updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n          updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n        }); // Update layout of line\n\n        mlData.each(function (idx) {\n          mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n        });\n        this.markerGroupMap.get(seriesModel.id).updateLayout();\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, mlModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var lineDrawMap = this.markerGroupMap;\n    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());\n    this.group.add(lineDraw.group);\n    var mlData = createList(coordSys, seriesModel, mlModel);\n    var fromData = mlData.from;\n    var toData = mlData.to;\n    var lineData = mlData.line;\n    mlModel.__from = fromData;\n    mlModel.__to = toData; // Line data for tooltip and formatter\n\n    mlModel.setData(lineData);\n    var symbolType = mlModel.get('symbol');\n    var symbolSize = mlModel.get('symbolSize');\n\n    if (!zrUtil.isArray(symbolType)) {\n      symbolType = [symbolType, symbolType];\n    }\n\n    if (typeof symbolSize === 'number') {\n      symbolSize = [symbolSize, symbolSize];\n    } // Update visual and layout of from symbol and to symbol\n\n\n    mlData.from.each(function (idx) {\n      updateDataVisualAndLayout(fromData, idx, true);\n      updateDataVisualAndLayout(toData, idx, false);\n    }); // Update visual and layout of line\n\n    lineData.each(function (idx) {\n      var lineColor = lineData.getItemModel(idx).get('lineStyle.color');\n      lineData.setItemVisual(idx, {\n        color: lineColor || fromData.getItemVisual(idx, 'color')\n      });\n      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n      lineData.setItemVisual(idx, {\n        'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),\n        'fromSymbol': fromData.getItemVisual(idx, 'symbol'),\n        'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),\n        'toSymbol': toData.getItemVisual(idx, 'symbol')\n      });\n    });\n    lineDraw.updateData(lineData); // Set host model for tooltip\n    // FIXME\n\n    mlData.line.eachItemGraphicEl(function (el, idx) {\n      el.traverse(function (child) {\n        child.dataModel = mlModel;\n      });\n    });\n\n    function updateDataVisualAndLayout(data, idx, isFrom) {\n      var itemModel = data.getItemModel(idx);\n      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);\n      data.setItemVisual(idx, {\n        symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n        symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n        color: itemModel.get('itemStyle.color') || seriesData.getVisual('color')\n      });\n    }\n\n    lineDraw.__keep = true;\n    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} coordSys\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\n\nfunction createList(coordSys, seriesModel, mlModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return zrUtil.defaults({\n        name: coordDim\n      }, info);\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var fromData = new List(coordDimsInfos, mlModel);\n  var toData = new List(coordDimsInfos, mlModel); // No dimensions\n\n  var lineData = new List([], mlModel);\n  var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));\n\n  if (coordSys) {\n    optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));\n  }\n\n  var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  };\n  fromData.initData(zrUtil.map(optData, function (item) {\n    return item[0];\n  }), null, dimValueGetter);\n  toData.initData(zrUtil.map(optData, function (item) {\n    return item[1];\n  }), null, dimValueGetter);\n  lineData.initData(zrUtil.map(optData, function (item) {\n    return item[2];\n  }));\n  lineData.hasItemOption = true;\n  return {\n    from: fromData,\n    to: toData,\n    line: lineData\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkLineView.js\n// module id = 287\n// module chunks = 0 2"],"sourceRoot":""}